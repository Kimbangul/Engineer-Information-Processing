# 소프트웨어 개발
## 자료 구조의 분류
1. 선형 구조(Linear Structure)
- 배열(Array)
- 선형 리스트(Linear List)
```
- 연속 리스트(Contiguous List)
- 연결 리스트(Linked List)
```
- 스택(Stack)
- 큐(Queue)
- 데크 (Deque)

2. 비선형 구조(Non-Linear structure)
- 트리(Tree)
- 그래프(Graph)

## 선형 리스트
### 연속 리스트(Contiguous List)
- 연속 리스트는 배열과 같이 연속되는 기억장소에 저장되는 자료 구조이다.
- 연속 리스트는 기억장소를 연속적으로 배정받기 때문에 기억장소 이용 효율은 밀도가 1로서 가장 좋다.
- 연속 리스트는 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 하며, 삽입/삭제 시 자료의 이동이 필요하다.

## 연결 리스트(Linked List)
- 연결 리스트는 자료들을 반드시 연속적으로 배열시키지는 않고 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조이다.
- 연결 리스트는 노드의 삽입/삭제 작업이 용이하다.
- 기억 공간이 연속적으로 놓여 있지 않아도 저장할 수 있다.
- 연결 리스트는 연결을 위한 링크(포인터) 부분이 필요하기 때문에 순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않다.
- 연결 리스트는 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다.
- 연결 리스트는 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다.

## 스택(Stack)
스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.
- 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO: Last In First Out) 방식으로 자료를 처리한다.
- 스택의 응용 분야
```
- 함수 호출의 순서 제어
- 인터럽트의 처리
- 수식 계산 및 수식 표기법
- 컴파일러를 이용한 언어 번역
- 부 프로그램 호출 시 복귀주소 저장
- 서브루틴 호출 및 복귀 주소 저장
```
- 스택의 모든 기억 공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 오버플로(Overflow)가 발생하며, 더이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.

## 큐(Queue)
큐는 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조이다.
- 큐는 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO: First In First Out) 방식으로 처리한다.
- 큐는 시작과 끝을 표시하는 두 개의 포인터가 있다.

## 방향/무방향 그래프의 최대 간선 수
n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1)/2 이고, 방향 그래프애서 최대 간선 수는 n(n-1) 이다.
- 정점이 4개인 경우 무방향 그래프와 방향 그래프의 최대 간선 수는 다음과 같다.
```
무방향 그래프의 최대 간선 수 : 4(4-1)/2 = 6
방향 그래프의 최대 간선 수 : 4(4-1) = 12
```

## 트리의 개요
트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태이다.
- 트리 관련 용어
1. 노드(Node): 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch) 를 합친 것<br />
2. 근 노드(Root Node): 트리의 맨 위에 있는 노드
3. 디그리(Degree, 치수): 각 노드에서 뻗어 나온 가지의 수
4. 단말 노드(Terminal Node) = 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
5. 자식 노드(Son Node): 어떤 노드에 연결된 다음 레벨의 노드들
6. 부모 노드(Parent Node): 어떤 노드에 연결된 이전 레벨의 노드들
7. 형제 노드(Brother Node): 동일한 부모를 갖는 노드들
8. 트리의 디그리: 노드들의 디그리 중에서 가장 많은 수 

## 트리의 운행법
```
  A
 /\
B  C
```
- Preorder 운행: Root -> Left -> Right 순으로 운행 / A,B,C
- Inorder 운행: Left -> Root -> Right 순으로 운행 / B,A,C
- Postorder 운행: Left -> Right -> Root 순으로 운행 / B,C,A

## 수식의 표기법
```
  +
 /\
A  B
```
- 전위 표기법(Prefix): 연산자 -> Left -> Right / +AB
- 중위 표기법(inFix): Left -> Right / A+B
- 후위 표기법(PostFix): Left -> Right -> 연산자/ AB+

### Infix 표기를 Postfix나 Prefix로 바꾸기
Postfix나 Prefix는 스택을 이용하여 처리하므로 Infix는 Postfix나 Prefix로 바꾸어 처리한다.
```
X = A / B * (C+D) + E
```
- Prefix 로 변환하기
1. 연산 우선순위에 따라 괄호로 묶는다.
`(X = ((A/B) * (C+D)) + E))`

2. 연산자를 해당 괄호의 앞(왼쪽)으로 옮긴다.
`(X + (*(/(AB)) +(CD) E))`

3. 필요없는 괄호를 제거한다.
`= X + * / AB + C D E`

- Postfix나 Prefix로 표기된 수식을 Infix로 바꾸기
```
A B C - / D E F + * +
```
Postfix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 뒤로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다.

1. 먼저 인접한 피연산자 두 개와 오른쪽의 연산자를 괄호로 묶는다.
`((A(B C -) /) (D (E F +) *) +)`

2. 연산자를 해당 피연산자의 가운데로 이동시킨다.
`((A / (B - C)) + (D * (E + F)))`

3. 필요 없는 괄호를 제거한다.
`A / (B - C) + D * (E + F)`



```
+ / A - B C * D + E F
```
Prefix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 앞으로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다.

1. 먼저 인접한 피연산자 두 개와 왼쪽의 연산자를 괄호로 묶는다.
`(+ (/ A (- B C) ) (* D (+ E F) ) )`
2. 연산자를 해당 피연산자 사이로 이동시킨다.
`((A/(B-C)) + (D * (E+F)))`
3. 필요 없는 괄호를 제거한다.
`((A/(B-C)) + (D*(E+F))) A/(B-C)+D*(E+F)`

## 삽입 정렬(Insertion Sort)
ex: 8,5,6,2,4 를 삽입 정렬로 정렬하시오.
- 초기 상태: 8|5||6|2|4
- 1회전: 5|8|6|2|4
두 번째 값을 첫 번째 값과 비교하여 5를 첫 번째 자리에 삽입하고 8을 한 칸 뒤로 이동시킨다.
- 2회전: 5|6|8|2|4
세 번째 값을 첫 번째, 두 번째 값과 비교하여 6을 8 자리에 삽입하고 8을 한 칸 뒤로 이동시킨다.
- 3회전: 2 |5 | 6|8|4
네 번째 값 2를 처음부터 비교하여 맨 처음에 삽입하고 나머지를 한 칸씩 뒤로 이동시킨다.
- 4회전: 2|4|5|6|8
다섯 번째 값 4를 처음부터 비교하여 5자리에 삽입하고 나머지를 한 칸씩 뒤로 이동시킨다.

## 선택 정렬(Selection Sort)
ex: 8,5,6,2,4 를 선택 정렬로 정렬하시오.
- 초기 상태: 8|5|6|2|4
- 1회전: 5 8 6 2 4 -> 5 8 6 2 4 -> 2 8 6 5 4 -> 2 8 6 5 4
- 2회전: 2 6 8 5 4 -> 2 5 8 6 4 -> 2 4 8 6 5
- 3회전: 2 4 6 8 5 -> 2 4 5 8 6
- 4회전: 2 4 5 6 8

## 버블 정렬(Bubble Sort)
ex: 8,5,6,2,4 를 버블 정렬로 정렬하시오.
- 초기 상태: 8|5|6|2|4
- 1회전: 5 8 6 2 4 -> 5 6 8 2 4 -> 5 6 2 8 4 ->
5 6 2 4 8
- 2회전: 5 6 2 4 8 -> 5 2 6 4 8 -> 5 2 4 6 8
- 3회전: 2 5 4 6 8 -> 2 4 5 6 8
- 4회전: 2 4 5 6 8

## 퀵 정렬(Quick Sort)
퀵 정렬은 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분해시키는 방식으로 정렬한다.
- 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬한다.
- 평균 수행 시간 복잡도는 O(nlog2n)이고, 최악의 수행 복잡도는 O(n2)이다.

## 힙 정렬(Heap Sort)
힙 정렬은 전이진트리 (Compleate Binary Tree)를 이용한 정렬 방식이다.
- 구성된 전이진 트리를 Heap Tree로 변환하여 정렬한다.
- 평균과 최악 모두 시간 복잡도는 O(nlog2n) 이다.

## 2-Way 합병 정렬(Merge Sort)
2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다.
- 평균과 최악 모두 시간 복잡도는 O(nlog2n)이다.

## 이분 검색
이분 검색(이진 검색, Binary Search)은 전체 파일을 두 개의 서브파일로 분리해 가면서 Key 레코드를 검색하는 방식이다.
- 이분 검색은 반드시 순서화된 파일이어야 검색할 수 있다.
- 찾고자 하는 Key 값을 파일의 중간 레코드 Key 값과 비교하면서 검색한다.
- 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반드로 줄어듦으로 탐색 효율이 좋고 탐색 시간이 적게 소요된다.
- 중간 레코드 번호 M = (F+L)/2 (단, F: 첫 번째 레코드 번호, L: 마지막 레코드 번호)

## 해싱 함수(Hashing Function)
- 제산법(Division): 레코드 키(K)를 해시표(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나눈 나머지를 홈 주소로 삼는 방식, 즉 h(K) = K mod
Q임
- 제곱법(Mid-Square): 레코드 키 값(K)을 제곱한 후 그 중간 부분의 값을 홈 주소로 삼는 방식
- 폴딩법(Folding): 레코드 키 값(K)을 여러 부분으로 나눈 후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값을 홈 주소로 삼는 방식
- 기수 변환법(Radix): 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이를 다시 주소 범위에 맞게 조정하는 방법
- 대수적 코딩법(Algebraic Coding): 키 값을 이루고 있는 각 자리의 비트 수를 한 다항식의 계수로 간주하고, 이 다항식을 해시표의 크기에 의해 정의된 다항식으로 나누어 얻은 나머지 다항식의 계수를 홈 주소로 삼는 방식
- 숫자 분석법(Digit Analysis, 계수 분석법): 키 값을 이루는 숫자의 분포를 분석하여 비교전 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식
- 무작위법(Random): 난수(Random Number)를 발생시켜 나온 값을 홈 주소로 삼는 방식

## DBMS(DataBase Management System: 데이터베이스 관리 시스템)
DBMS란 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어이다.
- DBMS의 필수 기능
1. 정의 기능: 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
2. 조작 기능: 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
3. 제어 기능: 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어해야 함

## DBMS의 장/단점
### 장점
- 데이터의 논리적, 물리적 독립성이 보장됨
- 데이터의 중복을 피할 수 있어 기억 공간이 절약됨
- 저장된 자료를 공통으로 이용할 수 있음
- 데이터의 일관성을 유지할 수 있음
- 데이터의 무결성을 유지할 수 있음
- 보안을 유지할 수 있음
- 데이터를 표준화할 수 있음
- 데이터를 통합하여 관리할 수 있음
- 항상 최신의 데이터를 유지함
- 데이터의 실시간 처리가 가능함

### 단점
- 데이터베이스의 전문가가 부족함
- 전산화 비용이 증가함
- 대용량 디스크로의 집중적인 Access 로 과부하(Overhead) 가 발생함
- 파일의 예비(Backup)와 회복(Recorvery)가 어려움
- 시스템이 복잡함

## 스키마
스키마(Schema)는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specification)를 기술(Description)한 메타데이터(Meta-Data)의 집합이다.
- 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나누어진다.

1. 외부 스키마: 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
2. 개념 스키마: 데이터베이스의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재함
3. 내부 스키마: 물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄

## 절차형 SQL의 테스트와 디버깅
절차형 SQL은 디버깅을 통해 기능의 적합성 여부를 검증하고, 실행을 통해 결과를 확인하는 테스트 과정을 수행한다.
- 테스트와 디버깅의 목적: 테스트(Test)를 통해 오류를 발견한 후 디버깅을 통해 오류가 발생한 소스 코드를 추적하며 수정함

## 단위 모듈(Unit Module)의 개요
단위 모듈은 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것이다.
- 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부른다.
- 단위 모듈은 사용자나 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램을 의미하기도 한다.
- 두 개의 단위 모듈이 합쳐질 경우 두 개의 기능을 구현할 수 있다.
- 단위 모듈의 구성 요소에는 처리문, 명령문, 데이터 구조 등이 있다.
- 단위 모듈은 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 한다.
- 단위 모듈을 구현하기 위해서는 단위 기능 명세서를 작성한 후 입/출력 기능과 알고리즘을 구현해야 한다.
```
단위 기능 명세서 작성 -> 입/출력 기능 구현 -> 알고리즘 구현
```

### IPC (Inter-Process Communication)
IPC는 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합으로, 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다.
- IPC의 대표 메소드 5가지
1. Shared Memory: 다수의 프로세스가 공유 가능한 메모리를 구성하여 프로세스 간 통신을 수행
2. Socket: 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스들 간 통신을 수행
3. Semaphores: 공유 자원에 대한 접근 제어를 통해 프로세스 간 통신을 수행
4. Pipes&named Pipes: 'Pipe' 라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신을 수행, 하나의 프로세스가 Pipe를 이용 중이라면 다른 프로세스는 접근할 수 없음
5. Message Queueing: 메시지가 발생하면 이를 전달하는 형태로 프로세스 간 통신을 수행

## 단위 모듈 테스트의 개요
단위 모듈 테스트는 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것이다.
- 단위 모듈 테스트는 단위 테스트(Unit Test) 라고도 하며, 화이트박스 테스트와 블랙박스 테스트 기법을 사용한다.
- 단위 모듈 테스트를 수행하기 위해서는 모듈을 단독적으로 실행할 수 있는 환경과 테스트에 필요한 데이터가 모두 준비되어야 한다.
- 모듈의 통합 이후에는 오랜 시간 추적해야 발견할 수 있는 에러들도 단위 모듈 테스트를 수행하면 쉽게 발견하고 수정할 수 있다.
- 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다.