# 소프트웨어 개발
## 자료 구조의 분류
1. 선형 구조(Linear Structure)
- 배열(Array)
- 선형 리스트(Linear List)
```
- 연속 리스트(Contiguous List)
- 연결 리스트(Linked List)
```
- 스택(Stack)
- 큐(Queue)
- 데크 (Deque)

2. 비선형 구조(Non-Linear structure)
- 트리(Tree)
- 그래프(Graph)

## 선형 리스트
### 연속 리스트(Contiguous List)
- 연속 리스트는 배열과 같이 연속되는 기억장소에 저장되는 자료 구조이다.
- 연속 리스트는 기억장소를 연속적으로 배정받기 때문에 기억장소 이용 효율은 밀도가 1로서 가장 좋다.
- 연속 리스트는 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 하며, 삽입/삭제 시 자료의 이동이 필요하다.

## 연결 리스트(Linked List)
- 연결 리스트는 자료들을 반드시 연속적으로 배열시키지는 않고 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조이다.
- 연결 리스트는 노드의 삽입/삭제 작업이 용이하다.
- 기억 공간이 연속적으로 놓여 있지 않아도 저장할 수 있다.
- 연결 리스트는 연결을 위한 링크(포인터) 부분이 필요하기 때문에 순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않다.
- 연결 리스트는 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다.
- 연결 리스트는 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다.

## 스택(Stack)
스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.
- 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO: Last In First Out) 방식으로 자료를 처리한다.
- 스택의 응용 분야
```
- 함수 호출의 순서 제어
- 인터럽트의 처리
- 수식 계산 및 수식 표기법
- 컴파일러를 이용한 언어 번역
- 부 프로그램 호출 시 복귀주소 저장
- 서브루틴 호출 및 복귀 주소 저장
```
- 스택의 모든 기억 공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 오버플로(Overflow)가 발생하며, 더이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.

## 큐(Queue)
큐는 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조이다.
- 큐는 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO: First In First Out) 방식으로 처리한다.
- 큐는 시작과 끝을 표시하는 두 개의 포인터가 있다.

## 방향/무방향 그래프의 최대 간선 수
n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1)/2 이고, 방향 그래프애서 최대 간선 수는 n(n-1) 이다.
- 정점이 4개인 경우 무방향 그래프와 방향 그래프의 최대 간선 수는 다음과 같다.
```
무방향 그래프의 최대 간선 수 : 4(4-1)/2 = 6
방향 그래프의 최대 간선 수 : 4(4-1) = 12
```

## 트리의 개요
트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태이다.
- 트리 관련 용어
1. 노드(Node): 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch) 를 합친 것<br />
2. 근 노드(Root Node): 트리의 맨 위에 있는 노드
3. 디그리(Degree, 치수): 각 노드에서 뻗어 나온 가지의 수
4. 단말 노드(Terminal Node) = 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
5. 자식 노드(Son Node): 어떤 노드에 연결된 다음 레벨의 노드들
6. 부모 노드(Parent Node): 어떤 노드에 연결된 이전 레벨의 노드들
7. 형제 노드(Brother Node): 동일한 부모를 갖는 노드들
8. 트리의 디그리: 노드들의 디그리 중에서 가장 많은 수 

## 트리의 운행법
```
  A
 /\
B  C
```
- Preorder 운행: Root -> Left -> Right 순으로 운행 / A,B,C
- Inorder 운행: Left -> Root -> Right 순으로 운행 / B,A,C
- Postorder 운행: Left -> Right -> Root 순으로 운행 / B,C,A

## 수식의 표기법
```
  +
 /\
A  B
```
- 전위 표기법(Prefix): 연산자 -> Left -> Right / +AB
- 중위 표기법(inFix): Left -> Right / A+B
- 후위 표기법(PostFix): Left -> Right -> 연산자/ AB+

### Infix 표기를 Postfix나 Prefix로 바꾸기
Postfix나 Prefix는 스택을 이용하여 처리하므로 Infix는 Postfix나 Prefix로 바꾸어 처리한다.
```
X = A / B * (C+D) + E
```
- Prefix 로 변환하기
1. 연산 우선순위에 따라 괄호로 묶는다.
`(X = ((A/B) * (C+D)) + E))`

2. 연산자를 해당 괄호의 앞(왼쪽)으로 옮긴다.
`(X + (*(/(AB)) +(CD) E))`

3. 필요없는 괄호를 제거한다.
`= X + * / AB + C D E`

- Postfix나 Prefix로 표기된 수식을 Infix로 바꾸기
```
A B C - / D E F + * +
```
Postfix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 뒤로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다.

1. 먼저 인접한 피연산자 두 개와 오른쪽의 연산자를 괄호로 묶는다.
`((A(B C -) /) (D (E F +) *) +)`

2. 연산자를 해당 피연산자의 가운데로 이동시킨다.
`((A / (B - C)) + (D * (E + F)))`

3. 필요 없는 괄호를 제거한다.
`A / (B - C) + D * (E + F)`



```
+ / A - B C * D + E F
```
Prefix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 앞으로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다.

1. 먼저 인접한 피연산자 두 개와 왼쪽의 연산자를 괄호로 묶는다.
`(+ (/ A (- B C) ) (* D (+ E F) ) )`
2. 연산자를 해당 피연산자 사이로 이동시킨다.
`((A/(B-C)) + (D * (E+F)))`
3. 필요 없는 괄호를 제거한다.
`((A/(B-C)) + (D*(E+F))) A/(B-C)+D*(E+F)`

## 삽입 정렬(Insertion Sort)
ex: 8,5,6,2,4 를 삽입 정렬로 정렬하시오.
- 초기 상태: 8|5||6|2|4
- 1회전: 5|8|6|2|4
두 번째 값을 첫 번째 값과 비교하여 5를 첫 번째 자리에 삽입하고 8을 한 칸 뒤로 이동시킨다.
- 2회전: 5|6|8|2|4
세 번째 값을 첫 번째, 두 번째 값과 비교하여 6을 8 자리에 삽입하고 8을 한 칸 뒤로 이동시킨다.
- 3회전: 2 |5 | 6|8|4
네 번째 값 2를 처음부터 비교하여 맨 처음에 삽입하고 나머지를 한 칸씩 뒤로 이동시킨다.
- 4회전: 2|4|5|6|8
다섯 번째 값 4를 처음부터 비교하여 5자리에 삽입하고 나머지를 한 칸씩 뒤로 이동시킨다.

## 선택 정렬(Selection Sort)
ex: 8,5,6,2,4 를 선택 정렬로 정렬하시오.
- 초기 상태: 8|5|6|2|4
- 1회전: 5 8 6 2 4 -> 5 8 6 2 4 -> 2 8 6 5 4 -> 2 8 6 5 4
- 2회전: 2 6 8 5 4 -> 2 5 8 6 4 -> 2 4 8 6 5
- 3회전: 2 4 6 8 5 -> 2 4 5 8 6
- 4회전: 2 4 5 6 8

## 버블 정렬(Bubble Sort)
ex: 8,5,6,2,4 를 버블 정렬로 정렬하시오.
- 초기 상태: 8|5|6|2|4
- 1회전: 5 8 6 2 4 -> 5 6 8 2 4 -> 5 6 2 8 4 ->
5 6 2 4 8
- 2회전: 5 6 2 4 8 -> 5 2 6 4 8 -> 5 2 4 6 8
- 3회전: 2 5 4 6 8 -> 2 4 5 6 8
- 4회전: 2 4 5 6 8

## 퀵 정렬(Quick Sort)
퀵 정렬은 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분해시키는 방식으로 정렬한다.
- 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬한다.
- 평균 수행 시간 복잡도는 O(nlog2n)이고, 최악의 수행 복잡도는 O(n2)이다.

## 힙 정렬(Heap Sort)
힙 정렬은 전이진트리 (Compleate Binary Tree)를 이용한 정렬 방식이다.
- 구성된 전이진 트리를 Heap Tree로 변환하여 정렬한다.
- 평균과 최악 모두 시간 복잡도는 O(nlog2n) 이다.

## 2-Way 합병 정렬(Merge Sort)
2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다.
- 평균과 최악 모두 시간 복잡도는 O(nlog2n)이다.

## 이분 검색
이분 검색(이진 검색, Binary Search)은 전체 파일을 두 개의 서브파일로 분리해 가면서 Key 레코드를 검색하는 방식이다.
- 이분 검색은 반드시 순서화된 파일이어야 검색할 수 있다.
- 찾고자 하는 Key 값을 파일의 중간 레코드 Key 값과 비교하면서 검색한다.
- 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반드로 줄어듦으로 탐색 효율이 좋고 탐색 시간이 적게 소요된다.
- 중간 레코드 번호 M = (F+L)/2 (단, F: 첫 번째 레코드 번호, L: 마지막 레코드 번호)

## 해싱 함수(Hashing Function)
- 제산법(Division): 레코드 키(K)를 해시표(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나눈 나머지를 홈 주소로 삼는 방식, 즉 h(K) = K mod
Q임
- 제곱법(Mid-Square): 레코드 키 값(K)을 제곱한 후 그 중간 부분의 값을 홈 주소로 삼는 방식
- 폴딩법(Folding): 레코드 키 값(K)을 여러 부분으로 나눈 후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값을 홈 주소로 삼는 방식
- 기수 변환법(Radix): 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이를 다시 주소 범위에 맞게 조정하는 방법
- 대수적 코딩법(Algebraic Coding): 키 값을 이루고 있는 각 자리의 비트 수를 한 다항식의 계수로 간주하고, 이 다항식을 해시표의 크기에 의해 정의된 다항식으로 나누어 얻은 나머지 다항식의 계수를 홈 주소로 삼는 방식
- 숫자 분석법(Digit Analysis, 계수 분석법): 키 값을 이루는 숫자의 분포를 분석하여 비교전 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식
- 무작위법(Random): 난수(Random Number)를 발생시켜 나온 값을 홈 주소로 삼는 방식

## DBMS(DataBase Management System: 데이터베이스 관리 시스템)
DBMS란 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어이다.
- DBMS의 필수 기능
1. 정의 기능: 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
2. 조작 기능: 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
3. 제어 기능: 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어해야 함

## DBMS의 장/단점
### 장점
- 데이터의 논리적, 물리적 독립성이 보장됨
- 데이터의 중복을 피할 수 있어 기억 공간이 절약됨
- 저장된 자료를 공통으로 이용할 수 있음
- 데이터의 일관성을 유지할 수 있음
- 데이터의 무결성을 유지할 수 있음
- 보안을 유지할 수 있음
- 데이터를 표준화할 수 있음
- 데이터를 통합하여 관리할 수 있음
- 항상 최신의 데이터를 유지함
- 데이터의 실시간 처리가 가능함

### 단점
- 데이터베이스의 전문가가 부족함
- 전산화 비용이 증가함
- 대용량 디스크로의 집중적인 Access 로 과부하(Overhead) 가 발생함
- 파일의 예비(Backup)와 회복(Recorvery)가 어려움
- 시스템이 복잡함

## 스키마
스키마(Schema)는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specification)를 기술(Description)한 메타데이터(Meta-Data)의 집합이다.
- 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나누어진다.

1. 외부 스키마: 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
2. 개념 스키마: 데이터베이스의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재함
3. 내부 스키마: 물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄

## 절차형 SQL의 테스트와 디버깅
절차형 SQL은 디버깅을 통해 기능의 적합성 여부를 검증하고, 실행을 통해 결과를 확인하는 테스트 과정을 수행한다.
- 테스트와 디버깅의 목적: 테스트(Test)를 통해 오류를 발견한 후 디버깅을 통해 오류가 발생한 소스 코드를 추적하며 수정함

## 단위 모듈(Unit Module)의 개요
단위 모듈은 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것이다.
- 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부른다.
- 단위 모듈은 사용자나 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램을 의미하기도 한다.
- 두 개의 단위 모듈이 합쳐질 경우 두 개의 기능을 구현할 수 있다.
- 단위 모듈의 구성 요소에는 처리문, 명령문, 데이터 구조 등이 있다.
- 단위 모듈은 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 한다.
- 단위 모듈을 구현하기 위해서는 단위 기능 명세서를 작성한 후 입/출력 기능과 알고리즘을 구현해야 한다.
```
단위 기능 명세서 작성 -> 입/출력 기능 구현 -> 알고리즘 구현
```

### IPC (Inter-Process Communication)
IPC는 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합으로, 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다.
- IPC의 대표 메소드 5가지
1. Shared Memory: 다수의 프로세스가 공유 가능한 메모리를 구성하여 프로세스 간 통신을 수행
2. Socket: 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스들 간 통신을 수행
3. Semaphores: 공유 자원에 대한 접근 제어를 통해 프로세스 간 통신을 수행
4. Pipes&named Pipes: 'Pipe' 라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신을 수행, 하나의 프로세스가 Pipe를 이용 중이라면 다른 프로세스는 접근할 수 없음
5. Message Queueing: 메시지가 발생하면 이를 전달하는 형태로 프로세스 간 통신을 수행

## 단위 모듈 테스트의 개요
단위 모듈 테스트는 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것이다.
- 단위 모듈 테스트는 단위 테스트(Unit Test) 라고도 하며, 화이트박스 테스트와 블랙박스 테스트 기법을 사용한다.
- 단위 모듈 테스트를 수행하기 위해서는 모듈을 단독적으로 실행할 수 있는 환경과 테스트에 필요한 데이터가 모두 준비되어야 한다.
- 모듈의 통합 이후에는 오랜 시간 추적해야 발견할 수 있는 에러들도 단위 모듈 테스트를 수행하면 쉽게 발견하고 수정할 수 있다.
- 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다.

## 테스트 케이스(Test Case)
테스트 케이스는 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당된다.
- 단위 모듈을 테스트하기 전에 테스트에 필요한 입력 데이터, 테스트 조건, 예상 결과 등을 모아 테스트 케이스를 만든다.
- 테스트 케이스를 이용하지 않고 수행하는 직관적인 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다.
- ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소는 다음과 같다.
1. 식별자(identifier): 항목 식별자, 일련번호
2. 테스트 항목(Test item): 테스트 대상(모듈 또는 기능)
3. 입력 명세(Input Specification): 입력 데이터 또는 테스트 조건
4. 출력 명세(Output Specification): 테스트 케이스 수행 시 예상되는 출력 결과 
5. 환경 설정(Environmental Needs): 필요한 하드웨어나 소프트웨어의 환경
6. 특수 절차 요구(Special Procedure Requirement): 테스트 케이스 수행 시 특별히 요구되는 절차
7. 의존성 기술(Inter-case Dependencies): 테스트 케이스간의 의존성

## 통합 개발 환경(IDE; Integrated Development Environment)
통합 개발 환경은 코딩, 디버그, 컴파일, 배포 등 프로그램 개발과 관련된 모든 작업을 하나의 프로그램에서 처리할 수 있도록 제공하는 소프트웨어적인 개발 환경을 말한다.
- 기존 소프트웨어 개발에서는 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger) 등의 다양한 툴을 별도로 사용했으나 현재는 하나의 인터페이스로 통합하여 제공한다.
- 통합 개발 환경 도구는 통합 개발 환경을 제공하는 소프트웨어를 의미한다.
- 통합 개발 환경을 지원하는 도구는 플랫폼, 운영체제, 언어별로 다양하게 존재한다.
- 통합 개발 환경 도구의 대표적인 기능
1. 코딩(Coding): C, Java 등의 프로그래밍 언어로 프로그램을 작성하는 기능
2. 컴파일(Compile): 개발자가 작성한 고급 언어로 된 프로그램을 컴퓨터가 이해할 수 있는 목적 프로그램으로 번역하여 컴퓨터에서 실행 가능한 형태로 변환하는 기능
3. 디버깅(Debugging): 소프트웨어나 하드웨어의 오류나 잘못된 동작, 즉 버그(Bug)를 찾아 수정하는 기능
4. 배포(Deployment): 소프트웨어를 사용자에게 전달하는 기능

## 빌드 도구
빌드는 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물을 말한다.
- 빌드 도구는 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리(Preprocessing), 컴파일(Compile) 등의 작업을 수행하는 소프트웨어를 말한다.
- 대표적인 도구로는 Ant, Maven, Gradle 등이 있다.
1. Ant: 아파치 소프트웨어 재단에서 개발한 소프트웨어로, 자바 프로젝트의 공식적인 빌드 도구로 사용되고 있음.
2. Maven: Ant와 동일한 아파치 소프트웨어 재단에서 개발된 것으로, Ant의 대안으로 개발되었음
3. Gradle: 기존의 Ant와 Maven을 보완하여 개발된 빌드 도구로, 한스 도커(Hans Docker)외 6인의 개발자가 모여 공동 개발하였음

## 소프트웨어 패키징의 개요
소프트웨어 패키징이란 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것을 말한다.
- 개발자가 아니라 사용자를 중심으로 진행한다.
- 소스 코드는 향후 관리를 고려하여 모듈화하여 패키징한다.
- 사용자가 소프트웨어를 사용하게 될 환경을 이해하여, 다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징한다.

## 패키징 시 고려사항
- 사용장의 시스템 환경, 즉 운영체제(OS), CPU, 메모리 등에 필요한 최소 환경을 정의한다.
- UI(User Interface)는 사용자가 눈으로 직접 확인할 수 있도록 시각적인 자료와 함께 제공하고 메뉴얼과 일치시켜 패키징한다.
- 소프트웨어는 단순히 패키징하여 배포하는 것으로 끝나는것이 아니라 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공하는 것이 좋다.
- 사용자에게 배포되는 소프트웨어이므로 내부 콘텐츠에 대한 암호화 및 보안을 고려한다.
- 다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관리) 연동을 고려한다.
- 사용자의 편의성을 위한 복잡성 및 비효율성 문제를 고려항다.
- 제품 소프트웨어 종류에 적합한 알고리즘을 적용한다.

## 릴리즈 노트(Release Note)의 개요
릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 공유하기 위한 문서이다.
- 릴리즈 노트를 통해 테스트 진행 방법에 대한 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부를 확인할 수 있다.
- 소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선사항 등을 사용자와 공유할 수 있다.
- 릴리즈 노트를 이용해 소프트웨어의 버전 관리나 릴리즈 정보를 체계적으로 관리할 수 있다.
- 릴리즈 노트는 소프트웨어의 초기 배포 시 또는 출시 후 개선 사항을 적용한 추가 배포 시에 제공한다.

## 릴리즈 노트 초기 버전 작성 시 고려사항
릴리즈 노트의 초기 버전은 다음의 사항을 고려하여 작성한다.
- 릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성해야 한다.
- 신규 소스, 빌드 등의 이력이 정확하게 관리되어 변경 또는 개선된 항목에 대한 이력 정보들도 작성되어야 한다.
- 릴리즈 노트 작성에 대한 표준 형식은 없지만 일반적으로 다음과 같은 항목이 포함된다.
1. Header(머릿말)
2. 개요
3. 목적
4. 문제 요약
5. 재현 항목
6. 수정/개선 내용
7. 사용자 영향도
8. SW 지원 영향도
9. 노트
10. 면책 조항
11. 연락처

## 디지털 저작권 관리 (DRM: Digital Right Management)
디지털 저작권 관리는 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술이다.
- 원본 콘텐츠가 아날로그인 경우에는 디지털로 변환한 후 패키저(Packager)에 의해 DRM 패키징을 수행한다.
- 콘텐츠의 크기에 따라 음원이나 문서와 같이 크기가 작은 경우에는 사용자가 콘텐츠를 요청하는 시점에서 실시간으로 패키징을 수행하고, 크기가 큰 경우에는 미리 패키징을 수행한 후 배포한다.
- 패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함되고 저작권자가 설정한 라이선스 정보가 클리어링 하우스(clearing House)에 등록된다.
- 사용자가 콘텐츠를 사용하기 위해서는 클리어링 하우스에 등록된 라이선스 정보를 통해 사용자 인증과 콘텐츠 사용 권한 소유 여부를 확인받아야 한다.
- 종량제 방식을 적용한 소프트웨어의 경우 클리어링 하우스를 통해 서비스의 실제 사용량을 측정하여 이용한 만큼의 요금을 부과한다.

## 디지털 저작권 관리(DRM)의 구성요소
- 클리어링 하우스: 저작권에 대한 사용 권한, 라이선스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳
- 콘텐츠 제공자(Contents Providder): 콘텐츠를 제공하는 저작권자
- 패키저(Packager): 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
- 콘텐츠 소비자(Customer): 콘텐츠를 구매해서 사용하는 주체
- DRM 컨트롤러(DRM Controller): 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
- 보안 컨테이너(security container): 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

## 디지털 저작권 관리의 기술 요소
- 암호화(Encryption): 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술
- 키 관리(Key Management): 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
- 암호화 파일 생성(Packager): 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
- 식별 기술(idenfication): 콘텐츠에 대한 식별 체계 표현 기술
- 저작권 표현(Right Expression): 라이선스의 내용 표현 기술
- 정책 관리(Policy Management): 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
- 크랙 방지(Tamper Resistance): 크랙에 의한 콘텐츠 사용 방지 기술
- 인증(Authentication): 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

## 소프트웨어 설치 메뉴얼의 개요
소프트웨어 설치 매뉴얼은 개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서이다.
- 설치 매뉴얼은 사용자 기준으로 작성한다.
- 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명한다.
- 설치 과정에서 표시될 수 있는 오류 메시지 및 예외 상황에 관한 내용을 별도로 분류하여 설명한다.
- 소프트웨어 설치 메뉴얼에는 목차 및 개요, 서문, 기본 사항 등이 기본적으로 포함되어야 한다.
- 기능 식별 -> UI 분류 -> 설치 파일/백업 파일 확인 -> 언인스톨 절차 확인 -> 이상 케이스 확인 -> 최종 메뉴얼 적용

## 소프트웨어 설치 매뉴얼의 기본 사항
1. 소프트웨어 개요
- 소프트웨어의 주요 기능 및 UI 설명
- UI 및 화면 상의 버튼, 프레임 등을 그림으로 설명
2. 설치 관련 파일
- 소프트웨어 설치에 필요한 파일 설명
- exe, ini, log 등의 파일 설명
3. 설치 아이콘(installation): 설치 아이콘 설명
4. 프로그램 삭제: 설치된 소프트웨어의 삭제 방법 설명
5. 관련 추가 정보
- 소프트웨어 이외의 관련 설치 프로그램 정보
- 소프트웨어 제작사 등의 추가 정보 기술

## 소프트웨어 사용자 매뉴얼의 개요
소프트웨어 사용자 매뉴얼은 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 문서로 기록한 설명서와 안내서이다.
- 사용자 매뉴얼은 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반 사항이 모두 포함되도록 작성한다.
- 소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 매뉴얼의 버전을 관리한다.
- 개별적으로 동작이 가능한 컴포넌트 단위로 매뉴얼을 작성한다.
- 사용자 매뉴얼은 컴포넌트 명세서와 컴포넌트 구현 설계서를 토대로 작성한다.
- 사용자 매뉴얼에는 목차 및 개요, 서문, 기본 사항 등이 기본적으로 포함되어야 한다.
- 작성 지침 정의 -> 사용자 매뉴얼 구성 요소 정의 -> 구성 요소별 내용 작성 -> 사용자 매뉴얼 검토

## 소프트웨어 패키징의 형상 관리
형상 관리(SCM: software configuration management)는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동이다.
- 소프트웨어 변경의 원인을 알아내고 제어하며, 적절히 변경되고 있는지 확인하여 해당 담당자에게 통보한다.
- 형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행된다.
- 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 한다.
- 관리 항목에는 소스 코드뿐만 아니라 각종 정의서, 지침서, 분석서 등이 포함된다.
- 형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 높일 수 있다.
- 대표적인 형상 관리 도구에는 Git, CVS, Subversion 등이 있다.

## 형상 관리의 중요성
- 지속적인 소프트웨어의 변경 사항을 체계적으로 추적하고 통제할 수 있다.
- 제품 소프트웨어에 대한 무절제한 변경을 방지할 수 있다.
- 제품 소프트웨어에서 발견된 버그나 수정 사항을 추적할 수 있다.
- 소프트웨어는 형태가 없어 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준으로 사용될 수 있다.
- 소프트웨어의 배포본을 효율적으로 관리할 수 있다.
- 소프트웨어를 여러 명의 개발자가 동시에 개발할 수 있다.

## 형상 관리 기능
- 형상 식별: 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree)구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
- 버전 제어: 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구(Tool)를 결합시키는 작업
- 형상 통제(변경 관리): 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정하는 작업
- 형상 검사: 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
- 형상 기록(상태 보고): 형상의 식별, 통제, 감사 작업의 결과를 기록/관리하고 보고서를 작성하는 작업

## 소프트웨어 버전 등록 관련 주요 기능
1. 저장소(Repository): 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳
2. 가져오기(import): 버전 관리가 되고 있지 않은 아무것도 없는 저장소에 처음으로 파일을 복사함
3. 체크아웃(Check-out): 프로그램을 수정하기 위해 저장소에서 파일을 받아옴. 소스 파일과 함께 버전 관리를 위한 파일들도 받아옴
4. 체크인(Check-in): 체크아웃한 파일의 수정을 완료한 후 저장소(repository)의 파일을 새로운 버전으로 갱신함
5. 커밋(Commit): 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌(Conflict)을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료함
6. 동기화(Update): 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화함

## 공유 폴더 방식
공유 폴더 방식은 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식으로, 다음과 같은 특징이 있다.
- 개발자들은 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사한다.
- 담당자들은 공유 폴더의 파일을 자기 PC로 복사한 후 컴파일 하여 이상 유무를 확인한다.
- 종류에는 SCSS, RCS, PVCS, QVCS 등이 있다.

## 클라이언트/서버 방식
클라이언트/서버 방식은 버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리되는 방식으로, 다음과 같은 특징이 있다.
- 서버의 자료를 개발자별로 자신의 PC(클라이언트)로 복사하여 작업한 후 변경된 내용을 서버에 반영한다.
- 모든 버전 관리는 서버에서 수행된다.
- 종류에는 CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perfoce 등이 있다.

## 분산 저장소 방식
분산 저장소 방식은 버전 관리 자료가 하나의 원격 저장소의 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식으로, 다음과 같은 특징이 있다.
- 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업한 후 변경된 내용을 로컬 저장소에서 우선 반영(버전 관리)한 다음 이를 원격 저장소에 반영한다.
- 로컬 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업할 수 있다.
- 종류에는 Git, CNU arch, DCVS, Bazzzar, Mercurial, TeamWare, Bitkeeper, Plastic SCM 등이 있다.

## Subversion(서브버전, SVN)
Subversion은 CVS를 개선한 것으로, 아파치 소프트웨어 재단에서 2000년에 발표하였다.
- 클라이언트/서버 구조로 서버(저장소, Repository)에는 최신 버전의 파일들과 변경 내역이 관리된다.
- 서버의 자료를 클라이언트로 복사해와 작업한 후 변경 내용을 서버에 반영(Commit) 한다.
- 모든 개발 작업은 trunk 디렉터리에서 수행되며, 추가 작업은 branches 디렉터리 안에 별도의 디렉터리를 만들어 작업을 완료한 후 trunk 디렉터리와 병합(merge)한다.
- 커밋(Commit)할 때마다 리비전(Revision)이 1씩 증가한다.
- 클라이언트는 대부분의 운영체제에서 사용되지만, 서버는 주로 유닉스를 사용한다.
- 소스가 오픈되어 있어 무료로 사용할 수 있다.
- CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능하다.

## Git(깃)
Git은 리누스 토발즈가 2005년 리눅스 커널 개발에 사용할 관리 도구로 개발한 이후 주니어 하마노에 의해 유지 보수되고 있다.
- Git은 분산 버전 관리 시스템으로 2개의 저장소, 즉 지역(로컬)저장소와 원격 저장소가 존재한다.
- 지역 저장소는 개발자들이 실제 개발을 진행하는 장소로, 버전 관리가 수행된다.
- 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳으로, 자신의 버전 관리 내역을 반영하거나 다른 개발자의 변경 내용을 가져올 때 사용한다.
- 버전 관리가 지역 저장소에서 진행되므로 버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업이 가능하다.
- 브랜치를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅이 가능하다.
- 파일의 변화를 스냅샷(Snapshot)으로 저장하는데, 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름을 파악할 수 있다.

## 빌드 자동화 도구의 개념
빌드란 소스 코드 파일들을 컴파일한 후 여러개의 모듈을 묶어 실행 파일로 만드는 과정이며, 이러한 빌드를 포함하여 테스트 및 배포를 자동화하는 도구를 빌드 자동화 도구라고 한다.
- 애자일 환경에서는 하나의 작업이 마무리될 때마다 모듈 단위로 나눠서 개발된 코드들이 지속적으로 통합되는데, 이러한 지속적인 통합(Continuous Integration)개발 환경에서 빌드 자동화 도구는 유용하게 활용된다.
- 빌드 자동화 도구에는 Ant, Make, Maven, Gradle, Jenkins 등이 있으며, 이중 Jenkins와 Gradle이 가장 대표적이다.

## Jenkins
Jenkins는 JAVA 기반의 오픈 소스 형태로, 가장 많이 사용되는 빌드 자동화 도구이다.
- 서블릿 컨테이너에서 실행되는 서버 기반 도구이다.
- SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능하다.
- 친숙한 Web GUI 제공으로 사용이 쉽다.
- 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트가 가능하다.

## Gradle
Gradle은 Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구로, 안드로이드 앱 개발 환경에서 사용된다.
- 안드로이드 뿐만 아니라 플러그인을 설정하면, Java, C/C++, Python 등의 언어도 빌드가 가능하다.
- Groovy를 사용해서 만든 DSL(Comain Specific Language)을 스크립트 언어로 사용한다.
- Gradle은 실핸할 처리 명령들을 모아 태스크(Task)로 만든 후 태스크 단위로 실행한다.
- 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능을 지원하므로 빌드의 속도를 향상시킬 수 있다.

## 애플리케이션 테스트의 개념
애플리케이션 테스트는 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차이다.
- 애플리케이션 테스트는 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인(Validation)하고 소프트웨어가 기능을 정확히 수행하는지 검증(Veification)한다.
1. 확인(Validation): 사용자의 입장에서 개발한 소프트웨어가 고객의 요구사항에 맞게 구현되었는지를 확인하는 것
2. 검증(Verification): 개발자의 입장에서 개발한 소프트웨어가 명세서에 맞게 만들어졌는지를 점검하는 것

## 애플리케이션 테스트 관련 용어
### 결함 집중(Detect Clustering)
대부분의 결함이 소수의 특정 모듈에 집중해서 발생하는 것이다.

### 파레토 법칙(Paret Principle)
상위 20% 사람들이 전체 부의 80%를 가지고 있다거나, 상위 20% 고객이 매출 80%를 창출한다는 의미로, 이 법칙이 애플리케이션 테스트에도 적용된다는 것이다. 즉, 테스트로 발견된 80%의 오류는 20%의 모듈에서 발견되므로 20개의 모듈을 집중적으로 테스트하여 효율적으로 오류를 찾자는 것이다. 

### 살충제 패러독스(Pesticide Paradox)
살충제를 지속적으로 뿌리면 벌레가 내성이 생겨서 죽지 않는 현상을 의미한다.

## 오류-부재의 궤변(Absence of Errors Fallacy)
소프트웨어의 겨함을 모두 분석해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말 할 수 없다는 것을 의미한다.

## 프로그램 실행 여부애 따른 테스트
1. 정적 테스트
- 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트
- 소프트웨어 개발 초기에 결함을 발견할 수 있어 소프트웨어의 개발 비용을 낮추는데 도움이 됨
- 종류: 워크스루, 인스펙션, 코드 검사 등
2. 동적 테스트
- 프로그램을 실행하여 오류를 찾는 테스트로, 소프트웨어 개발의 모든 단계에서 테스트를 수행할 수 있음
- 종류: 블랙박스 테스트, 화이트박스 테스트

## 테스트 기반(Test Bases)에 따른 테스트
1. 명세 기반 테스트
- 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
- 종류: 동등 분할, 경계 값 분석

2. 구조 기반 테스트
- 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트
- 종류: 구문 기반, 결정 기반, 조건 기반 등

3. 경험 기반 테스트
- 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트
- 경험 기반 테스트는 사용자의 요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 수행하면 효과적
- 종류: 에러 추정, 체크 리스트, 탐색적 테스팅

## 시각에 따른 테스트
1. 검증(Verification) 테스트: 개발자의 시각에서 제품의 생산 과정을 테스트하는 것으로, 제품이 명세서대로 완성됐는지를 테스트함
2. 확인(Validation) 테스트: 사용자의 시각에서 생산된 제품의 결과를 테스트하는 것으로, 사용자가 요구한대로 제품이 완성됐는지, 제품이 정상적으로 동작하는지를 테스트함