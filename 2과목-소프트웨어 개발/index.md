# 소프트웨어 개발
## 자료 구조의 분류
1. 선형 구조(Linear Structure)
- 배열(Array)
- 선형 리스트(Linear List)
```
- 연속 리스트(Contiguous List)
- 연결 리스트(Linked List)
```
- 스택(Stack)
- 큐(Queue)
- 데크 (Deque)

2. 비선형 구조(Non-Linear structure)
- 트리(Tree)
- 그래프(Graph)

## 선형 리스트
### 연속 리스트(Contiguous List)
- 연속 리스트는 배열과 같이 연속되는 기억장소에 저장되는 자료 구조이다.
- 연속 리스트는 기억장소를 연속적으로 배정받기 때문에 기억장소 이용 효율은 밀도가 1로서 가장 좋다.
- 연속 리스트는 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 하며, 삽입/삭제 시 자료의 이동이 필요하다.

## 연결 리스트(Linked List)
- 연결 리스트는 자료들을 반드시 연속적으로 배열시키지는 않고 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조이다.
- 연결 리스트는 노드의 삽입/삭제 작업이 용이하다.
- 기억 공간이 연속적으로 놓여 있지 않아도 저장할 수 있다.
- 연결 리스트는 연결을 위한 링크(포인터) 부분이 필요하기 때문에 순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않다.
- 연결 리스트는 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다.
- 연결 리스트는 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다.

## 스택(Stack)
스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.
- 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO: Last In First Out) 방식으로 자료를 처리한다.
- 스택의 응용 분야
```
- 함수 호출의 순서 제어
- 인터럽트의 처리
- 수식 계산 및 수식 표기법
- 컴파일러를 이용한 언어 번역
- 부 프로그램 호출 시 복귀주소 저장
- 서브루틴 호출 및 복귀 주소 저장
```
- 스택의 모든 기억 공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 오버플로(Overflow)가 발생하며, 더이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.

## 큐(Queue)
큐는 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조이다.
- 큐는 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO: First In First Out) 방식으로 처리한다.
- 큐는 시작과 끝을 표시하는 두 개의 포인터가 있다.

## 방향/무방향 그래프의 최대 간선 수
n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1)/2 이고, 방향 그래프애서 최대 간선 수는 n(n-1) 이다.
- 정점이 4개인 경우 무방향 그래프와 방향 그래프의 최대 간선 수는 다음과 같다.
```
무방향 그래프의 최대 간선 수 : 4(4-1)/2 = 6
방향 그래프의 최대 간선 수 : 4(4-1) = 12
```

## 트리의 개요
트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태이다.
- 트리 관련 용어
1. 노드(Node): 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch) 를 합친 것<br />
2. 근 노드(Root Node): 트리의 맨 위에 있는 노드
3. 디그리(Degree, 치수): 각 노드에서 뻗어 나온 가지의 수
4. 단말 노드(Terminal Node) = 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
5. 자식 노드(Son Node): 어떤 노드에 연결된 다음 레벨의 노드들
6. 부모 노드(Parent Node): 어떤 노드에 연결된 이전 레벨의 노드들
7. 형제 노드(Brother Node): 동일한 부모를 갖는 노드들
8. 트리의 디그리: 노드들의 디그리 중에서 가장 많은 수 

## 트리의 운행법
```
  A
 /\
B  C
```
- Preorder 운행: Root -> Left -> Right 순으로 운행 / A,B,C
- Inorder 운행: Left -> Root -> Right 순으로 운행 / B,A,C
- Postorder 운행: Left -> Right -> Root 순으로 운행 / B,C,A

## 수식의 표기법
```
  +
 /\
A  B
```
- 전위 표기법(Prefix): 연산자 -> Left -> Right / +AB
- 중위 표기법(inFix): Left -> Right / A+B
- 후위 표기법(PostFix): Left -> Right -> 연산자/ AB+

### Infix 표기를 Postfix나 Prefix로 바꾸기
Postfix나 Prefix는 스택을 이용하여 처리하므로 Infix는 Postfix나 Prefix로 바꾸어 처리한다.
```
X = A / B * (C+D) + E
```
- Prefix 로 변환하기
1. 연산 우선순위에 따라 괄호로 묶는다.
`(X = ((A/B) * (C+D)) + E))`

2. 연산자를 해당 괄호의 앞(왼쪽)으로 옮긴다.
`(X + (*(/(AB)) +(CD) E))`

3. 필요없는 괄호를 제거한다.
`= X + * / AB + C D E`

- Postfix나 Prefix로 표기된 수식을 Infix로 바꾸기
```
A B C - / D E F + * +
```