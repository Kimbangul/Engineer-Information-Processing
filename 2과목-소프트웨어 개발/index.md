# 소프트웨어 개발
## 자료 구조의 분류
1. 선형 구조(Linear Structure)
- 배열(Array)
- 선형 리스트(Linear List)
```
- 연속 리스트(Contiguous List)
- 연결 리스트(Linked List)
```
- 스택(Stack)
- 큐(Queue)
- 데크 (Deque)

2. 비선형 구조(Non-Linear structure)
- 트리(Tree)
- 그래프(Graph)

## 선형 리스트
### 연속 리스트(Contiguous List)
- 연속 리스트는 배열과 같이 연속되는 기억장소에 저장되는 자료 구조이다.
- 연속 리스트는 기억장소를 연속적으로 배정받기 때문에 기억장소 이용 효율은 밀도가 1로서 가장 좋다.
- 연속 리스트는 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 하며, 삽입/삭제 시 자료의 이동이 필요하다.

## 연결 리스트(Linked List)
- 연결 리스트는 자료들을 반드시 연속적으로 배열시키지는 않고 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조이다.
- 연결 리스트는 노드의 삽입/삭제 작업이 용이하다.
- 기억 공간이 연속적으로 놓여 있지 않아도 저장할 수 있다.
- 연결 리스트는 연결을 위한 링크(포인터) 부분이 필요하기 때문에 순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않다.
- 연결 리스트는 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다.
- 연결 리스트는 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다.

## 스택(Stack)
스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.
- 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO: Last In First Out) 방식으로 자료를 처리한다.
- 스택의 응용 분야
```
- 함수 호출의 순서 제어
- 인터럽트의 처리
- 수식 계산 및 수식 표기법
- 컴파일러를 이용한 언어 번역
- 부 프로그램 호출 시 복귀주소 저장
- 서브루틴 호출 및 복귀 주소 저장
```
- 스택의 모든 기억 공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 오버플로(Overflow)가 발생하며, 더이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.

## 큐(Queue)
큐는 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조이다.
- 큐는 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO: First In First Out) 방식으로 처리한다.
- 큐는 시작과 끝을 표시하는 두 개의 포인터가 있다.

## 방향/무방향 그래프의 최대 간선 수
n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1)/2 이고, 방향 그래프애서 최대 간선 수는 n(n-1) 이다.
- 정점이 4개인 경우 무방향 그래프와 방향 그래프의 최대 간선 수는 다음과 같다.
```
무방향 그래프의 최대 간선 수 : 4(4-1)/2 = 6
방향 그래프의 최대 간선 수 : 4(4-1) = 12
```

## 트리의 개요
트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태이다.
- 트리 관련 용어
1. 노드(Node): 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch) 를 합친 것<br />
2. 근 노드(Root Node): 트리의 맨 위에 있는 노드
3. 디그리(Degree, 치수): 각 노드에서 뻗어 나온 가지의 수
4. 단말 노드(Terminal Node) = 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
5. 자식 노드(Son Node): 어떤 노드에 연결된 다음 레벨의 노드들
6. 부모 노드(Parent Node): 어떤 노드에 연결된 이전 레벨의 노드들
7. 형제 노드(Brother Node): 동일한 부모를 갖는 노드들
8. 트리의 디그리: 노드들의 디그리 중에서 가장 많은 수 

## 트리의 운행법
```
  A
 /\
B  C
```
- Preorder 운행: Root -> Left -> Right 순으로 운행 / A,B,C
- Inorder 운행: Left -> Root -> Right 순으로 운행 / B,A,C
- Postorder 운행: Left -> Right -> Root 순으로 운행 / B,C,A

## 수식의 표기법
```
  +
 /\
A  B
```
- 전위 표기법(Prefix): 연산자 -> Left -> Right / +AB
- 중위 표기법(inFix): Left -> Right / A+B
- 후위 표기법(PostFix): Left -> Right -> 연산자/ AB+

### Infix 표기를 Postfix나 Prefix로 바꾸기
Postfix나 Prefix는 스택을 이용하여 처리하므로 Infix는 Postfix나 Prefix로 바꾸어 처리한다.
```
X = A / B * (C+D) + E
```
- Prefix 로 변환하기
1. 연산 우선순위에 따라 괄호로 묶는다.
`(X = ((A/B) * (C+D)) + E))`

2. 연산자를 해당 괄호의 앞(왼쪽)으로 옮긴다.
`(X + (*(/(AB)) +(CD) E))`

3. 필요없는 괄호를 제거한다.
`= X + * / AB + C D E`

- Postfix나 Prefix로 표기된 수식을 Infix로 바꾸기
```
A B C - / D E F + * +
```
Postfix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 뒤로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다.

1. 먼저 인접한 피연산자 두 개와 오른쪽의 연산자를 괄호로 묶는다.
`((A(B C -) /) (D (E F +) *) +)`

2. 연산자를 해당 피연산자의 가운데로 이동시킨다.
`((A / (B - C)) + (D * (E + F)))`

3. 필요 없는 괄호를 제거한다.
`A / (B - C) + D * (E + F)`



```
+ / A - B C * D + E F
```
Prefix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 앞으로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다.

1. 먼저 인접한 피연산자 두 개와 왼쪽의 연산자를 괄호로 묶는다.
`(+ (/ A (- B C) ) (* D (+ E F) ) )`
2. 연산자를 해당 피연산자 사이로 이동시킨다.
`((A/(B-C)) + (D * (E+F)))`
3. 필요 없는 괄호를 제거한다.
`((A/(B-C)) + (D*(E+F))) A/(B-C)+D*(E+F)`

## 삽입 정렬(Insertion Sort)
ex: 8,5,6,2,4 를 삽입 정렬로 정렬하시오.
- 초기 상태: 8|5||6|2|4
- 1회전: 5|8|6|2|4
두 번째 값을 첫 번째 값과 비교하여 5를 첫 번째 자리에 삽입하고 8을 한 칸 뒤로 이동시킨다.
- 2회전: 5|6|8|2|4
세 번째 값을 첫 번째, 두 번째 값과 비교하여 6을 8 자리에 삽입하고 8을 한 칸 뒤로 이동시킨다.
- 3회전: 2 |5 | 6|8|4
네 번째 값 2를 처음부터 비교하여 맨 처음에 삽입하고 나머지를 한 칸씩 뒤로 이동시킨다.
- 4회전: 2|4|5|6|8
다섯 번째 값 4를 처음부터 비교하여 5자리에 삽입하고 나머지를 한 칸씩 뒤로 이동시킨다.

## 선택 정렬(Selection Sort)
ex: 8,5,6,2,4 를 선택 정렬로 정렬하시오.
- 초기 상태: 8|5|6|2|4
- 1회전: 5 8 6 2 4 -> 5 8 6 2 4 -> 2 8 6 5 4 -> 2 8 6 5 4
- 2회전: 2 6 8 5 4 -> 2 5 8 6 4 -> 2 4 8 6 5
- 3회전: 2 4 6 8 5 -> 2 4 5 8 6
- 4회전: 2 4 5 6 8

## 버블 정렬(Bubble Sort)
ex: 8,5,6,2,4 를 버블 정렬로 정렬하시오.
- 초기 상태: 8|5|6|2|4
- 1회전: 5 8 6 2 4 -> 5 6 8 2 4 -> 5 6 2 8 4 ->
5 6 2 4 8
- 2회전: 5 6 2 4 8 -> 5 2 6 4 8 -> 5 2 4 6 8
- 3회전: 2 5 4 6 8 -> 2 4 5 6 8
- 4회전: 2 4 5 6 8

## 퀵 정렬(Quick Sort)
퀵 정렬은 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분해시키는 방식으로 정렬한다.
- 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬한다.
- 평균 수행 시간 복잡도는 O(nlog2n)이고, 최악의 수행 복잡도는 O(n2)이다.

## 힙 정렬(Heap Sort)
힙 정렬은 전이진트리 (Compleate Binary Tree)를 이용한 정렬 방식이다.
- 구성된 전이진 트리를 Heap Tree로 변환하여 정렬한다.
- 평균과 최악 모두 시간 복잡도는 O(nlog2n) 이다.

## 2-Way 합병 정렬(Merge Sort)
2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다.
- 평균과 최악 모두 시간 복잡도는 O(nlog2n)이다.

## 이분 검색
이분 검색(이진 검색, Binary Search)은 전체 파일을 두 개의 서브파일로 분리해 가면서 Key 레코드를 검색하는 방식이다.
- 이분 검색은 반드시 순서화된 파일이어야 검색할 수 있다.
- 찾고자 하는 Key 값을 파일의 중간 레코드 Key 값과 비교하면서 검색한다.
- 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반드로 줄어듦으로 탐색 효율이 좋고 탐색 시간이 적게 소요된다.
- 중간 레코드 번호 M = (F+L)/2 (단, F: 첫 번째 레코드 번호, L: 마지막 레코드 번호)

## 해싱 함수(Hashing Function)
- 제산법(Division): 레코드 키(K)를 해시표(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나눈 나머지를 홈 주소로 삼는 방식, 즉 h(K) = K mod
Q임
- 제곱법(Mid-Square): 레코드 키 값(K)을 제곱한 후 그 중간 부분의 값을 홈 주소로 삼는 방식
- 폴딩법(Folding): 레코드 키 값(K)을 여러 부분으로 나눈 후 각 부분의 값을 더하거나 XOR(배타적 논리합)한 값을 홈 주소로 삼는 방식
- 기수 변환법(Radix): 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수는 절단하고, 이를 다시 주소 범위에 맞게 조정하는 방법
- 대수적 코딩법(Algebraic Coding): 키 값을 이루고 있는 각 자리의 비트 수를 한 다항식의 계수로 간주하고, 이 다항식을 해시표의 크기에 의해 정의된 다항식으로 나누어 얻은 나머지 다항식의 계수를 홈 주소로 삼는 방식
- 숫자 분석법(Digit Analysis, 계수 분석법): 키 값을 이루는 숫자의 분포를 분석하여 비교전 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식
- 무작위법(Random): 난수(Random Number)를 발생시켜 나온 값을 홈 주소로 삼는 방식

## DBMS(DataBase Management System: 데이터베이스 관리 시스템)
DBMS란 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어이다.
- DBMS의 필수 기능
1. 정의 기능: 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
2. 조작 기능: 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
3. 제어 기능: 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어해야 함

## DBMS의 장/단점
### 장점
- 데이터의 논리적, 물리적 독립성이 보장됨
- 데이터의 중복을 피할 수 있어 기억 공간이 절약됨
- 저장된 자료를 공통으로 이용할 수 있음
- 데이터의 일관성을 유지할 수 있음
- 데이터의 무결성을 유지할 수 있음
- 보안을 유지할 수 있음
- 데이터를 표준화할 수 있음
- 데이터를 통합하여 관리할 수 있음
- 항상 최신의 데이터를 유지함
- 데이터의 실시간 처리가 가능함

### 단점
- 데이터베이스의 전문가가 부족함
- 전산화 비용이 증가함
- 대용량 디스크로의 집중적인 Access 로 과부하(Overhead) 가 발생함
- 파일의 예비(Backup)와 회복(Recorvery)가 어려움
- 시스템이 복잡함

## 스키마
스키마(Schema)는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specification)를 기술(Description)한 메타데이터(Meta-Data)의 집합이다.
- 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나누어진다.

1. 외부 스키마: 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
2. 개념 스키마: 데이터베이스의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재함
3. 내부 스키마: 물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄

## 절차형 SQL의 테스트와 디버깅
절차형 SQL은 디버깅을 통해 기능의 적합성 여부를 검증하고, 실행을 통해 결과를 확인하는 테스트 과정을 수행한다.
- 테스트와 디버깅의 목적: 테스트(Test)를 통해 오류를 발견한 후 디버깅을 통해 오류가 발생한 소스 코드를 추적하며 수정함

## 단위 모듈(Unit Module)의 개요
단위 모듈은 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것이다.
- 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부른다.
- 단위 모듈은 사용자나 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램을 의미하기도 한다.
- 두 개의 단위 모듈이 합쳐질 경우 두 개의 기능을 구현할 수 있다.
- 단위 모듈의 구성 요소에는 처리문, 명령문, 데이터 구조 등이 있다.
- 단위 모듈은 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 한다.
- 단위 모듈을 구현하기 위해서는 단위 기능 명세서를 작성한 후 입/출력 기능과 알고리즘을 구현해야 한다.
```
단위 기능 명세서 작성 -> 입/출력 기능 구현 -> 알고리즘 구현
```

### IPC (Inter-Process Communication)
IPC는 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합으로, 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능하다.
- IPC의 대표 메소드 5가지
1. Shared Memory: 다수의 프로세스가 공유 가능한 메모리를 구성하여 프로세스 간 통신을 수행
2. Socket: 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스들 간 통신을 수행
3. Semaphores: 공유 자원에 대한 접근 제어를 통해 프로세스 간 통신을 수행
4. Pipes&named Pipes: 'Pipe' 라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신을 수행, 하나의 프로세스가 Pipe를 이용 중이라면 다른 프로세스는 접근할 수 없음
5. Message Queueing: 메시지가 발생하면 이를 전달하는 형태로 프로세스 간 통신을 수행

## 단위 모듈 테스트의 개요
단위 모듈 테스트는 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것이다.
- 단위 모듈 테스트는 단위 테스트(Unit Test) 라고도 하며, 화이트박스 테스트와 블랙박스 테스트 기법을 사용한다.
- 단위 모듈 테스트를 수행하기 위해서는 모듈을 단독적으로 실행할 수 있는 환경과 테스트에 필요한 데이터가 모두 준비되어야 한다.
- 모듈의 통합 이후에는 오랜 시간 추적해야 발견할 수 있는 에러들도 단위 모듈 테스트를 수행하면 쉽게 발견하고 수정할 수 있다.
- 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다.

## 테스트 케이스(Test Case)
테스트 케이스는 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당된다.
- 단위 모듈을 테스트하기 전에 테스트에 필요한 입력 데이터, 테스트 조건, 예상 결과 등을 모아 테스트 케이스를 만든다.
- 테스트 케이스를 이용하지 않고 수행하는 직관적인 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다.
- ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소는 다음과 같다.
1. 식별자(identifier): 항목 식별자, 일련번호
2. 테스트 항목(Test item): 테스트 대상(모듈 또는 기능)
3. 입력 명세(Input Specification): 입력 데이터 또는 테스트 조건
4. 출력 명세(Output Specification): 테스트 케이스 수행 시 예상되는 출력 결과 
5. 환경 설정(Environmental Needs): 필요한 하드웨어나 소프트웨어의 환경
6. 특수 절차 요구(Special Procedure Requirement): 테스트 케이스 수행 시 특별히 요구되는 절차
7. 의존성 기술(Inter-case Dependencies): 테스트 케이스간의 의존성

## 통합 개발 환경(IDE; Integrated Development Environment)
통합 개발 환경은 코딩, 디버그, 컴파일, 배포 등 프로그램 개발과 관련된 모든 작업을 하나의 프로그램에서 처리할 수 있도록 제공하는 소프트웨어적인 개발 환경을 말한다.
- 기존 소프트웨어 개발에서는 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger) 등의 다양한 툴을 별도로 사용했으나 현재는 하나의 인터페이스로 통합하여 제공한다.
- 통합 개발 환경 도구는 통합 개발 환경을 제공하는 소프트웨어를 의미한다.
- 통합 개발 환경을 지원하는 도구는 플랫폼, 운영체제, 언어별로 다양하게 존재한다.
- 통합 개발 환경 도구의 대표적인 기능
1. 코딩(Coding): C, Java 등의 프로그래밍 언어로 프로그램을 작성하는 기능
2. 컴파일(Compile): 개발자가 작성한 고급 언어로 된 프로그램을 컴퓨터가 이해할 수 있는 목적 프로그램으로 번역하여 컴퓨터에서 실행 가능한 형태로 변환하는 기능
3. 디버깅(Debugging): 소프트웨어나 하드웨어의 오류나 잘못된 동작, 즉 버그(Bug)를 찾아 수정하는 기능
4. 배포(Deployment): 소프트웨어를 사용자에게 전달하는 기능

## 빌드 도구
빌드는 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물을 말한다.
- 빌드 도구는 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리(Preprocessing), 컴파일(Compile) 등의 작업을 수행하는 소프트웨어를 말한다.
- 대표적인 도구로는 Ant, Maven, Gradle 등이 있다.
1. Ant: 아파치 소프트웨어 재단에서 개발한 소프트웨어로, 자바 프로젝트의 공식적인 빌드 도구로 사용되고 있음.
2. Maven: Ant와 동일한 아파치 소프트웨어 재단에서 개발된 것으로, Ant의 대안으로 개발되었음
3. Gradle: 기존의 Ant와 Maven을 보완하여 개발된 빌드 도구로, 한스 도커(Hans Docker)외 6인의 개발자가 모여 공동 개발하였음

## 소프트웨어 패키징의 개요
소프트웨어 패키징이란 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것을 말한다.
- 개발자가 아니라 사용자를 중심으로 진행한다.
- 소스 코드는 향후 관리를 고려하여 모듈화하여 패키징한다.
- 사용자가 소프트웨어를 사용하게 될 환경을 이해하여, 다양한 환경에서 소프트웨어를 손쉽게 사용할 수 있도록 일반적인 배포 형태로 패키징한다.

## 패키징 시 고려사항
- 사용장의 시스템 환경, 즉 운영체제(OS), CPU, 메모리 등에 필요한 최소 환경을 정의한다.
- UI(User Interface)는 사용자가 눈으로 직접 확인할 수 있도록 시각적인 자료와 함께 제공하고 메뉴얼과 일치시켜 패키징한다.
- 소프트웨어는 단순히 패키징하여 배포하는 것으로 끝나는것이 아니라 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공하는 것이 좋다.
- 사용자에게 배포되는 소프트웨어이므로 내부 콘텐츠에 대한 암호화 및 보안을 고려한다.
- 다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관리) 연동을 고려한다.
- 사용자의 편의성을 위한 복잡성 및 비효율성 문제를 고려항다.
- 제품 소프트웨어 종류에 적합한 알고리즘을 적용한다.

## 릴리즈 노트(Release Note)의 개요
릴리즈 노트는 개발 과정에서 정리된 릴리즈 정보를 소프트웨어의 최종 사용자인 고객과 공유하기 위한 문서이다.
- 릴리즈 노트를 통해 테스트 진행 방법에 대한 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부를 확인할 수 있다.
- 소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선사항 등을 사용자와 공유할 수 있다.
- 릴리즈 노트를 이용해 소프트웨어의 버전 관리나 릴리즈 정보를 체계적으로 관리할 수 있다.
- 릴리즈 노트는 소프트웨어의 초기 배포 시 또는 출시 후 개선 사항을 적용한 추가 배포 시에 제공한다.

## 릴리즈 노트 초기 버전 작성 시 고려사항
릴리즈 노트의 초기 버전은 다음의 사항을 고려하여 작성한다.
- 릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발팀에서 직접 현재 시제로 작성해야 한다.
- 신규 소스, 빌드 등의 이력이 정확하게 관리되어 변경 또는 개선된 항목에 대한 이력 정보들도 작성되어야 한다.
- 릴리즈 노트 작성에 대한 표준 형식은 없지만 일반적으로 다음과 같은 항목이 포함된다.
1. Header(머릿말)
2. 개요
3. 목적
4. 문제 요약
5. 재현 항목
6. 수정/개선 내용
7. 사용자 영향도
8. SW 지원 영향도
9. 노트
10. 면책 조항
11. 연락처