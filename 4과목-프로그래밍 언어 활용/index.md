## 배치 프로그램
### 배치 프로그램(Batch Program)의 개요
배치 프로그램은 사용자와의 상호작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것을 의미한다.
- 배치 프로그램이 갖추어야 하는 필수 요소는 다음과 같다.
1. 대용량 데이터: 대량의데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함
2. 자동화: 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함
3. 견고성: 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함
4. 안정성/신회성: 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함
5. 성능: 다른 응용 프로그램의 수행을 방해하지 않아야 하고, 지정된 시간 내에 처리가 완료되어야 함

## C/C++의 데이터 타입 크기 및 기억 범위
1. 문자
- 데이터 타입: `char`
- 크기: 1byte

2. 부호없는 문자형
- 데이터 타입: `unsigned char`
- 크기: 1byte

3. 정수
- `short`: 2byte
- `int`: 4byte
- `long`: 4byte
- `long long`: 8byte

4. 실수
- `float`: 4byte
- `double`: 8byte
- `long double`: 8byte

## C언어의 구조체
배열이 자료의 형과 크기가 동일한 변수의 모임이라면 구조체는 자료의 종류가 다른 변수의 모임이라고 할 수 있습니다. 예를 들어 이름, 직위, 급여 등의 필드가 필요한 사원 자료를 하나의 단위로 관리하려면 이름과 직위는 문자, 급여는 숫자와 같이 문자와 숫자가 혼용되므로 배열로는 처리할 수 없습니다. 이런 경우 구조체를 사용하면 간단하게 처리할 수 있습니다.
- 구조체를 정의한다는 것은 `int`나 `char` 같은 자료형을 하나 만드는 것을 의미합니다.
- 구조체는 'structure(구조)' 의 약어인 `struct`를 사용하여 정의합니다.
- 구조체 정의 예
```C++
struct sawon {
  char name[10];
  char position[10];
  int pay;
}
```

## JAVA의 데이터 타입 크기 및 기억 범위
1. 문자
- 데이터 타입: `char`
- 크기: 2byte

2. 정수
- `byte`: 1byte
- `short`: 2byte
- `int`: 4byte
- `long`: 8byte

3. 실수
- `float`: 4byte
- `double`: 8byte

4. 논리
- `boolean`: 1byte

## Python의 시퀀스 자료형
시퀀스 자료형(Sequence Type) 이란 리스트(List), 튜풀(Tuple), range, 문자열처럼 값이 연속적으로 이어진 자료형을 말한다.
- `리스트(List)`: 다양한 자료형의 값을 연속적으로 저장하며, 필요에 따라 개수를 늘리거나 줄일 수 있음
- `튜플(Tuple)`: 리스트처럼 요소를 연속적으로 저장하지만, 요소의 추가, 삭제, 변경은 불가능함.
- `range`: 연속된 숫자를 생성하는 것으로, 리스트, 반복문 등에서 많이 사용됨

## 변수의 개요 / 변수명 작성 규칙
### 변수의 개요
변수(Variable)는 컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간으로, 변할 수 있는 값을 의미한다.
- 변수는 저장하는 값에 따라 정수형, 실수형, 문자형, 포인터형 등으로 구분한다.

### 변수명 작성 규칙
- 영문자, 숫자, _(under bar)를 사용할 수 있다.
- 첫 글자는 영문자나 _(under bar)로 시작해야 하며, 숫자는 올 수 없다.
- 글자 수에 제한이 없다.
- 공백이나, *, +, -, / 등의 특수문자를 사용할 수 없다.
- 대/소문자를 구분한다.
- 예약어를 변수명으로 사용할 수 없다.
- 변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야 한다.
- 변수 선언 시 변수명에 데이터 타입을 명시하는 것을 헝가리언 표기법(Hungarian Notation)이라고 한다.

## 가비지 콜렉터(Garbage Collector)
- 변수를 선언만 하고 사용하지 않으면 이 변수들이 점유한 메모리 공간은 다른 프로그램들이 사용할 수 없게 된다.
- 이렇게 선언만 하고 사용하지 않는 변수들이 점유한 메모리 공간을 강제로 해제하여 다른 프로그램들이 사용할 수 있도록 하는 것을 가비지 콜렉션(Garbage Collection) 이라고 하며, 이 기능을 수행하는 모듈을 가비지 콜렉터(Garbage collecter)라고 한다.

## 산술 연산자
산술 연산자는 가, 감, 승, 제 등의 산술 계산에 사용되는 연산자를 말한다.
- 산술 연산자에는 일반 산술식과 달리 한 변수의 값을 증가하거나 감소시키는 증감 연산자가 있다.
- `+`: 덧셈
- `*`: 곱셈
- `/`: 나눗셈
- `%`: 나머지
- `++`: 증가 연산자
- `--`: 감소 연산자
- 전치: 변수 앞에 증감 연산자가 오는 형태로, 먼저 변수의 값을 증감시킨 후 변수를 연산에 사용(`++a, --a`)
- 후치: 변수 뒤에 증감 연산자가 오는 형태로 먼저 변수를 연산에 사용한 후 변수의 값을 증감시킴(`a++, a--`)

## 관계 연산자
관계 연산자는 두 수의 관계를 비교하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자이다.
- 거짓은 0, 참은 1로 사용되지만 0 외에 모든 숫자도 참으로 간주된다.
- `==`: 같다
- `!=`: 같지 않다
- `>`: 크다
- `>=`: 크거나 같다
- `<`: 작다
- `<=`: 작거나 같다

## 비트 연산자
비트 연산자는 비트별(0,1) 로 연산하여 결과를 얻는 연산자이다.
- `&`: and, 모든 비트가 1일 때만 1
- `^`: xor, 모든 비트가 같으면 0, 하나라도 다르면 1
- `|`: or, 모든 비트 중 한 비트라도 1이면 1
- `~`: not, 각 비트의 부정. 0이면 1, 1이면 0
- `<<`: 왼쪽 시프트, 비트를 왼쪽으로 이동
- `>>`: 오른쪽 시프트, 비트를 오른쪽으로 이동

## 논리 연산자
논리 연산자는 두 개의 논리 값을 연산하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자이다. 관계 연산자와 마찬가지로 거짓은 0, 참은 1이다.
- `!`: not, 부정
- `&&`: and, 모두 참이면 참
- `||`: or, 하나라도 참이면 참

## 대입 연산자
연산 후 결과를 대입하는 연산식을 간략하게 입력할 수 있도록 대입 연산자를 제공한다. 대입 연산자는 산술, 관계, 비트, 논리 연산자에 모두 적용할 수 있다.
- `+=`: `a+=1`, a = a + 1
- `--`: `a-=1`, a = a - 1
- `*=`: a = a * 1
- `/=`: a = a / 1
- `%=`: a = a % 1
- `<<=`: a = a << 1
- `>>=`: a = a >> 1 

## 조건 연산자
조건 연산자는 조건에 따라 서로 다른 수식을 수행한다.
- 형식
`조건 ? 수식1 : 수식2;`
- '조건' 의 수식이 참이면 수식1을, 거짓이면 수식2를 실행한다.

## 연산자 우선순위
- 한 개의 수식에 여러 개의 연산자가 사용되면 기본적으로 아래 표의 순서대로 처리된다.
- 아래 표의 한 줄에 가로로 나열된 연산자는 우선순위가 같기 때문에 결합규칙에 따라 ←는 오른쪽에 있는 연산자부터, →는 왼쪽에 있는 연산자부터 차례로 계산된다.

### 단항 연산자
- 결합규칙: <-
#### 단항 연산자
- `!(논리 not), ~(비트 not), ++(증가), --(감소), sizeof(기타)`

### 이항 연산자
- 결합규칙: ->
#### 산술 연산자
- `*, /, %(나머지)`
#### 시프트 연산자
- `+, -`
#### 관계 연산자
- `<, <=, >=, >`
#### 비트 연산자
- `<<, >>`
- `<, <=, >=, >`
- `==, !=`
#### 논리 연산자
- `&(비트 and), ^(비트 xor), |(비트 or)`
- `&&(논리 and), ||(논리 or)`

### 삼항 연산자
- 결합규칙: ->
#### 조건 연산자
- `? :`

### 대입 연산자
- 결합규칙: <-
#### 대입 연산자
- `=, +=, -=, *=, /=, %=, <<=, >>= 등`

### 순서 연산자
- 결합규칙: ->
#### 순서 연산자
- `.`

## scanf() 함수
`scanf()` 함수는 C언어의 표준 입력 함수로, 키보드로 입력받아 변수에 저장받는 함수이다.
```c
scanf(서식 문자열, 변수의 주소)
```

- 서식 문자열: 입력받을 데이터의 자료형을 지정함.
- 변수의 주소: 데이터를 입력받을 변수를 적는다. 변수의 주소로 입력받아야 하기 때문에 변수에 주소연산자 `&`를 붙임

```c
scanf("%3d" &a);
``` 
- `%`: 서식 문자임을 지정
- `3`: 입력 자릿수를 3자리로 지정
- `d`: 10진수로 입력
- `&a`: 입력받은 데이터를 변수 a의 주소에 저장

### 특징
- 입력받을 데이터의 자료형, 자릿수 등을 지정할 수 있다.
- 한 번에 여러 개의 데이터를 입력 받을 수 있다.
- 서식 문자열과 변수의 자료형은 일치해야 한다.
```c
scanf("%d %f", &i, &j); 
```
‘%d’와 i, “%f”와 j는 자료형이 일치해야 한다.

## 서식 문자열
- `%d`: 정수형 10진수를 입/출력 하기 위해 지정함
- `%u`: 부호없는 정수형 10진수를 입/출력 하기 위해 지정함
- `%o`: 정수형 8진수를 입/출력하기 위해 지정함
- `%x`: 정수형 16진수를 입/출력하기 위해 지정함
- `%c`: 문자를 입/출력 하기 위해 지정함
- `%s`: 문자열을 입/출력 하기 위해 지정함
- `%f`: 소수점을 포함하는 실수를 입/출력하기 위해 지정함
- `%e`: 지수형 실수를 입/출력하기 위해 지정함
- `%ld`: long 형 10진수를 입/출력하기 위해 지정함
- `%lb`: long형 8진수를 입/출력하기 위해서 지정함
- `%lx`: long혈 16진수를 입/출력 하기 위해 지정함
- `%p`: 주소를 16진수로 입/출력하기 위해 지정함

## printf()함수
printf() 함수는 C언어의 표준 출력 함수로, 인수로 주어진 값을 화면에 출력하는 함수이다.
```c
printf(서식 문자열, 변수)
```
- 서식 문자열: 변수의 자료형에 맞는 서식 문자열을 입력함
- 변수: 서식 문자열의 순서에 맞게 출력할 변수를 적음. scanf()와 달리 주ㅗ 연산자 &를 붙이지 않음.

```c
printf("%-8.2f", 200.2);
```
- `%`: 서식 문자임을 지정
- `-`: 왼쪽부터 출력
- `8`: 출력 자릿수를 8자리로 지정
- `2`: 소수점 이하를 2자리로 지정
- `f`: 실수로 출력
```
200.20VV (V는 빈칸을 의미함)
```

## 주요 제어문자
- `\n`: new line, 커서를 다음 줄 앞으로 이동함
- `\b`: backspace, 커서를 왼쪽으로 한 칸 이동함
- `\t`: tab, 커서를 일정 간격 띄움
- `\r`: carriage return, 커서를 현재 줄의 처음으로 이동함
- `\0`: 널 문자를 출력함
- `\'`: single quote, 작은따옴표를 출력함
- `\"`: double quote, 큰따옴표를 출력함
- `\a`: alert, 스피커로 벨 소리를 출력함
- `\\`: backslash, 역 슬래시를 출력함
- `\!`: form feed, 한 페이지를 넘김

## JAVA 에서의 표준 출력
- JAVA에서 값을 화면에 출력할 때는 System 클래스의 서브 클래스인 `out` 클래스의 메소드 `print(), printIn(), printf()` 등을 사용한다.
- 형식 1: 서식 문자열에 맞게 변수의 내용을 출력함
```java
System.out.printf(서식 문자열, 변수)
```
- `printf()` 메소드는 C언어의 printf 함수와 사용법이 동일하다.
```java
System.out.printf("%-8.2f", 200.2);
```
```
200.20VV (V는 빈칸을 의미함)
```
- `%`: 서식 문저임을 지정
- `-`: 왼쪽부터 출력
- `8`: 출력 자릿수를 8자리로 지정
- `2`: 소수점 이하를 2자리로 지정
- `f`: 실수로 출력

- 형식 2: 값이나 변수의 내용을 형식없이 출력함.
```java
System.out.print()
```
- 문자열을 출력할 때는 큰따옴표로 묶어줘야 한다.
- 문자열 또는 문자열 변수를 연속으로 출력할 때는 `+`를 이용한다.

```java
System.out.print("abc123", "def")
```
```
abc123def
```

- 형식 3: 값이나 변수의 내용을 형식없이 출력 후 커서를 다음 줄의 처음으로 이동함
```java
System.out.println
```
- println() 메소드는 출력 후 다음 줄로 이동한다는 것을 제외하면 print() 메소드와 사용법이 동일하다.
```java
System.out.print(“abc123” + “def”);
```
```
abc123def
```

## 단순 if문
if문은 조건에 따라서 실행할 문장을 달리하는 제어문이며, 단순 if문은 조건이 한 개 일때 사용하는 제어문이다.
- 조건이 참일 때만 실행할 문장을 지정할 수도 있고, 참과 거짓에 대해 각각 다른 실행문을 지정할 수도 있다.
- 형식1: 조건이 참일 때만 실행함.
1. 조건이 참일 때 실행할 문장이 하나인 경우
``` c++
if (조건) // if는 조건 판단문에 사용되는 예약어이므로 그대로 적는다. 조건은 참(1) 또는 거짓(0)이 결과로 나올 수 있는 수식을 ( ) 안에 입력한다
  실행할 문장;  // 조건이 참일 경우 실행할 문장을 적는다
```

2. 조건이 참일 때 실행할 문장이 두 문장 이상인 경우
```c++
if (조건){
  실행할 문장1; // { } 사이에 조건이 참일 경우 실행할 문장을 적는다
  실행할 문장2;
  ...
}
```

1. a가 10보다 크면 a에서 10을 빼기
```c++
  #include <stdio.h>
  main()
  {
    int a = 15, b;
    if (a > 10) // 1. a가 10보다 크면 ❷번 문장을 실행하고, 아니면 ❸번 문장으로 이동해서 실행을 계속한다.
      b = a - 10; // ❶번의 조건식이 참일 경우 실행할 문장이다. b는 5가 된다.
    printf("%d\n", b); // 여기서는 ❶번의 조건식이 거짓일 경우 실행할 문장이 없다. 조건 판단문을 벗어나면 무조건 ❸번으로 온다. 결과: 5
  }
```

2. 조건이 참일 때와 거짓 때 실행할 문장이 다름
```c++
  if(조건)
    실행할 문장1; // 조건이 참일 경우 실행할 문장을 적는다. 참일 경우 실행할 문장이 두 문장 이상이면 { }를 입력하고 그 사이에 문장을 적는다.
  else
    실행할 문장2; // 조건이 거짓일 경우 실행할 문장을 적는다. 두 문장 이상인 경우 {  }를 입력하고 그 사이에 문장을 적는다.
```

2. a가 b보다 크면 `a-b`, 아니면 `b-a`를 수행하기
```c++
#include <stdio.h>
main(){
  int a = 10, b = 20, cha;
  if (a > b) // 1. a가 b보다 크면 ❷번 문장을 실행하고, 아니면 ❸번의 다음 문장인 ❹번 문장을 실행한다.
    cha = a - b; // 2. ❶번의 조건식이 참일 경우 실행할 문장이다. 참이 아니기 때문에 초기화 시키지 않은 cha에는 알 수 없는 값이 그대로 있게 된다.
  else // 3. ❶번의 조건식이 거짓일 경우 실행할 문장의 시작점이다. 
    cha = b - a; // 4. ❶번의 조건식이 거짓일 경우 실행할 실제 처리문이다. cha는 10이 된다. 
  printf("%d\n", cha); // 결과: 10
} 
```

## 다중 if문
다중 if문은 조건이 여러 개일때 사용하는 제어문이다.

- 형식 1
```c++
  if(조건1)
   실행할 문장1; // 조건1이 참일 경우 실행할 문장을 적는다.
  else if(조건2)
  실행할 문장2; // 조건2가 참일 경우 실행할 문장을 적는다.
  else if(조건3)
  실행할 문장3; // 조건3이 참일 경우 실행할 문장을 적는다.
  ⋮
  else
  실행할 문장4; // 앞의 조건이 모두 거짓일 경우 실행할 문장을 적는다.
```

1. 점수에 따라 등급 표시하기
```c++
#include <stdio.h>
main( )
{
 int jum = 85;
 if (jum >= 90) //❶ jum이 90 이상이면 ❷번을 실행하고, 아니면 ❸번으로 이동한다.
 printf("학점은 A입니다.\n"); // ❷ “학점은 A입니다.”를 출력하고, ❾번으로 이동하여 프로그램을 종료한다.
 else if (jum >= 80) // ❸ jum이 80 이상이면 ❹번을 실행하고, 아니면 ❺번으로 이동한다.
 printf("학점은 B입니다.\n"); // ❹ “학점은 B입니다.”를 출력하고, ❾번으로 이동하여 프로그램을 종료한다.
 else if (jum >= 70) // ❺ jum이 70 이상이면 ❻번을실행하고, 아니면 ❼번으로 이동한다.
 printf("학점은 C입니다.\n"); // ❻ “학점은 C입니다.”를 출력하고, ❾번으로 이동하여 프로그램을 종료한다.
 else //❼ ❺번의 조건식이 거짓일경우 ❽번을 실행한다.
 printf("학점은 F입니다.\n"); // ❽ “학점은 F입니다.”를 출력하고, ❾번으로 이동하여 프로그램을 종료한다.
} //❾ 학점은 B입니다.
```

- 형식 2: if문 안에 if문이 포함된다.
```c++
if(조건1)
 { // 조건1이 참일 경우 실행할 문장의 시작점이다.
 if(조건2)
 실행할 문장1; // 조건2가 참일 경우 실행할 문장을 적는다.
 else
 실행할 문장2; // 조건2가 거짓일 경우 실행할 문장을 적는다.
 }
else
 실행할 문장3; // 조건1이 거짓일 경우 실행할 문장을 적는다
```

2. 홀수, 짝수 판별하기
```c++
#include <stdio.h>
main( )
{
 int a = 21, b = 10;
 if (a % 2 == 0) // ❶ a를 2로 나눈 나머지가 0이면 ❷번을 실행하고, 아니면 ❻번으로 이동한다.
 if (b % 2 == 0) // ❷ b를 2로 나눈 나머지가 0이면 ❸번을 실행하고, 아니면 ❹번으로 이동한다.
 printf("모두 짝수\n"); // ❸ “모두 짝수”를 출력하고, 번으로 이동하여 프로그램을 종료한다.
 else // ❹ ❷번의 조건식이 거짓일 경우 ❺번을실행한다.
 printf("a : 짝수, b : 홀수\n"); // ❺“a : 짝수, b : 홀수”를 출력하고, 번으로 이동하여 프로그램을 종료한다.
 else // ❻ ❶번의 조건식이 거짓일 경우 실행할 문장의 시작점이다.
 if (b % 2 == 0) // ❼ b를 2로 나눈 나머지가 0이면 ❽번을 실행하고, 아니면 ❾번으로 이동한다.
 printf("a : 홀수, b : 짝수\n");//  ❽ “a : 홀수, b : 짝수”를 출력하고, 번으로 이동하여 프로그램을 종료한다.
 else // ❾ ❼번의 조건식이 거짓일 경우 실행할 문장의 시작점이다.
 printf("모두 홀수\n"); //❿ “모두 홀수”를 출력하고, 번으로 이동하여 프로그램을 종료한다.
} //   a : 홀수, b : 짝수
```
## switch문
switch문은 조건에 따라 분기할 곳이 여러 곳인 경우 간단하게 처리할 수 있는 제어문이다. 

- 형식
```c++
switch(수식){ //• switch는 switch문에 사용되는 예약어로 그대로 입력한다.
// • 수식 : ‘레이블1’ ~ ‘레이블n’의 값 중 하나를 도출하는 변수나 수식을 입력한다.
  case 레이블1: 
    실행할 문장1;
    break;
  case 레이블2:
    실행할 문장2;
    break;
  default:
    실행할 문장3;
}
```
- case문의 레이블에는 한 개의 상수만 지정할 수 있으며, int, char, enum형의 상수만 가능하다.
- case문의 레이블에는 변수를 지정할 수 없다.
- break문은 생략이 가능하지만 break문이 생략되면 수식과 레이블이 일치할 때 실행할 문장부터 break문 또는 switch문이 종료될 때까지 모든 문장이 실행된다.

1. 점수(jum)에 따라 등급 표시하기
```c++
#include <stdio.h>
main( )
{
int jum = 85;
switch (jum / 10)
// jum을 10으로 나눠 결과에 해당하는 숫자를 찾아
// 간다. 85/10은 8.5지만 C 언어에서 정수 나눗셈은
// 결과도 정수이므로 결과는 8이다. 8에 해당하는 ❺
// 번으로 이동하여 ❻, ❼번을 실행한다.
{
  // ❶ ❶~❽번까지가 switch 조건문의 범위이다.
  case 10:
  // 100점일 경우 ‘jum/10’의 결과인 10이 찾아오는 곳
  // 이지만 할 일은 ‘case 9:’와 같으므로 아무것도 적
  // 지 않는다. 아무것도 적지 않으면 다음 문장인 ❷
  // 번으로 이동한다.
  case 9: ❷
  // ‘jum/10’이 9일 경우 찾아오는 곳이다. ❸, ❹번을  실행한다.
    printf(“학점은 A입니다.\n”); //  ❸  “학점은 A입니다.”를 출력한다.
    break; // ❹  break를 만나면 switch문을 탈출하여 ❾번으로 이  동한다.  
  case 8:
    printf(“학점은 B입니다.\n”);
   break; 
  case 7:
   printf(“학점은 C입니다.\n”);
   break;
  case 6:
    printf(“학점은 D입니다.\n”);
    break;
  default:
  // case 10~6에 해당되지 않는 경우, 즉 jum이 59 이하인 경우 찾아오는 곳이다.
   printf(“학점은 F입니다.\n”); //  “학점은 F입니다.”를 출력한다.
  } //❽
} //❾ 학점은 8입니다.
```

## for문
for문은 초기값, 최종값, 증가값을 지정하는 수식을 이용해 정해진 횟수를 반복하는 제어문이다.
- for문은 초기갓을 정한 다음 최종값에 대한 조건이 참이면 실행할 문장을 실행한 후 초기값을 증가값 만큼 증가시키면서 최종값에 대한 조건이 참인 동안 실행할 문장을 반복 수행한다.

- 형식
```c++
for(식1; 식2; 식3)
// • for는 반복문을 의미하는 예약어로 그대로 입력한다.
// •식1 : 초기값을 지정할 수식을 입력한다.
// •식2 : 최종값을 지정할 수식을 입력한다.
// •식3 : 증가값으로 사용할 수식을 입력한다.
  실행할 문장;
  // 식2가 참일 동안 실행할 문장을 입력한다. 실행할 문장이 두 문장 이상일 경우 { }를 입력하고 그 사이에 처리할 문장들을 입력한다.
```
- for문은 처음부터 최종값에 대한 조건식을 만족하지 못하면 한 번도 수행하지 않는다.

## while문
while문은 조건이 참인 동안 실행할 문장을 반복 수행하는 제어문이다.
- while문은 조건이 참인 동안 실행할 문장을 반복 수행하다가 조건이 거짓이면 while문을 끝낸 후 다음 코드를 수행한다.
- while문은 조건이 처음부터 거짓이면 한 번도 수행하지 않는다.
- 형식
```c++
while(조건)
// • while은 반복문에 사용되는 예약어로 그대로 입력한다.
// • (조건) : 참이나 거짓을 결과로 갖는 수식을 ‘조건’에 입력한다. 참(1)*을 직접 입력할 수도 있다.
  실행할 문장;
// 조건이 참인 동안 실행할 문장을 입력한다. 문장이 두 문장 이상인 경우 { }를 입력하고 그 사이에 처리할 문장들을 입력한다.
```

1. 다음은 1~5까지의 합을 더하는 프로그램이다. 결과를 확인하시오.
```c++
#include <stdio.h>
main( )
  {
  int a = 0, hap = 0;
  while (a < 5) 
  { 
    a++; 
    hap += a;
  } 
  printf(“%d, %d\n”, a, hap); // ❻ 결과 5, 15
}
```

## do~while문
do~while문은 조건이 참인 동안 정해진 문장을 반복 수행하다가 조건이 거짓이면 반복문을 벗어나는 while문과 같은 동작을 하는데, 다른 점은 do~while문은 실행할 문장을 무조건 한 번 실행한 다음 조건을 판단하여 탈출 여부를 결정한다는 것이다.
- do~while문은 실행할 문장을 우선 실행한 후 조건을 판별하여 조건이 참이면 실행할 문장을 계속 반복 수행하고, 거짓이면 do~while문을 끝낸 후 다음 코드를 실핸한다.

- 형식
```c++
do
// do는 do~while문에 사용되는 예약어로, do~while 의 시작 부분에 그대로 입력한다.
  실행할 문장;
// 조건이 참인 동안 실행할 문장을 입력한다. 문장이 두 문장 이상인 경우 { }를 입력하고 그 사이에 실행할 문장들을 입력한다.
while(조건); // • while은 do~while문에 사용되는 예약어로, do~while의 끝 부분에 그대로 입력한다.
// • (조건) : 참이나 거짓을 결과로 갖는 수식을 ‘조건’ 에 입력한다. 참(1)을 직접 입력할 수도 있다.
```

1. 다음은 1부터 10까지 홀수의 합을 더하는 프로그램이다. 결과를 확인하시오.
```c++
#include <stdio.h>
main(){
  int a = 0, hap = 0;
  do {
    hap += a;
    a += 2;
  }  while(a<10>); // a가 10보다 작은 동안 do 안의 문장을 반복 수행

  printf("%d, %d\n", a, hap); // 결과: 11, 25
  // a가 9가 되었을 때 9를 hap에 누적한 다음 a에 2를 더해 a가 11이 되었을 때 do-while문을 벗어나기 때문에 a는 11로 끝난다.
}
```

## break, continue
switch문이나 반복문의 실행을 제어하기 위해 사용되는 예약어이다.
- `break`: switch문이나 반복문 안에서 break가 나오면 블록을 벗어난다.
- `continue`: continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮긴다. 반복문에서만 사용된다.

1. 다음은 1~5까지의 합을 더하되 2의 배수는 배제하는 프로그램이다. 결과를 확인하시오.

```c++
#include <stdio.h>
main(){
  int a = 0, hap = 0;
  while(1){
    a++;
    if(a > 5)
      break;
    if(a%2 == 0)
      continue;
    hap += a;
  }
  
  printf("%d, %d\n", a, hap); // 결과: 6, 9
}
```

## 배열
### 배열의 개념
배열은 동일한 데이터 유형을 여러 개 사용해야 할 경우를 손쉽게 처리하기 위해 여러 개의 변수들을 조합해서 하나의 이름으로 정의해 사용하는 것을 말한다.
- 배열은 하나의 이름으로 여러 기억장소를 가리키기 떄문에 배열에서 개별적인 요소들의 위치는 첨자를 이용하여 지정한다.
- 배열은 변수명 뒤에 대괄호 `[]`를 붙이고 그 안에 사용할 개수를 지정한다.
- C언어에서 배열의 위치는 0부터 시작한다.
- 배열은 행 우선으로 데이터가 기억장소에 할당된다. 
- C 언어에서 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같다.

### 1차원 배열
- 1차원 배열은 변수들을 일직선상의 개념으로 조합한 배열이다.
- 형식
#### 자료형 변수명[개수];
- 자료형: 배열에 저장할 자료의 형을 지정함
- 변수명: 사용할 배열의 이름으로 사용자가 임의로 지정함.
- 개수: 배열의 크기를 지정하는 것으로 생략할 수 있음.
- `a[3]`: a는 배열의 이름이고, 3은 첨자로서 배열 a에서의 위치를 나타냄. a[3]에 4를 저장시키려면 `a[3] = 4` 와 같이 작성함.

1) 1차원 배열 1의 각 요소에 10, 11, 12, 13, 14를 저장한 후 출력하기
``` c++
#include <stdio.h>
main(){
  int a[5]; // 5개의 요소를 갖는 정수형 배열 a를 선언한다. 선언할 때는 사용할 개수를 선언하고, 사용할 때는 첨자를 0부터 사용하므로 주의해야 한다.
  int i; // 정수형 변수 i를 선언한다.
  
  for (i=0; i<5; i++)
    a[i]  = i + 10;

  for (i=0; i<5; i++)
    printf("%d ", a[i]); // 결과: 10 11 12 13 14
}
```

### 2차원 배열
- 2차원 배열은 변수들을 평면, 즉 행과 열로 조합한 배열이다.
#### 자료형 변수명[행개수][열개수]
- 자료형: 배열에 저장할 자료의 형을 지정함.
- 변수명: 사용할 배열의 이름으로 사용자가 임의로 지정함.
- 행개수: 배열의 행 크기를 지정함.
- 열개수: 배열의 열 크기를 지정함.
- `int b[3][3]`: 3개의 행과 열을 갖는 정수형 배열 b
```
b[0][2]: b는 배열의 이름이고, 0은 행 첨자, 2는 열 첨자로서 배열 b에서의 위치를 나타낸다.
```
2) 3행 4열의 배열에 다음과 같이 숫자 저장하기
```c++
#include <stdio.h>
main(){
  int a[3][4]; // 3행 4열의 크기를 갖는 정수형 배열 a 선언
  int i, j, k = 0; // 정수형 변수 i를 선언
  for (i<0; i<3; i++){
    for (j=0; j<4; j++){
      k++;
      a[i][j] = k;
    }
  }    
}
```

## 배열의 초기화
- 배열 선언 시 초기값을 지정할 수 있다.
- 배열을 선언할 때 배열의 크기를 생략하는 경우에는 반드시 초기값을 지정해야 조기값을 지정한 개수 만큼의 배열이 선언된다.

1. 1차원 배열 초기화
```c++
char a[3] = {'A','B','C'};
char a[] = {'A','B','C'};'
```

2. 2차원 배열 초기화
```c++
int a[2][4] = { {10, 20, 30, 40}, {50, 60, 70, 80} };
int a[2][4] = {10, 20, 30, 40, 50, 60, 70, 80};
```
- q배열의 개수보다 적은 수로 배열을 초기화하면 입력된 값만큼 지정된 숫자가 입력되고, 나머지 요소에는 0이 입력된다.
ex: `int a[5] = {3, };` 또는 `int a[5] = {3};`

## 배열 형태의 문자열 번수
C언어에서는 큰따옴표("") 로 묶인 글자는 글자 수에 관계없이 문자열로 처리된다.
- C언어에는 문자열을 저장하는 자료형이 없기 때문에 베열, 또는 포인터를 이용하여 처리한다.
```c++
char 배열이름[크기] = "문자열";
```
- 배열에 문자열을 저장하면 문자열의 끝을 알리기 위한 널 문자(`\0`)가 문자열 끝에 자동으로 삽입된다.
- 배열에 문자열을 저장할 때는 배열 선언 시 초기값으로 지정해야 하며, 이미 선언된 배열에는 문자열을 저장할 수 없다.

```c++
#include <stdio.h>
main( )
{
  char a = 'A';
  char b[9] = "SINAGONG";
  char *c = "SINAGONG"; // 포인터 변수 c에 SINAGONG 이라는 문자열이 저장된 곳의 주소를 저장한다.

  printf("%c\n", a); 
  printf("%s\n", b); // 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같으므로 배열 b의 첫 번째 요소가 가리키는 곳의 값을 문자열로 출력한다.
  printf("%s\n", c); // 포인터 변수 c가 가리키는 곳의 값을 문자열로 출력한다.
}
// 결과: 
// A
// SINAGONG
// SINAGONG
```

## 포인터와 포인터 변수
포인터는 변수의 주소를 말하며, C언어에서는 주소를 제어할 수 있는 기능을 제공한다.
- C언어에서 변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라 한다.
- 포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변수명 앞에 간접 연산자 `*`를 붙인다.(`int *a;`)
- 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 `&`를 붙인다. (`a = &b`);
- 실행문에서 포인터 변수에 간접 연산자 `*`를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말한다. (`c = *a`);
- 포인터 변수는 필요에 의해 동적으로 할당되는 메모리 영역인 힙 영역에 접근하는 동적 변수이다.<br />
예를 들어, a 변수에 100을 저장시키고, a 변수의 주소를 포인터 변수 b에 기억시켰다면 다음 그림과 같이 표헌하고 말할 수 있다.
- a는 메모리의 4번지에 대한 이름이다.
- a 변수의 주소는 4다.
- a 변수에는 100이 기억되어 있다.
- 4번지에는 100이 기억되어 있다.
- `&a`는 a 변수의 주소를 말한다. 즉 `&a`는 4다.
- 포인터 변수 b는 a 변수의 주소를 기억하고 있다.
- 포인터 변수가 가리키는 곳의 값을 말할 때는 `*`을 붙인다.
- `*b`는 b에 저장된 주소가 가리키는 곳에 저장된 값을 말하므로 100이다.

1. 다음 C언어로 구현된 프로그램의 출력 결과를 확인하시오.
```c++
main(){
  int a = 50;
  int *b; // 선언할 때의 *는 해당 변수가 포인터 변수라는 것을 의미함.
  b = &a; // 정수형 변수 a의 주소를 포인터 변수 b에 기억시킨다. b에는 a의 주소가 저장된다.
  *b = *b + 20; // b가 가리키는 곳의 값에 20을 더한다. b가 가리키는 곳이 a이므로 결국 a의 값도 바뀌는 것이다.

  printf("%d, %d", a, *b);
  // 결과: 70, 70
}
```

## 포인터와 배열
배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근할 수 있다.
- 배열 위치를 나타내는 첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같다.
- 배열 요소에 대한 주소를 지정할 때는 일반 변수와 동일하게 `&` 연산자를 사용한다.
```c++
int a[5], *b;
b = a; // 배열의 대표명을 적었으므로 a 배열의 시작 주소인 a[0]의 주소를 b에 저장한다.
b = &a[0]; // a 배열의 첫 번째 요소인 a[0]의 주소(&)를 b에 저장한다.
// 포인터 표기 방법: *(a+0), *(a+1), *(a+2)...
```
- 배열의 요소가 포인터인 포인터형 배열을 선언할 수 있다.

1. 다음의 출력 결과를 확인하시오.
```c++
main(){
  int a[5];
  int i;
  int *p;
  for (i = 0; i<5; i++){
    a[i] = i + 10;
  }

  p = a; // 포인터 변수 p에는 배열 a의 시작 위치가 기억된다. 배열의 이름은 주소이므로 `p = &a` 처럼 입력하지 않도록 주의해야 한다.
  for (i = 0; i<5; i++){
    printf("%d ", *(p+i));
    // p에 저장된 값은 정수형 배열의 시작 주소이다. p의 값을 1 증가 시킨다는 것은 현자 p가 기리키고 있는 정수형 자료의 주소에서 다음 정수형 자료의 주소로 가리키는 주소를 증가시킨다는 것이다. 정수형 자료의 크기는 4바이트이므로 다음 물리적 메모리의 주소는 4Byte 증가한 곳을 가리키는 것이다. 
  }
} // 결과: 10 11 12 13 14
```
- `p+0`: 배열의 시작 주소에 0을 더했으므로, 배열의 시작 주소인 '1000' 번지 그대로이다.
- `p+1`: '1000' 에서 한 번지 증가한 주소는 '1004' 번지이다.
- `*(p+1)`: '1004' 번지의 값은 11이다. 11을 출력한다.
- `*(p+2)`: '1008' 번지의 값은 12이다. 12를 출력한다.

## Python 의 기본 문법
- 변수의 자료형에 대한 선언이 없다.
- 문장의 끝을 의미하는 세미콜론(;)을 사용할 필요가 없다.
- 변수에 연속하여 값을 저장하는 것이 가능하다.
```py
x,y,z = 10,20,30
```
- if나 for와 같이 코드 블록을 포함하는 명령문을 작성할 때 코드 블록은 콜론(:)과 여백으로 구분한다.
- 여백은 일반적으로 4칸 또는 한개의 탭만큼 띄어야 하며, 같은 수준의 코드들은 반드시 동일한 여백을 가져야 한다.

## Python의 데이터 입출력 함수
### input() 함수
- `input()` 함수는 Python의 표준 입력 함수로, 키보드로 입력받아 변수에 저장하는 함수이다.
- 형식
```py
변수 = input(출력문자);
# 출력문자는 생략이 가능하며, 변수는 사용자가 임의로 지정할 수 있다.
# 값을 입력하고 J 를 누르면, 입력한 값이 ‘변수’에 저장된다.
```

`a=input('입력하세요.')` -> 화면에 입력하세요. 가 출력되고 그 뒤에서 커서가 깜빡거리며 입력을 기다린다. 키보드로 값을 입력하면 변수 a에 저장된다. 키보드로 값을 입력하면 변수 a에 저장된다.

### print() 함수
- 형식1
```py
print( 출력값1, 출력값2, …, sep = 분리문자, end = 종료문자)
# 출력값에는 숫자, 문자, 문자열, 변수 등 다양한 값이나 식이 올 수 있다.
# sep 은 여러 값을 출력할 때 값과 값 사이를 구분하기 위해 출력하는 문자로, 생략할 경우 기본값은 공백 한 칸( )이다.
# end는 맨 마지막에 표시할 문자로, 생략할 경우 기본값은 줄 나눔이다.
```

`print(82, 24, sep = '-', end = ',' )` → 82와 24 사이에 분리문자 ‘-’가 출력되고, 마지막에 종료문자 ‘,’가 출력된다. (결과: 82-24,)

## 입력 값의 형변환(Casting)
`input()` 함수는 입력되는 값을 무조건 문자열로 저장하므로, 숫자로 사용하기 위해서는 형을 변환해야 한다.

- 변환할 데이터가 1개일 때 
```py
변수 = int(input()) # 정수로 변환 시
변수 = float(input()) # 실수로 변환 시
```

`a = int(input())` -> `input()`으로 입력받은 값을 정수로 변환하여 변수 a에 저장한다.

- 변환할 데이터가 2개 이상일 때
```py
변수1, 변수2, ... = map*(int, input().split()) # 정수로 변환 시
변수1, 변수2, ... = map(float, input().split()) # 실수로 변환 시
```
`a, b = map(int, input().split)` -> input().split()으로 입력받은 2개의 값을 정수로 변환하여 변수 a,b에 저장한다.

## 리스트(List)
C와 Java에서는 여러 요소들을 하나의 이름으로 처리할 때 배열을 사용했는데 Python에서는 리스트를 사용한다.
- 리스트는 필요에 따라 개수를 늘이거나 줄일 수 있기 때문에 리스트를 선언할 때 크기를 적지 않는다.
- 배열과 달리 하나의 리스트에 정수, 실수, 문자열 등 다양한 자료형을 섞어서 저장할 수 있다.
- Python에서 리스트의 위치는 0부터 시작한다.
- 형식
```py
리스트명 = [값1, 값2 ...] # 리스트명은 사용자가 임의로 지정하며, 리스트를 의미하는 대괄호 사이에 저장할 값들을 쉼표(,) 로 구분하여 입력한다.
리스트명 = list([값1, 값2 ...]) # 두 방법에 대한 결과는 같습니다.
a[0] = 1 # a[0]에 1을 저장한다.
```

## 딕셔너리(Dictionary)
- 딕셔너리는 연관된 값을 묶어서 저장하는 용도로 사용한다.
- 리스트는 저장된 요소에 접근하기 위한 키로 위치에 해당하는 0,1,2 등의 사용하지만 딕셔너리는 사용자가 원하는 값을 키로 지정해 사용한다.
- 딕셔너리에 접근할 때는 딕셔너리 뒤에 대괄호([])를 사용하며, 대괄호([]) 안에 키를 지정한다.
- 형식
```py
딕셔너리명 = {키1: 값1, 키2: 값2 ...}
# 딕셔너리명은 사용자가 임의로 지정하여, 딕셔너리를 의미하는 중괄호 사이에 지정할 값들을 쉼표로 구분하여 입력한다.

딕셔너리명 = dict({키1: 값1, 키2: 값2, ...})
```

ex: `a['이름'] = '이순신` -> 딕셔너리 a의 '이름' 위치에 '이순신' 을 저장한다.

## 슬라이스(Slice)
슬라이스는 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라(Slicing) 반환하는 기능이다.
- 형식
```py
객체명[초기위치:최종위치] # 초기위치에서 최종위치 - 1 까지의 요소들을 가져온다.

객체명[초기위치:최종위치:증가값]
# 초기위치에서 최종위치 - 1 까지 '증가값' 만큼 증가하면서 해당 위치의 요소들을 가져온다.
# 증가값이 음수인 경우 초기위치에서 최종위치 + 1까지 '증가값' 만큼 감소하면서 해당 위치의 요소들을 가져온다.
```

- 슬라이스는 일부 인수를 생략하여 사용할 수 있다.
```py
객체명[:] 또는 객체명[::] # 객체의 모든 요소를 반환한다.
객체명[초기위치:] # 객체의 초기위치에서 마지막 위치까지의 요소들을 반환한다.
객체명[:최종위치] # 객체의 0번째 위치에서 최종위치-1 까지의 요소들을 반환한다.
객체명[::증가값] # 객체의 0번째 위치에서 마지막 위치까지 '증가값'만큼 증가하면서 해당 위치의 요소들을 반환한다.
```
`a = ['a', 'b', 'c', 'd', 'e']`일 때
```py
a[1:3] → ['b', 'c']
a[0:5:2] → ['a', 'c', 'e']
a[3:] → ['d', 'e']
a[:3] → ['a', 'b', 'c']
a[::3] → ['a', 'd']
```

## Python - if문
- 형식
```py 
if 조건: # 예악어 if와 참 또는 거짓이 결과로 나올 수 있는 조건을 입력한 후 끝에 콜론(:) 을 붙여준다.
    실행할 문장 # 조건이 참일 경우 실행할 문장을 적는다.
```

1) a가 10보다 크면 a에서 10을 뺴기
```py
a = 15
if a > 10:
  a = a - 10 
print(a)
```

## Python - for문
- 형식1: range를 이용하는 방식이다.
```py
for 변수 in range(최종값):
  # 0에서 '최종값' -1 까지 연속된 숫자를 순서대로 변수에 저장하며 실행할 문장을 반복 수행한다.
  실행할 문장 # 반복 수행할 문장을 적는다.
```
```py
for i in range(10) # i에 0부터 9까지 순서대로 저장하여 실행할 문장을 반복 수행한다.
  sum += i # i의 값을 sum에 누적한다. sum에는 0부터 9까지의 합 45가 저장된다.
```
```py
for i in range(11,20) # i에 if에서 19까지 순서대로 저장하여 실행할 문장을 반복 수행한다.
  sum += i # i의 값을 sum에 누적한다. sum에는 11부터 19까지의 합 135가 저장된다.
```

```py
for i in range(-10, 20 ,2): # i에 -10에서 19까지 2씩 증가하는 숫자를 순서대로 저장하며 실행할 문장을 반복 수행한다.
    sum += i # i의 값을 sum에 누적한다. sum에는 -10, -8, -6 ... 16, 18의 합 60이 저장된다.
```

- 형식2: 리스트(List)를 이용하는 방식이다.
```py
for 변수 in 리스트 # 리스트의 0번째 요소에서 마지막 요소까지 순서대로 변수에 저장하며 실행할 문장을 반복 수행한다.
  실행할 문장 # 반복 수행할 문장을 적는다.
```

다음은 리스트 a에 저장된 요소의 합과 평균을 구하는 프로그램을 Python으로 구현한 것이다.

```py
a = [35,55,65,84,45]
hap = 0
for i in a :
  hap += i
avg = hap / len(a)
print(hap, avg)
```

## Python - While문
```py
while 조건: # while은 예약어로 그대로 입력한다.
  실행할 문장 # 참이나 거짓을 결과로 갖는 수식을 조건에 입력한다.
```

다음은 1~5까지의 합을 구하는 프로그램은 Python으로 구현한 것이다.
```py
i, hap = 0, 0 # i와 hap을 0으로 초기화한다.
while i < 5 : # i가 5보다 작은 동안 반복 수행
  i += 1 # i의 값을 1씩 증가시킨다.
  hap += i # i의 값을 hap에 누적시킨다.
print(hap) # 결과 15
```

## Python - 클래스
- 정의 형식
```py
class 클래스명: # class 는 예약어로, 그대로 입력하고 클래스명은 사용자가 임의로 지정한다.
  실행할 문장
  def 메소드명(self, 인수): # def는 메소드를 정의하는 예약어로 그대로 입력하고, 메소드명은 사용자가 임의로 지정한다.
  # self는 메소드에서 자기 클래스에 속한 변수에 접근할 때 사용하는 명칭으로, 일반적으로 self를 사용하지만 사용자가 임의로 지정해도 된다.
  # 인수는 메소드를 호출하는 곳에서 보낸 값을 저장할 변수로, 사용자가 임의로 지정한다.
  실행할 문장
  return 값
  # return 은 메소드를 호출한 위치로 값을 돌려주기 위해 사용하는 예약어로, 그대로 입력한다. return 값이 없는 경우에는 생략할 수 있다. 값에는 변수, 객체, 계산식 등이 올 수 있다.
```

- 객체의 선언 형식
```py
변수명 = 클래스명()
# 변수명은 사용자가 임의로 지정하고, 사전에 정의한 클래스명과 괄호() 를 적는다.
```

다음은 두 수를 교환하는 프로그램을 Python으로 구현한 것이다.
```py
  class Cls: # Cls 클래스 정의부의 시작점
  x, y = 10, 20 # 변수(속성) x,y 선언 및 초기화

  def chg(self):
    temp = self.x
    self.x = self.y
    self.y = temp

  a = Cls()
  print(a.x, a.y)
  a.chg()
  print(a.x, a.y)
```

## 클래스 없는 메소드의 사용
C언어의 사용자 정의 함수와 같이 클래스 없이 메소드만 단독으로 사용할 수 있다.

```py
def calc(x,y):
  x *= 3
  y /= 3
  print(x, y) # 9 4.0
  return x

a, b = 3, 12
a = calc(a, b)
print(a,b) # 9 12
```

## 절차적 프로그래밍 언어의 종류
### C
- 1972년 미국 벨 연구소의 데니스 리치에 의해 개발됨
- 시스템 소프트웨어를 개발하기 편리하여 시스템 프로그래밍 언어로 널리 사용됨
- 자료의 주소를 조작할 수 있는 포인터를 제공함
- 고급 프로그래밍 언어이면서 저급 프로그램 언어의 특징을 모두 갖춤
- UNIX의 일부가 C 언어로 구현됨
- 컴파일러 방식의 언어
- 이식성이 좋아 컴퓨터 기종에 관계없이 프로그램을 작성할 수 있음
### ALGOL
- 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어
- PASCAL과 C 언어의 모체가 됨
### COBOL
- 사무 처리용 언어
- 영어 문장 형식으로 구성되어 있어 이해와 사용이 쉬움
- 4개의 DIVISON 으로 구성되어 있음

### FORTRAN
- 과학 기술 계산용 언어임
- 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 할 수 있음

## 객체지향 프로그래밍 언어의 종류
### JAVA
- 분산 네트워크 환경에 적용이 가능하며, 멀티스레드 기능을 제공하므로 여러 작업을 동시에 처리할 수 있음
- 운영체제 및 하드웨어에 독립적이며, 이식성이 강함
- 캡슐화가 가능하고 재사용성 높음

### C++
- C언어에 객체지향 개념을 적용한 언어
- 모든 문제를 객체로 모델링하여 포현함

### Smalltalk
- 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객체지향 프로그래밍 언어
- 최초로 GUI를 제공한 언어

## 스크립트 언어의 종류
### 자바스크립트(JavaScript)
- 웹 페이지의 동작을 제어하는 데 사용되는 클라이언트용 스크립트 언어로, 클래스가 존재하지 않으며 변수 선언도 필요 없음
- 서버에서 데이터를 전송할 때 아이디, 비밀번호, 수량 등의 입력 사항을 확인하기 위한 용도로 많이 사용됨

### VB 스크립트(Visual Basic Script)
- 마이크로소프트 사에서 자바 스크립트에 대응하기 위해 제작된 언어로, Active X를 사용하여 마이크로소프트 사의 애플리케이션들을 컨트롤 할 수 있음

### ASP(Active Server Page)
- 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 마이크로소프트 사에서 제작함
- Windows 계역에서만 수행 가능한 프로그래밍 언어

### JSP (Java Server Page)
- JAVA로 만들어진 서버용 스크립트로, 다양한 운영체제에서 사용이 가능함

### PHP(Professional HyperText Preprocessor)
- 서버용 스크립트 언어로, Linux, Unix, Windows 운영체제에서 사용 가능함
- C, Java 등과 문법이 유사하므로 배우기 쉬워 웹 페이지 제작에 많이 사용됨

### 파이썬(Python)
- 객체지향 기능을 지원하는 대화형 인터프리터 언어로, 플랫폼에 독립적이고 문법이 간단하여 배우기 쉬움

### 쉘 스크립트
- 유닉스/ 리눅스 계열의 쉘(Shell) 에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어
- 컴파일 단계가 없어 실행 속도가 빠름
- 쉘의 종류: Bash Shell, Bourne Shell, C Shell, Korn Shell 등
- 쉘 스크립트에서 사용되는 제어문
1. 선택형: If, case
2. 반복형: for, while, until

### Basic
- 절차지향 기능을 지원하는 대화형 인터프리터 언어로, 초보자도 쉽게 사용할 수 있는 문법 구조를 가짐

## 선언형 프로그래밍 언어 종류
### HTML
- 인터넷의 표준 문서인 하이퍼텍스트 문서를 만들기 위해 사용하는 언어로, 특별한 데이터 타입이 없는 단순한 텍스트이므로 호환성이 좋고 사용이 편리함
### LISP
- 인공지능 분야에 사용되는 언어
- 기본 자료 구조가 연결 리스트 구조이며, 재귀 호출을 많이 사용함
### PROLOG
- 논리학을 기초로 한 고급 언어로, 인공 지능 분야에서의 논리적인 추론이나 리스트 처리 등에 주로 사용함
### XML
- 기존 HTML의 단점을 보완하여 웹에서 구조화된 폭넓고 다양한 문서들을 상호 교환할 수 있도록 설계된 언어
- HTML에 사용자가 새로운 태그를 정의할 수 있으며, 문서의 내용과 이를 표현하는 방식이 독립적임
### Haskell
- 함수형 프로그래밍 언어로 부작용(Side Effect)이 없음
- 코드가 간결하고 에러 발생 가능성이 낮음

## 라이브러리
라이브러리는 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체이다.
- 자주 사용하는 함수들의 반복적인 코드 작성을 피하기 위해 미리 만들어 놓은 것으로, 필요할 때는 언제든지 호출하여 사용할 수 있다.
- 라이브러리에는 표준 라이브러리와 외부 라이브러리가 있다.
- 표준 라이브러리: 프로그래밍 언어에 기본적으로 포함되어 있는 라이브러리로, 여러 종류의 모듈이나 패키지 형태
- 외부 라이브러리: 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것으로, 외부 라이브러리를 다운받아 설치한 후 사용함

## C언어의 대표적인 표준 라이브러리
C언어는 라이브러리를 헤더 파일로 제공하는데, 각 헤더 파일에는 응용 프로그램 개발에 필요한 함수들이 정리되어 있다.
- C언어에서 헤더 파일을 사용하려면 `#include <stdio.h>` 와 같이 include 문을 이용해 선언한 후 사용해야 한다.

### stdio.h
- 데이터의 입/출력에 사용되는 기능을 제공함
- 주요 함수: printf, scanf, fprintf, fscanf, fclose, fopen 등

### math.h
- 수학 함수들을 제공함
- 주요 함수: sqrt, pow, abs 등

### string.h
- 문자열 처리에 사용되는 기능들을 제공함
- 주요 함수: strlen, strcpy, strcmp 등

### stdlib.h
- 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공함
- 주요 함수: : atoi, atof, srand, rand, malloc, free 등

### time.h
- 시간 처리에 사용되는 기능들을 제공함
- 주요 함수: time, clock 등

## 에외 처리
프로그램의 정상적인 실행을 방해하는 조건이나 상태를 예외(Exception) 라고 하며, 이러한 예외가 발생했을 때 프로그래머가 해당 문제에 대비해 작성해 놓은 처리 루틴을 수행하도록 하는 것을 예외 처리(Exception Handling) 라고 한다.
- 예외가 발생했을 때 처리 루틴은 프로그램을 종료시키거나 로그를 남기도록 하는 것이다.
- C++, Ada, Java, 자바스크립트와 같은 언어에는 예외 처리 기능이 내장되어 있으며, 그 외의 언어에서는 필요한 경우 조건문을 이용해 예외 처리 루틴을 작성한다.
- 예외의 원인에는 컴퓨터 하드웨어 문제, 운영체제의 설정 실수, 라이브러리 손상, 사용자의 입력 실수, 받아들일 수 없는 연산, 할당하지 못하는 기억장치 접근 등 다양하다.

## 운영체제의 정의 및 목적
운영체제(OS: Operation System)는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다.
- 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해 준다.
- 운영체제의 목적에는 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있다.
- 처리 능력, 반환 시간, 사용 가능도, 신뢰도는 운영체제의 성능을 평가하는 기준이 된다.
1. 처리 능력(Throughout): 일정 시간 내에 시스템이 처리하는 일의 양 
2. 반환 시간(Turn Around Time): 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
3. 사용 가능도(Availability): 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
4. 신뢰도(Reliability): 시스템이 주어진 문제를 정확하게 해결하는 정도

## 운영체제의 구성
### 제어 프로그램
제어 프로그램(Control Program)은 컴퓨터 전체의 작동상태 감시, 작업의 순서 지정, 작업에 사용되는 데이터 관리 등의 역할을 수행하는 것으로 다음과 같이 구분할 수 있다.
1. 감시 프로그램(Supervisor Program):: 제어 프로그램 중 가장 핵심적인 역할을 하는 것으로, 자원의 할당 및 시스템 전체의 작동 상태를 감시하는 프로그램
2. 작업 관리 프로그램(Job Management Program): 작업이 정상적으로 퍼리될 수 있도록 작업의 순서와 방법을 관리하는 프로그램
3. 데이터 관리 프로그램(Data Management Program): 작업에 사용되는 데이터와 파일의 표준적인 처리 및 전송을 관리하는 프로그램