## 배치 프로그램
### 배치 프로그램(Batch Program)의 개요
배치 프로그램은 사용자와의 상호작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것을 의미한다.
- 배치 프로그램이 갖추어야 하는 필수 요소는 다음과 같다.
1. 대용량 데이터: 대량의데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함
2. 자동화: 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함
3. 견고성: 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함
4. 안정성/신회성: 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함
5. 성능: 다른 응용 프로그램의 수행을 방해하지 않아야 하고, 지정된 시간 내에 처리가 완료되어야 함

## C/C++의 데이터 타입 크기 및 기억 범위
1. 문자
- 데이터 타입: `char`
- 크기: 1byte

2. 부호없는 문자형
- 데이터 타입: `unsigned char`
- 크기: 1byte

3. 정수
- `short`: 2byte
- `int`: 4byte
- `long`: 4byte
- `long long`: 8byte

4. 실수
- `float`: 4byte
- `double`: 8byte
- `long double`: 8byte

## C언어의 구조체
배열이 자료의 형과 크기가 동일한 변수의 모임이라면 구조체는 자료의 종류가 다른 변수의 모임이라고 할 수 있습니다. 예를 들어 이름, 직위, 급여 등의 필드가 필요한 사원 자료를 하나의 단위로 관리하려면 이름과 직위는 문자, 급여는 숫자와 같이 문자와 숫자가 혼용되므로 배열로는 처리할 수 없습니다. 이런 경우 구조체를 사용하면 간단하게 처리할 수 있습니다.
- 구조체를 정의한다는 것은 `int`나 `char` 같은 자료형을 하나 만드는 것을 의미합니다.
- 구조체는 'structure(구조)' 의 약어인 `struct`를 사용하여 정의합니다.
- 구조체 정의 예
```C++
struct sawon {
  char name[10];
  char position[10];
  int pay;
}
```

## JAVA의 데이터 타입 크기 및 기억 범위
1. 문자
- 데이터 타입: `char`
- 크기: 2byte

2. 정수
- `byte`: 1byte
- `short`: 2byte
- `int`: 4byte
- `long`: 8byte

3. 실수
- `float`: 4byte
- `double`: 8byte

4. 논리
- `boolean`: 1byte

## Python의 시퀀스 자료형
시퀀스 자료형(Sequence Type) 이란 리스트(List), 튜풀(Tuple), range, 문자열처럼 값이 연속적으로 이어진 자료형을 말한다.
- `리스트(List)`: 다양한 자료형의 값을 연속적으로 저장하며, 필요에 따라 개수를 늘리거나 줄일 수 있음
- `튜플(Tuple)`: 리스트처럼 요소를 연속적으로 저장하지만, 요소의 추가, 삭제, 변경은 불가능함.
- `range`: 연속된 숫자를 생성하는 것으로, 리스트, 반복문 등에서 많이 사용됨

## 변수의 개요 / 변수명 작성 규칙
### 변수의 개요
변수(Variable)는 컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간으로, 변할 수 있는 값을 의미한다.
- 변수는 저장하는 값에 따라 정수형, 실수형, 문자형, 포인터형 등으로 구분한다.

### 변수명 작성 규칙
- 영문자, 숫자, _(under bar)를 사용할 수 있다.
- 첫 글자는 영문자나 _(under bar)로 시작해야 하며, 숫자는 올 수 없다.
- 글자 수에 제한이 없다.
- 공백이나, *, +, -, / 등의 특수문자를 사용할 수 없다.
- 대/소문자를 구분한다.
- 예약어를 변수명으로 사용할 수 없다.
- 변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야 한다.
- 변수 선언 시 변수명에 데이터 타입을 명시하는 것을 헝가리언 표기법(Hungarian Notation)이라고 한다.

## 가비지 콜렉터(Garbage Collector)
- 변수를 선언만 하고 사용하지 않으면 이 변수들이 점유한 메모리 공간은 다른 프로그램들이 사용할 수 없게 된다.
- 이렇게 선언만 하고 사용하지 않는 변수들이 점유한 메모리 공간을 강제로 해제하여 다른 프로그램들이 사용할 수 있도록 하는 것을 가비지 콜렉션(Garbage Collection) 이라고 하며, 이 기능을 수행하는 모듈을 가비지 콜렉터(Garbage collecter)라고 한다.

## 산술 연산자
산술 연산자는 가, 감, 승, 제 등의 산술 계산에 사용되는 연산자를 말한다.
- 산술 연산자에는 일반 산술식과 달리 한 변수의 값을 증가하거나 감소시키는 증감 연산자가 있다.
- `+`: 덧셈
- `*`: 곱셈
- `/`: 나눗셈
- `%`: 나머지
- `++`: 증가 연산자
- `--`: 감소 연산자
- 전치: 변수 앞에 증감 연산자가 오는 형태로, 먼저 변수의 값을 증감시킨 후 변수를 연산에 사용(`++a, --a`)
- 후치: 변수 뒤에 증감 연산자가 오는 형태로 먼저 변수를 연산에 사용한 후 변수의 값을 증감시킴(`a++, a--`)

## 관계 연산자
관계 연산자는 두 수의 관계를 비교하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자이다.
- 거짓은 0, 참은 1로 사용되지만 0 외에 모든 숫자도 참으로 간주된다.
- `==`: 같다
- `!=`: 같지 않다
- `>`: 크다
- `>=`: 크거나 같다
- `<`: 작다
- `<=`: 작거나 같다

## 비트 연산자
비트 연산자는 비트별(0,1) 로 연산하여 결과를 얻는 연산자이다.
- `&`: and, 모든 비트가 1일 때만 1
- `^`: xor, 모든 비트가 같으면 0, 하나라도 다르면 1
- `|`: or, 모든 비트 중 한 비트라도 1이면 1
- `~`: not, 각 비트의 부정. 0이면 1, 1이면 0
- `<<`: 왼쪽 시프트, 비트를 왼쪽으로 이동
- `>>`: 오른쪽 시프트, 비트를 오른쪽으로 이동

## 논리 연산자
논리 연산자는 두 개의 논리 값을 연산하여 참(true) 또는 거짓(false)을 결과로 얻는 연산자이다. 관계 연산자와 마찬가지로 거짓은 0, 참은 1이다.
- `!`: not, 부정
- `&&`: and, 모두 참이면 참
- `||`: or, 하나라도 참이면 참

## 대입 연산자
연산 후 결과를 대입하는 연산식을 간략하게 입력할 수 있도록 대입 연산자를 제공한다. 대입 연산자는 산술, 관계, 비트, 논리 연산자에 모두 적용할 수 있다.
- `+=`: `a+=1`, a = a + 1
- `--`: `a-=1`, a = a - 1
- `*=`: a = a * 1
- `/=`: a = a / 1
- `%=`: a = a % 1
- `<<=`: a = a << 1
- `>>=`: a = a >> 1 

## 조건 연산자
조건 연산자는 조건에 따라 서로 다른 수식을 수행한다.
- 형식
`조건 ? 수식1 : 수식2;`
- '조건' 의 수식이 참이면 수식1을, 거짓이면 수식2를 실행한다.

## 연산자 우선순위
- 한 개의 수식에 여러 개의 연산자가 사용되면 기본적으로 아래 표의 순서대로 처리된다.
- 아래 표의 한 줄에 가로로 나열된 연산자는 우선순위가 같기 때문에 결합규칙에 따라 ←는 오른쪽에 있는 연산자부터, →는 왼쪽에 있는 연산자부터 차례로 계산된다.

### 단항 연산자
- 결합규칙: <-
#### 단항 연산자
- `!(논리 not), ~(비트 not), ++(증가), --(감소), sizeof(기타)`

### 이항 연산자
- 결합규칙: ->
#### 산술 연산자
- `*, /, %(나머지)`
#### 시프트 연산자
- `+, -`
#### 관계 연산자
- `<, <=, >=, >`
#### 비트 연산자
- `<<, >>`
- `<, <=, >=, >`
- `==, !=`
#### 논리 연산자
- `&(비트 and), ^(비트 xor), |(비트 or)`
- `&&(논리 and), ||(논리 or)`

### 삼항 연산자
- 결합규칙: ->
#### 조건 연산자
- `? :`

### 대입 연산자
- 결합규칙: <-
#### 대입 연산자
- `=, +=, -=, *=, /=, %=, <<=, >>= 등`

### 순서 연산자
- 결합규칙: ->
#### 순서 연산자
- `.`

## scanf() 함수
`scanf()` 함수는 C언어의 표준 입력 함수로, 키보드로 입력받아 변수에 저장받는 함수이다.
```c
scanf(서식 문자열, 변수의 주소)
```

- 서식 문자열: 입력받을 데이터의 자료형을 지정함.
- 변수의 주소: 데이터를 입력받을 변수를 적는다. 변수의 주소로 입력받아야 하기 때문에 변수에 주소연산자 `&`를 붙임

```c
scanf("%3d" &a);
``` 
- `%`: 서식 문자임을 지정
- `3`: 입력 자릿수를 3자리로 지정
- `d`: 10진수로 입력
- `&a`: 입력받은 데이터를 변수 a의 주소에 저장

### 특징
- 입력받을 데이터의 자료형, 자릿수 등을 지정할 수 있다.
- 한 번에 여러 개의 데이터를 입력 받을 수 있다.
- 서식 문자열과 변수의 자료형은 일치해야 한다.
```c
scanf("%d %f", &i, &j); 
```
‘%d’와 i, “%f”와 j는 자료형이 일치해야 한다.

## 서식 문자열
- `%d`: 정수형 10진수를 입/출력 하기 위해 지정함
- `%u`: 부호없는 정수형 10진수를 입/출력 하기 위해 지정함
- `%o`: 정수형 8진수를 입/출력하기 위해 지정함
- `%x`: 정수형 16진수를 입/출력하기 위해 지정함
- `%c`: 문자를 입/출력 하기 위해 지정함
- `%s`: 문자열을 입/출력 하기 위해 지정함
- `%f`: 소수점을 포함하는 실수를 입/출력하기 위해 지정함
- `%e`: 지수형 실수를 입/출력하기 위해 지정함
- `%ld`: long 형 10진수를 입/출력하기 위해 지정함
- `%lb`: long형 8진수를 입/출력하기 위해서 지정함
- `%lx`: long혈 16진수를 입/출력 하기 위해 지정함
- `%p`: 주소를 16진수로 입/출력하기 위해 지정함

## printf()함수
printf() 함수는 C언어의 표준 출력 함수로, 인수로 주어진 값을 화면에 출력하는 함수이다.
```c
printf(서식 문자열, 변수)
```
- 서식 문자열: 변수의 자료형에 맞는 서식 문자열을 입력함
- 변수: 서식 문자열의 순서에 맞게 출력할 변수를 적음. scanf()와 달리 주ㅗ 연산자 &를 붙이지 않음.

```c
printf("%-8.2f", 200.2);
```
- `%`: 서식 문자임을 지정
- `-`: 왼쪽부터 출력
- `8`: 출력 자릿수를 8자리로 지정
- `2`: 소수점 이하를 2자리로 지정
- `f`: 실수로 출력
```
200.20VV (V는 빈칸을 의미함)
```

## 주요 제어문자
- `\n`: new line, 커서를 다음 줄 앞으로 이동함
- `\b`: backspace, 커서를 왼쪽으로 한 칸 이동함
- `\t`: tab, 커서를 일정 간격 띄움
- `\r`: carriage return, 커서를 현재 줄의 처음으로 이동함
- `\0`: 널 문자를 출력함
- `\'`: single quote, 작은따옴표를 출력함
- `\"`: double quote, 큰따옴표를 출력함
- `\a`: alert, 스피커로 벨 소리를 출력함
- `\\`: backslash, 역 슬래시를 출력함
- `\!`: form feed, 한 페이지를 넘김

## JAVA 에서의 표준 출력
- JAVA에서 값을 화면에 출력할 때는 System 클래스의 서브 클래스인 `out` 클래스의 메소드 `print(), printIn(), printf()` 등을 사용한다.
- 형식 1: 서식 문자열에 맞게 변수의 내용을 출력함
```java
System.out.printf(서식 문자열, 변수)
```
- `printf()` 메소드는 C언어의 printf 함수와 사용법이 동일하다.
```java
System.out.printf("%-8.2f", 200.2);
```
```
200.20VV (V는 빈칸을 의미함)
```
- `%`: 서식 문저임을 지정
- `-`: 왼쪽부터 출력
- `8`: 출력 자릿수를 8자리로 지정
- `2`: 소수점 이하를 2자리로 지정
- `f`: 실수로 출력

- 형식 2: 값이나 변수의 내용을 형식없이 출력함.
```java
System.out.print()
```
- 문자열을 출력할 때는 큰따옴표로 묶어줘야 한다.
- 문자열 또는 문자열 변수를 연속으로 출력할 때는 `+`를 이용한다.

```java
System.out.print("abc123", "def")
```
```
abc123def
```

- 형식 3: 값이나 변수의 내용을 형식없이 출력 후 커서를 다음 줄의 처음으로 이동함
```java
System.out.println
```
- println() 메소드는 출력 후 다음 줄로 이동한다는 것을 제외하면 print() 메소드와 사용법이 동일하다.
```java
System.out.print(“abc123” + “def”);
```
```
abc123def
```

## 단순 if문
if문은 조건에 따라서 실행할 문장을 달리하는 제어문이며, 단순 if문은 조건이 한 개 일때 사용하는 제어문이다.
- 조건이 참일 때만 실행할 문장을 지정할 수도 있고, 참과 거짓에 대해 각각 다른 실행문을 지정할 수도 있다.
- 형식1: 조건이 참일 때만 실행함.
1. 조건이 참일 때 실행할 문장이 하나인 경우
``` c++
if (조건) // if는 조건 판단문에 사용되는 예약어이므로 그대로 적는다. 조건은 참(1) 또는 거짓(0)이 결과로 나올 수 있는 수식을 ( ) 안에 입력한다
  실행할 문장;  // 조건이 참일 경우 실행할 문장을 적는다
```

2. 조건이 참일 때 실행할 문장이 두 문장 이상인 경우
```c++
if (조건){
  실행할 문장1; // { } 사이에 조건이 참일 경우 실행할 문장을 적는다
  실행할 문장2;
  ...
}
```

1. a가 10보다 크면 a에서 10을 빼기
```c++
  #include <stdio.h>
  main()
  {
    int a = 15, b;
    if (a > 10) // 1. a가 10보다 크면 ❷번 문장을 실행하고, 아니면 ❸번 문장으로 이동해서 실행을 계속한다.
      b = a - 10; // ❶번의 조건식이 참일 경우 실행할 문장이다. b는 5가 된다.
    printf("%d\n", b); // 여기서는 ❶번의 조건식이 거짓일 경우 실행할 문장이 없다. 조건 판단문을 벗어나면 무조건 ❸번으로 온다. 결과: 5
  }
```

2. 조건이 참일 때와 거짓 때 실행할 문장이 다름
```c++
  if(조건)
    실행할 문장1; // 조건이 참일 경우 실행할 문장을 적는다. 참일 경우 실행할 문장이 두 문장 이상이면 { }를 입력하고 그 사이에 문장을 적는다.
  else
    실행할 문장2; // 조건이 거짓일 경우 실행할 문장을 적는다. 두 문장 이상인 경우 {  }를 입력하고 그 사이에 문장을 적는다.
```

2. a가 b보다 크면 `a-b`, 아니면 `b-a`를 수행하기
```c++
#include <stdio.h>
main(){
  int a = 10, b = 20, cha;
  if (a > b) // 1. a가 b보다 크면 ❷번 문장을 실행하고, 아니면 ❸번의 다음 문장인 ❹번 문장을 실행한다.
    cha = a - b; // 2. ❶번의 조건식이 참일 경우 실행할 문장이다. 참이 아니기 때문에 초기화 시키지 않은 cha에는 알 수 없는 값이 그대로 있게 된다.
  else // 3. ❶번의 조건식이 거짓일 경우 실행할 문장의 시작점이다. 
    cha = b - a; // 4. ❶번의 조건식이 거짓일 경우 실행할 실제 처리문이다. cha는 10이 된다. 
  printf("%d\n", cha); // 결과: 10
} 
```

## 다중 if문
다중 if문은 조건이 여러 개일때 사용하는 제어문이다.

- 형식 1
```c++
  if(조건1)
   실행할 문장1; // 조건1이 참일 경우 실행할 문장을 적는다.
  else if(조건2)
  실행할 문장2; // 조건2가 참일 경우 실행할 문장을 적는다.
  else if(조건3)
  실행할 문장3; // 조건3이 참일 경우 실행할 문장을 적는다.
  ⋮
  else
  실행할 문장4; // 앞의 조건이 모두 거짓일 경우 실행할 문장을 적는다.
```

1. 점수에 따라 등급 표시하기
```c++
#include <stdio.h>
main( )
{
 int jum = 85;
 if (jum >= 90) //❶ jum이 90 이상이면 ❷번을 실행하고, 아니면 ❸번으로 이동한다.
 printf("학점은 A입니다.\n"); // ❷ “학점은 A입니다.”를 출력하고, ❾번으로 이동하여 프로그램을 종료한다.
 else if (jum >= 80) // ❸ jum이 80 이상이면 ❹번을 실행하고, 아니면 ❺번으로 이동한다.
 printf("학점은 B입니다.\n"); // ❹ “학점은 B입니다.”를 출력하고, ❾번으로 이동하여 프로그램을 종료한다.
 else if (jum >= 70) // ❺ jum이 70 이상이면 ❻번을실행하고, 아니면 ❼번으로 이동한다.
 printf("학점은 C입니다.\n"); // ❻ “학점은 C입니다.”를 출력하고, ❾번으로 이동하여 프로그램을 종료한다.
 else //❼ ❺번의 조건식이 거짓일경우 ❽번을 실행한다.
 printf("학점은 F입니다.\n"); // ❽ “학점은 F입니다.”를 출력하고, ❾번으로 이동하여 프로그램을 종료한다.
} //❾ 학점은 B입니다.
```

- 형식 2: if문 안에 if문이 포함된다.
```c++
if(조건1)
 { // 조건1이 참일 경우 실행할 문장의 시작점이다.
 if(조건2)
 실행할 문장1; // 조건2가 참일 경우 실행할 문장을 적는다.
 else
 실행할 문장2; // 조건2가 거짓일 경우 실행할 문장을 적는다.
 }
else
 실행할 문장3; // 조건1이 거짓일 경우 실행할 문장을 적는다
```

2. 홀수, 짝수 판별하기
```c++
#include <stdio.h>
main( )
{
 int a = 21, b = 10;
 if (a % 2 == 0) // ❶ a를 2로 나눈 나머지가 0이면 ❷번을 실행하고, 아니면 ❻번으로 이동한다.
 if (b % 2 == 0) // ❷ b를 2로 나눈 나머지가 0이면 ❸번을 실행하고, 아니면 ❹번으로 이동한다.
 printf("모두 짝수\n"); // ❸ “모두 짝수”를 출력하고, 번으로 이동하여 프로그램을 종료한다.
 else // ❹ ❷번의 조건식이 거짓일 경우 ❺번을실행한다.
 printf("a : 짝수, b : 홀수\n"); // ❺“a : 짝수, b : 홀수”를 출력하고, 번으로 이동하여 프로그램을 종료한다.
 else // ❻ ❶번의 조건식이 거짓일 경우 실행할 문장의 시작점이다.
 if (b % 2 == 0) // ❼ b를 2로 나눈 나머지가 0이면 ❽번을 실행하고, 아니면 ❾번으로 이동한다.
 printf("a : 홀수, b : 짝수\n");//  ❽ “a : 홀수, b : 짝수”를 출력하고, 번으로 이동하여 프로그램을 종료한다.
 else // ❾ ❼번의 조건식이 거짓일 경우 실행할 문장의 시작점이다.
 printf("모두 홀수\n"); //❿ “모두 홀수”를 출력하고, 번으로 이동하여 프로그램을 종료한다.
} //   a : 홀수, b : 짝수
```
## switch문
switch문은 조건에 따라 분기할 곳이 여러 곳인 경우 간단하게 처리할 수 있는 제어문이다. 

- 형식
```c++
switch(수식){ //• switch는 switch문에 사용되는 예약어로 그대로 입력한다.
// • 수식 : ‘레이블1’ ~ ‘레이블n’의 값 중 하나를 도출하는 변수나 수식을 입력한다.
  case 레이블1: 
    실행할 문장1;
    break;
  case 레이블2:
    실행할 문장2;
    break;
  default:
    실행할 문장3;
}
```
- case문의 레이블에는 한 개의 상수만 지정할 수 있으며, int, char, enum형의 상수만 가능하다.
- case문의 레이블에는 변수를 지정할 수 없다.
- break문은 생략이 가능하지만 break문이 생략되면 수식과 레이블이 일치할 때 실행할 문장부터 break문 또는 switch문이 종료될 때까지 모든 문장이 실행된다.

1. 점수(jum)에 따라 등급 표시하기
```c++
#include <stdio.h>
main( )
{
int jum = 85;
switch (jum / 10)
// jum을 10으로 나눠 결과에 해당하는 숫자를 찾아
// 간다. 85/10은 8.5지만 C 언어에서 정수 나눗셈은
// 결과도 정수이므로 결과는 8이다. 8에 해당하는 ❺
// 번으로 이동하여 ❻, ❼번을 실행한다.
{
  // ❶ ❶~❽번까지가 switch 조건문의 범위이다.
  case 10:
  // 100점일 경우 ‘jum/10’의 결과인 10이 찾아오는 곳
  // 이지만 할 일은 ‘case 9:’와 같으므로 아무것도 적
  // 지 않는다. 아무것도 적지 않으면 다음 문장인 ❷
  // 번으로 이동한다.
  case 9: ❷
  // ‘jum/10’이 9일 경우 찾아오는 곳이다. ❸, ❹번을  실행한다.
    printf(“학점은 A입니다.\n”); //  ❸  “학점은 A입니다.”를 출력한다.
    break; // ❹  break를 만나면 switch문을 탈출하여 ❾번으로 이  동한다.  
  case 8:
    printf(“학점은 B입니다.\n”);
   break; 
  case 7:
   printf(“학점은 C입니다.\n”);
   break;
  case 6:
    printf(“학점은 D입니다.\n”);
    break;
  default:
  // case 10~6에 해당되지 않는 경우, 즉 jum이 59 이하인 경우 찾아오는 곳이다.
   printf(“학점은 F입니다.\n”); //  “학점은 F입니다.”를 출력한다.
  } //❽
} //❾ 학점은 8입니다.
```

## for문
for문은 초기값, 최종값, 증가값을 지정하는 수식을 이용해 정해진 횟수를 반복하는 제어문이다.
- for문은 초기갓을 정한 다음 최종값에 대한 조건이 참이면 실행할 문장을 실행한 후 초기값을 증가값 만큼 증가시키면서 최종값에 대한 조건이 참인 동안 실행할 문장을 반복 수행한다.

- 형식
```c++
for(식1; 식2; 식3)
// • for는 반복문을 의미하는 예약어로 그대로 입력한다.
// •식1 : 초기값을 지정할 수식을 입력한다.
// •식2 : 최종값을 지정할 수식을 입력한다.
// •식3 : 증가값으로 사용할 수식을 입력한다.
  실행할 문장;
  // 식2가 참일 동안 실행할 문장을 입력한다. 실행할 문장이 두 문장 이상일 경우 { }를 입력하고 그 사이에 처리할 문장들을 입력한다.
```
- for문은 처음부터 최종값에 대한 조건식을 만족하지 못하면 한 번도 수행하지 않는다.

## while문
while문은 조건이 참인 동안 실행할 문장을 반복 수행하는 제어문이다.
- while문은 조건이 참인 동안 실행할 문장을 반복 수행하다가 조건이 거짓이면 while문을 끝낸 후 다음 코드를 수행한다.
- while문은 조건이 처음부터 거짓이면 한 번도 수행하지 않는다.
- 형식
```c++
while(조건)
// • while은 반복문에 사용되는 예약어로 그대로 입력한다.
// • (조건) : 참이나 거짓을 결과로 갖는 수식을 ‘조건’에 입력한다. 참(1)*을 직접 입력할 수도 있다.
  실행할 문장;
// 조건이 참인 동안 실행할 문장을 입력한다. 문장이 두 문장 이상인 경우 { }를 입력하고 그 사이에 처리할 문장들을 입력한다.
```

1. 다음은 1~5까지의 합을 더하는 프로그램이다. 결과를 확인하시오.
```c++
#include <stdio.h>
main( )
  {
  int a = 0, hap = 0;
  while (a < 5) 
  { 
    a++; 
    hap += a;
  } 
  printf(“%d, %d\n”, a, hap); // ❻ 결과 5, 15
}
```

## do~while문
do~while문은 조건이 참인 동안 정해진 문장을 반복 수행하다가 조건이 거짓이면 반복문을 벗어나는 while문과 같은 동작을 하는데, 다른 점은 do~while문은 실행할 문장을 무조건 한 번 실행한 다음 조건을 판단하여 탈출 여부를 결정한다는 것이다.
- do~while문은 실행할 문장을 우선 실행한 후 조건을 판별하여 조건이 참이면 실행할 문장을 계속 반복 수행하고, 거짓이면 do~while문을 끝낸 후 다음 코드를 실핸한다.

- 형식
```c++
do
// do는 do~while문에 사용되는 예약어로, do~while 의 시작 부분에 그대로 입력한다.
  실행할 문장;
// 조건이 참인 동안 실행할 문장을 입력한다. 문장이 두 문장 이상인 경우 { }를 입력하고 그 사이에 실행할 문장들을 입력한다.
while(조건); // • while은 do~while문에 사용되는 예약어로, do~while의 끝 부분에 그대로 입력한다.
// • (조건) : 참이나 거짓을 결과로 갖는 수식을 ‘조건’ 에 입력한다. 참(1)을 직접 입력할 수도 있다.
```

1. 다음은 1부터 10까지 홀수의 합을 더하는 프로그램이다. 결과를 확인하시오.
```c++
#include <stdio.h>
main(){
  int a = 0, hap = 0;
  do {
    hap += a;
    a += 2;
  }  while(a<10>); // a가 10보다 작은 동안 do 안의 문장을 반복 수행

  printf("%d, %d\n", a, hap); // 결과: 11, 25
  // a가 9가 되었을 때 9를 hap에 누적한 다음 a에 2를 더해 a가 11이 되었을 때 do-while문을 벗어나기 때문에 a는 11로 끝난다.
}
```

## break, continue
switch문이나 반복문의 실행을 제어하기 위해 사용되는 예약어이다.
- `break`: switch문이나 반복문 안에서 break가 나오면 블록을 벗어난다.
- `continue`: continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 옮긴다. 반복문에서만 사용된다.

1. 다음은 1~5까지의 합을 더하되 2의 배수는 배제하는 프로그램이다. 결과를 확인하시오.

```c++
#include <stdio.h>
main(){
  int a = 0, hap = 0;
  while(1){
    a++;
    if(a > 5)
      break;
    if(a%2 == 0)
      continue;
    hap += a;
  }
  
  printf("%d, %d\n", a, hap); // 결과: 6, 9
}
```

## 배열
### 배열의 개념
배열은 동일한 데이터 유형을 여러 개 사용해야 할 경우를 손쉽게 처리하기 위해 여러 개의 변수들을 조합해서 하나의 이름으로 정의해 사용하는 것을 말한다.
- 배열은 하나의 이름으로 여러 기억장소를 가리키기 떄문에 배열에서 개별적인 요소들의 위치는 첨자를 이용하여 지정한다.
- 배열은 변수명 뒤에 대괄호 `[]`를 붙이고 그 안에 사용할 개수를 지정한다.
- C언어에서 배열의 위치는 0부터 시작한다.
- 배열은 행 우선으로 데이터가 기억장소에 할당된다. 
- C 언어에서 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같다.

### 1차원 배열
- 1차원 배열은 변수들을 일직선상의 개념으로 조합한 배열이다.
- 형식
#### 자료형 변수명[개수];
- 자료형: 배열에 저장할 자료의 형을 지정함
- 변수명: 사용할 배열의 이름으로 사용자가 임의로 지정함.
- 개수: 배열의 크기를 지정하는 것으로 생략할 수 있음.
- `a[3]`: a는 배열의 이름이고, 3은 첨자로서 배열 a에서의 위치를 나타냄. a[3]에 4를 저장시키려면 `a[3] = 4` 와 같이 작성함.

1) 1차원 배열 1의 각 요소에 10, 11, 12, 13, 14를 저장한 후 출력하기
``` c++
#include <stdio.h>
main(){
  int a[5]; // 5개의 요소를 갖는 정수형 배열 a를 선언한다. 선언할 때는 사용할 개수를 선언하고, 사용할 때는 첨자를 0부터 사용하므로 주의해야 한다.
  int i; // 정수형 변수 i를 선언한다.
  
  for (i=0; i<5; i++)
    a[i]  = i + 10;

  for (i=0; i<5; i++)
    printf("%d ", a[i]); // 결과: 10 11 12 13 14
}
```

### 2차원 배열
- 2차원 배열은 변수들을 평면, 즉 행과 열로 조합한 배열이다.
#### 자료형 변수명[행개수][열개수]
- 자료형: 배열에 저장할 자료의 형을 지정함.
- 변수명: 사용할 배열의 이름으로 사용자가 임의로 지정함.
- 행개수: 배열의 행 크기를 지정함.
- 열개수: 배열의 열 크기를 지정함.
- `int b[3][3]`: 3개의 행과 열을 갖는 정수형 배열 b
```
b[0][2]: b는 배열의 이름이고, 0은 행 첨자, 2는 열 첨자로서 배열 b에서의 위치를 나타낸다.
```
2) 3행 4열의 배열에 다음과 같이 숫자 저장하기
```c++
#include <stdio.h>
main(){
  int a[3][4]; // 3행 4열의 크기를 갖는 정수형 배열 a 선언
  int i, j, k = 0; // 정수형 변수 i를 선언
  for (i<0; i<3; i++){
    for (j=0; j<4; j++){
      k++;
      a[i][j] = k;
    }
  }    
}
```

## 배열의 초기화
- 배열 선언 시 초기값을 지정할 수 있다.
- 배열을 선언할 때 배열의 크기를 생략하는 경우에는 반드시 초기값을 지정해야 조기값을 지정한 개수 만큼의 배열이 선언된다.

1. 1차원 배열 초기화
```c++
char a[3] = {'A','B','C'};
char a[] = {'A','B','C'};'
```

2. 2차원 배열 초기화
```c++
int a[2][4] = { {10, 20, 30, 40}, {50, 60, 70, 80} };
int a[2][4] = {10, 20, 30, 40, 50, 60, 70, 80};
```
- q배열의 개수보다 적은 수로 배열을 초기화하면 입력된 값만큼 지정된 숫자가 입력되고, 나머지 요소에는 0이 입력된다.
ex: `int a[5] = {3, };` 또는 `int a[5] = {3};`

## 배열 형태의 문자열 번수
C언어에서는 큰따옴표("") 로 묶인 글자는 글자 수에 관계없이 문자열로 처리된다.
- C언어에는 문자열을 저장하는 자료형이 없기 때문에 베열, 또는 포인터를 이용하여 처리한다.
```c++
char 배열이름[크기] = "문자열";
```
- 배열에 문자열을 저장하면 문자열의 끝을 알리기 위한 널 문자(`\0`)가 문자열 끝에 자동으로 삽입된다.
- 배열에 문자열을 저장할 때는 배열 선언 시 초기값으로 지정해야 하며, 이미 선언된 배열에는 문자열을 저장할 수 없다.

```c++
#include <stdio.h>
main( )
{
  char a = 'A';
  char b[9] = "SINAGONG";
  char *c = "SINAGONG"; // 포인터 변수 c에 SINAGONG 이라는 문자열이 저장된 곳의 주소를 저장한다.

  printf("%c\n", a); 
  printf("%s\n", b); // 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같으므로 배열 b의 첫 번째 요소가 가리키는 곳의 값을 문자열로 출력한다.
  printf("%s\n", c); // 포인터 변수 c가 가리키는 곳의 값을 문자열로 출력한다.
}
// 결과: 
// A
// SINAGONG
// SINAGONG
```

## 포인터와 포인터 변수
포인터는 변수의 주소를 말하며, C언어에서는 주소를 제어할 수 있는 기능을 제공한다.
- C언어에서 변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라 한다.
- 포인터 변수를 선언할 때는 자료의 형을 먼저 쓰고 변수명 앞에 간접 연산자 `*`를 붙인다.(`int *a;`)
- 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 `&`를 붙인다. (`a = &b`);
- 실행문에서 포인터 변수에 간접 연산자 `*`를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말한다. (`c = *a`);
- 포인터 변수는 필요에 의해 동적으로 할당되는 메모리 영역인 힙 영역에 접근하는 동적 변수이다.<br />
예를 들어, a 변수에 100을 저장시키고, a 변수의 주소를 포인터 변수 b에 기억시켰다면 다음 그림과 같이 표헌하고 말할 수 있다.
- a는 메모리의 4번지에 대한 이름이다.
- a 변수의 주소는 4다.
- a 변수에는 100이 기억되어 있다.
- 4번지에는 100이 기억되어 있다.
- `&a`는 a 변수의 주소를 말한다. 즉 `&a`는 4다.
- 포인터 변수 b는 a 변수의 주소를 기억하고 있다.
- 포인터 변수가 가리키는 곳의 값을 말할 때는 `*`을 붙인다.
- `*b`는 b에 저장된 주소가 가리키는 곳에 저장된 값을 말하므로 100이다.

1. 다음 C언어로 구현된 프로그램의 출력 결과를 확인하시오.
```c++
main(){
  int a = 50;
  int *b; // 선언할 때의 *는 해당 변수가 포인터 변수라는 것을 의미함.
  b = &a; // 정수형 변수 a의 주소를 포인터 변수 b에 기억시킨다. b에는 a의 주소가 저장된다.
  *b = *b + 20; // b가 가리키는 곳의 값에 20을 더한다. b가 가리키는 곳이 a이므로 결국 a의 값도 바뀌는 것이다.

  printf("%d, %d", a, *b);
  // 결과: 70, 70
}
```

## 포인터와 배열
배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근할 수 있다.
- 배열 위치를 나타내는 첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같다.
- 배열 요소에 대한 주소를 지정할 때는 일반 변수와 동일하게 `&` 연산자를 사용한다.
```c++
int a[5], *b;
b = a; // 배열의 대표명을 적었으므로 a 배열의 시작 주소인 a[0]의 주소를 b에 저장한다.
b = &a[0]; // a 배열의 첫 번째 요소인 a[0]의 주소(&)를 b에 저장한다.
// 포인터 표기 방법: *(a+0), *(a+1), *(a+2)...
```
- 배열의 요소가 포인터인 포인터형 배열을 선언할 수 있다.

1. 다음의 출력 결과를 확인하시오.
```c++
main(){
  int a[5];
  int i;
  int *p;
  for (i = 0; i<5; i++){
    a[i] = i + 10;
  }

  p = a; // 포인터 변수 p에는 배열 a의 시작 위치가 기억된다. 배열의 이름은 주소이므로 `p = &a` 처럼 입력하지 않도록 주의해야 한다.
  for (i = 0; i<5; i++){
    printf("%d ", *(p+i));
    // p에 저장된 값은 정수형 배열의 시작 주소이다. p의 값을 1 증가 시킨다는 것은 현자 p가 기리키고 있는 정수형 자료의 주소에서 다음 정수형 자료의 주소로 가리키는 주소를 증가시킨다는 것이다. 정수형 자료의 크기는 4바이트이므로 다음 물리적 메모리의 주소는 4Byte 증가한 곳을 가리키는 것이다. 
  }
} // 결과: 10 11 12 13 14
```
- `p+0`: 배열의 시작 주소에 0을 더했으므로, 배열의 시작 주소인 '1000' 번지 그대로이다.
- `p+1`: '1000' 에서 한 번지 증가한 주소는 '1004' 번지이다.
- `*(p+1)`: '1004' 번지의 값은 11이다. 11을 출력한다.
- `*(p+2)`: '1008' 번지의 값은 12이다. 12를 출력한다.

## Python 의 기본 문법
- 변수의 자료형에 대한 선언이 없다.
- 문장의 끝을 의미하는 세미콜론(;)을 사용할 필요가 없다.
- 변수에 연속하여 값을 저장하는 것이 가능하다.
```py
x,y,z = 10,20,30
```
- if나 for와 같이 코드 블록을 포함하는 명령문을 작성할 때 코드 블록은 콜론(:)과 여백으로 구분한다.
- 여백은 일반적으로 4칸 또는 한개의 탭만큼 띄어야 하며, 같은 수준의 코드들은 반드시 동일한 여백을 가져야 한다.

## Python의 데이터 입출력 함수
### input() 함수
- `input()` 함수는 Python의 표준 입력 함수로, 키보드로 입력받아 변수에 저장하는 함수이다.
- 형식
```py
변수 = input(출력문자);
# 출력문자는 생략이 가능하며, 변수는 사용자가 임의로 지정할 수 있다.
# 값을 입력하고 J 를 누르면, 입력한 값이 ‘변수’에 저장된다.
```

`a=input('입력하세요.')` -> 화면에 입력하세요. 가 출력되고 그 뒤에서 커서가 깜빡거리며 입력을 기다린다. 키보드로 값을 입력하면 변수 a에 저장된다. 키보드로 값을 입력하면 변수 a에 저장된다.

### print() 함수
- 형식1
```py
print( 출력값1, 출력값2, …, sep = 분리문자, end = 종료문자)
# 출력값에는 숫자, 문자, 문자열, 변수 등 다양한 값이나 식이 올 수 있다.
# sep 은 여러 값을 출력할 때 값과 값 사이를 구분하기 위해 출력하는 문자로, 생략할 경우 기본값은 공백 한 칸( )이다.
# end는 맨 마지막에 표시할 문자로, 생략할 경우 기본값은 줄 나눔이다.
```

`print(82, 24, sep = '-', end = ',' )` → 82와 24 사이에 분리문자 ‘-’가 출력되고, 마지막에 종료문자 ‘,’가 출력된다. (결과: 82-24,)

## 입력 값의 형변환(Casting)
`input()` 함수는 입력되는 값을 무조건 문자열로 저장하므로, 숫자로 사용하기 위해서는 형을 변환해야 한다.

- 변환할 데이터가 1개일 때 
```py
변수 = int(input()) # 정수로 변환 시
변수 = float(input()) # 실수로 변환 시
```

`a = int(input())` -> `input()`으로 입력받은 값을 정수로 변환하여 변수 a에 저장한다.

- 변환할 데이터가 2개 이상일 때
```py
변수1, 변수2, ... = map*(int, input().split()) # 정수로 변환 시
변수1, 변수2, ... = map(float, input().split()) # 실수로 변환 시
```
`a, b = map(int, input().split)` -> input().split()으로 입력받은 2개의 값을 정수로 변환하여 변수 a,b에 저장한다.

## 리스트(List)
C와 Java에서는 여러 요소들을 하나의 이름으로 처리할 때 배열을 사용했는데 Python에서는 리스트를 사용한다.
- 리스트는 필요에 따라 개수를 늘이거나 줄일 수 있기 때문에 리스트를 선언할 때 크기를 적지 않는다.
- 배열과 달리 하나의 리스트에 정수, 실수, 문자열 등 다양한 자료형을 섞어서 저장할 수 있다.
- Python에서 리스트의 위치는 0부터 시작한다.
- 형식
```py
리스트명 = [값1, 값2 ...] # 리스트명은 사용자가 임의로 지정하며, 리스트를 의미하는 대괄호 사이에 저장할 값들을 쉼표(,) 로 구분하여 입력한다.
리스트명 = list([값1, 값2 ...]) # 두 방법에 대한 결과는 같습니다.
a[0] = 1 # a[0]에 1을 저장한다.
```

## 딕셔너리(Dictionary)
- 딕셔너리는 연관된 값을 묶어서 저장하는 용도로 사용한다.
- 리스트는 저장된 요소에 접근하기 위한 키로 위치에 해당하는 0,1,2 등의 사용하지만 딕셔너리는 사용자가 원하는 값을 키로 지정해 사용한다.
- 딕셔너리에 접근할 때는 딕셔너리 뒤에 대괄호([])를 사용하며, 대괄호([]) 안에 키를 지정한다.
- 형식
```py
딕셔너리명 = {키1: 값1, 키2: 값2 ...}
# 딕셔너리명은 사용자가 임의로 지정하여, 딕셔너리를 의미하는 중괄호 사이에 지정할 값들을 쉼표로 구분하여 입력한다.

딕셔너리명 = dict({키1: 값1, 키2: 값2, ...})
```

ex: `a['이름'] = '이순신` -> 딕셔너리 a의 '이름' 위치에 '이순신' 을 저장한다.

## 슬라이스(Slice)
슬라이스는 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라(Slicing) 반환하는 기능이다.
- 형식
```py
객체명[초기위치:최종위치] # 초기위치에서 최종위치 - 1 까지의 요소들을 가져온다.

객체명[초기위치:최종위치:증가값]
# 초기위치에서 최종위치 - 1 까지 '증가값' 만큼 증가하면서 해당 위치의 요소들을 가져온다.
# 증가값이 음수인 경우 초기위치에서 최종위치 + 1까지 '증가값' 만큼 감소하면서 해당 위치의 요소들을 가져온다.
```

- 슬라이스는 일부 인수를 생략하여 사용할 수 있다.
```py
객체명[:] 또는 객체명[::] # 객체의 모든 요소를 반환한다.
객체명[초기위치:] # 객체의 초기위치에서 마지막 위치까지의 요소들을 반환한다.
객체명[:최종위치] # 객체의 0번째 위치에서 최종위치-1 까지의 요소들을 반환한다.
객체명[::증가값] # 객체의 0번째 위치에서 마지막 위치까지 '증가값'만큼 증가하면서 해당 위치의 요소들을 반환한다.
```
`a = ['a', 'b', 'c', 'd', 'e']`일 때
```py
a[1:3] → ['b', 'c']
a[0:5:2] → ['a', 'c', 'e']
a[3:] → ['d', 'e']
a[:3] → ['a', 'b', 'c']
a[::3] → ['a', 'd']
```

## Python - if문
- 형식
```py 
if 조건: # 예악어 if와 참 또는 거짓이 결과로 나올 수 있는 조건을 입력한 후 끝에 콜론(:) 을 붙여준다.
    실행할 문장 # 조건이 참일 경우 실행할 문장을 적는다.
```

1) a가 10보다 크면 a에서 10을 뺴기
```py
a = 15
if a > 10:
  a = a - 10 
print(a)
```

## Python - for문
- 형식1: range를 이용하는 방식이다.
```py
for 변수 in range(최종값):
  # 0에서 '최종값' -1 까지 연속된 숫자를 순서대로 변수에 저장하며 실행할 문장을 반복 수행한다.
  실행할 문장 # 반복 수행할 문장을 적는다.
```
```py
for i in range(10) # i에 0부터 9까지 순서대로 저장하여 실행할 문장을 반복 수행한다.
  sum += i # i의 값을 sum에 누적한다. sum에는 0부터 9까지의 합 45가 저장된다.
```
```py
for i in range(11,20) # i에 if에서 19까지 순서대로 저장하여 실행할 문장을 반복 수행한다.
  sum += i # i의 값을 sum에 누적한다. sum에는 11부터 19까지의 합 135가 저장된다.
```

```py
for i in range(-10, 20 ,2): # i에 -10에서 19까지 2씩 증가하는 숫자를 순서대로 저장하며 실행할 문장을 반복 수행한다.
    sum += i # i의 값을 sum에 누적한다. sum에는 -10, -8, -6 ... 16, 18의 합 60이 저장된다.
```

- 형식2: 리스트(List)를 이용하는 방식이다.
```py
for 변수 in 리스트 # 리스트의 0번째 요소에서 마지막 요소까지 순서대로 변수에 저장하며 실행할 문장을 반복 수행한다.
  실행할 문장 # 반복 수행할 문장을 적는다.
```

다음은 리스트 a에 저장된 요소의 합과 평균을 구하는 프로그램을 Python으로 구현한 것이다.

```py
a = [35,55,65,84,45]
hap = 0
for i in a :
  hap += i
avg = hap / len(a)
print(hap, avg)
```

## Python - While문
```py
while 조건: # while은 예약어로 그대로 입력한다.
  실행할 문장 # 참이나 거짓을 결과로 갖는 수식을 조건에 입력한다.
```

다음은 1~5까지의 합을 구하는 프로그램은 Python으로 구현한 것이다.
```py
i, hap = 0, 0 # i와 hap을 0으로 초기화한다.
while i < 5 : # i가 5보다 작은 동안 반복 수행
  i += 1 # i의 값을 1씩 증가시킨다.
  hap += i # i의 값을 hap에 누적시킨다.
print(hap) # 결과 15
```

## Python - 클래스
- 정의 형식
```py
class 클래스명: # class 는 예약어로, 그대로 입력하고 클래스명은 사용자가 임의로 지정한다.
  실행할 문장
  def 메소드명(self, 인수): # def는 메소드를 정의하는 예약어로 그대로 입력하고, 메소드명은 사용자가 임의로 지정한다.
  # self는 메소드에서 자기 클래스에 속한 변수에 접근할 때 사용하는 명칭으로, 일반적으로 self를 사용하지만 사용자가 임의로 지정해도 된다.
  # 인수는 메소드를 호출하는 곳에서 보낸 값을 저장할 변수로, 사용자가 임의로 지정한다.
  실행할 문장
  return 값
  # return 은 메소드를 호출한 위치로 값을 돌려주기 위해 사용하는 예약어로, 그대로 입력한다. return 값이 없는 경우에는 생략할 수 있다. 값에는 변수, 객체, 계산식 등이 올 수 있다.
```

- 객체의 선언 형식
```py
변수명 = 클래스명()
# 변수명은 사용자가 임의로 지정하고, 사전에 정의한 클래스명과 괄호() 를 적는다.
```

다음은 두 수를 교환하는 프로그램을 Python으로 구현한 것이다.
```py
  class Cls: # Cls 클래스 정의부의 시작점
  x, y = 10, 20 # 변수(속성) x,y 선언 및 초기화

  def chg(self):
    temp = self.x
    self.x = self.y
    self.y = temp

  a = Cls()
  print(a.x, a.y)
  a.chg()
  print(a.x, a.y)
```

## 클래스 없는 메소드의 사용
C언어의 사용자 정의 함수와 같이 클래스 없이 메소드만 단독으로 사용할 수 있다.

```py
def calc(x,y):
  x *= 3
  y /= 3
  print(x, y) # 9 4.0
  return x

a, b = 3, 12
a = calc(a, b)
print(a,b) # 9 12
```

## 절차적 프로그래밍 언어의 종류
### C
- 1972년 미국 벨 연구소의 데니스 리치에 의해 개발됨
- 시스템 소프트웨어를 개발하기 편리하여 시스템 프로그래밍 언어로 널리 사용됨
- 자료의 주소를 조작할 수 있는 포인터를 제공함
- 고급 프로그래밍 언어이면서 저급 프로그램 언어의 특징을 모두 갖춤
- UNIX의 일부가 C 언어로 구현됨
- 컴파일러 방식의 언어
- 이식성이 좋아 컴퓨터 기종에 관계없이 프로그램을 작성할 수 있음
### ALGOL
- 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어
- PASCAL과 C 언어의 모체가 됨
### COBOL
- 사무 처리용 언어
- 영어 문장 형식으로 구성되어 있어 이해와 사용이 쉬움
- 4개의 DIVISON 으로 구성되어 있음

### FORTRAN
- 과학 기술 계산용 언어임
- 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 할 수 있음

## 객체지향 프로그래밍 언어의 종류
### JAVA
- 분산 네트워크 환경에 적용이 가능하며, 멀티스레드 기능을 제공하므로 여러 작업을 동시에 처리할 수 있음
- 운영체제 및 하드웨어에 독립적이며, 이식성이 강함
- 캡슐화가 가능하고 재사용성 높음

### C++
- C언어에 객체지향 개념을 적용한 언어
- 모든 문제를 객체로 모델링하여 포현함

### Smalltalk
- 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객체지향 프로그래밍 언어
- 최초로 GUI를 제공한 언어

## 스크립트 언어의 종류
### 자바스크립트(JavaScript)
- 웹 페이지의 동작을 제어하는 데 사용되는 클라이언트용 스크립트 언어로, 클래스가 존재하지 않으며 변수 선언도 필요 없음
- 서버에서 데이터를 전송할 때 아이디, 비밀번호, 수량 등의 입력 사항을 확인하기 위한 용도로 많이 사용됨

### VB 스크립트(Visual Basic Script)
- 마이크로소프트 사에서 자바 스크립트에 대응하기 위해 제작된 언어로, Active X를 사용하여 마이크로소프트 사의 애플리케이션들을 컨트롤 할 수 있음

### ASP(Active Server Page)
- 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어로 마이크로소프트 사에서 제작함
- Windows 계역에서만 수행 가능한 프로그래밍 언어

### JSP (Java Server Page)
- JAVA로 만들어진 서버용 스크립트로, 다양한 운영체제에서 사용이 가능함

### PHP(Professional HyperText Preprocessor)
- 서버용 스크립트 언어로, Linux, Unix, Windows 운영체제에서 사용 가능함
- C, Java 등과 문법이 유사하므로 배우기 쉬워 웹 페이지 제작에 많이 사용됨

### 파이썬(Python)
- 객체지향 기능을 지원하는 대화형 인터프리터 언어로, 플랫폼에 독립적이고 문법이 간단하여 배우기 쉬움

### 쉘 스크립트
- 유닉스/ 리눅스 계열의 쉘(Shell) 에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어
- 컴파일 단계가 없어 실행 속도가 빠름
- 쉘의 종류: Bash Shell, Bourne Shell, C Shell, Korn Shell 등
- 쉘 스크립트에서 사용되는 제어문
1. 선택형: If, case
2. 반복형: for, while, until

### Basic
- 절차지향 기능을 지원하는 대화형 인터프리터 언어로, 초보자도 쉽게 사용할 수 있는 문법 구조를 가짐

## 선언형 프로그래밍 언어 종류
### HTML
- 인터넷의 표준 문서인 하이퍼텍스트 문서를 만들기 위해 사용하는 언어로, 특별한 데이터 타입이 없는 단순한 텍스트이므로 호환성이 좋고 사용이 편리함
### LISP
- 인공지능 분야에 사용되는 언어
- 기본 자료 구조가 연결 리스트 구조이며, 재귀 호출을 많이 사용함
### PROLOG
- 논리학을 기초로 한 고급 언어로, 인공 지능 분야에서의 논리적인 추론이나 리스트 처리 등에 주로 사용함
### XML
- 기존 HTML의 단점을 보완하여 웹에서 구조화된 폭넓고 다양한 문서들을 상호 교환할 수 있도록 설계된 언어
- HTML에 사용자가 새로운 태그를 정의할 수 있으며, 문서의 내용과 이를 표현하는 방식이 독립적임
### Haskell
- 함수형 프로그래밍 언어로 부작용(Side Effect)이 없음
- 코드가 간결하고 에러 발생 가능성이 낮음

## 라이브러리
라이브러리는 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체이다.
- 자주 사용하는 함수들의 반복적인 코드 작성을 피하기 위해 미리 만들어 놓은 것으로, 필요할 때는 언제든지 호출하여 사용할 수 있다.
- 라이브러리에는 표준 라이브러리와 외부 라이브러리가 있다.
- 표준 라이브러리: 프로그래밍 언어에 기본적으로 포함되어 있는 라이브러리로, 여러 종류의 모듈이나 패키지 형태
- 외부 라이브러리: 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 것으로, 외부 라이브러리를 다운받아 설치한 후 사용함

## C언어의 대표적인 표준 라이브러리
C언어는 라이브러리를 헤더 파일로 제공하는데, 각 헤더 파일에는 응용 프로그램 개발에 필요한 함수들이 정리되어 있다.
- C언어에서 헤더 파일을 사용하려면 `#include <stdio.h>` 와 같이 include 문을 이용해 선언한 후 사용해야 한다.

### stdio.h
- 데이터의 입/출력에 사용되는 기능을 제공함
- 주요 함수: printf, scanf, fprintf, fscanf, fclose, fopen 등

### math.h
- 수학 함수들을 제공함
- 주요 함수: sqrt, pow, abs 등

### string.h
- 문자열 처리에 사용되는 기능들을 제공함
- 주요 함수: strlen, strcpy, strcmp 등

### stdlib.h
- 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공함
- 주요 함수: : atoi, atof, srand, rand, malloc, free 등

### time.h
- 시간 처리에 사용되는 기능들을 제공함
- 주요 함수: time, clock 등

## 에외 처리
프로그램의 정상적인 실행을 방해하는 조건이나 상태를 예외(Exception) 라고 하며, 이러한 예외가 발생했을 때 프로그래머가 해당 문제에 대비해 작성해 놓은 처리 루틴을 수행하도록 하는 것을 예외 처리(Exception Handling) 라고 한다.
- 예외가 발생했을 때 처리 루틴은 프로그램을 종료시키거나 로그를 남기도록 하는 것이다.
- C++, Ada, Java, 자바스크립트와 같은 언어에는 예외 처리 기능이 내장되어 있으며, 그 외의 언어에서는 필요한 경우 조건문을 이용해 예외 처리 루틴을 작성한다.
- 예외의 원인에는 컴퓨터 하드웨어 문제, 운영체제의 설정 실수, 라이브러리 손상, 사용자의 입력 실수, 받아들일 수 없는 연산, 할당하지 못하는 기억장치 접근 등 다양하다.

## 운영체제의 정의 및 목적
운영체제(OS: Operation System)는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다.
- 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해 준다.
- 운영체제의 목적에는 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있다.
- 처리 능력, 반환 시간, 사용 가능도, 신뢰도는 운영체제의 성능을 평가하는 기준이 된다.
1. 처리 능력(Throughout): 일정 시간 내에 시스템이 처리하는 일의 양 
2. 반환 시간(Turn Around Time): 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
3. 사용 가능도(Availability): 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
4. 신뢰도(Reliability): 시스템이 주어진 문제를 정확하게 해결하는 정도

## 운영체제의 구성
### 제어 프로그램
제어 프로그램(Control Program)은 컴퓨터 전체의 작동상태 감시, 작업의 순서 지정, 작업에 사용되는 데이터 관리 등의 역할을 수행하는 것으로 다음과 같이 구분할 수 있다.
1. 감시 프로그램(Supervisor Program):: 제어 프로그램 중 가장 핵심적인 역할을 하는 것으로, 자원의 할당 및 시스템 전체의 작동 상태를 감시하는 프로그램
2. 작업 관리 프로그램(Job Management Program): 작업이 정상적으로 퍼리될 수 있도록 작업의 순서와 방법을 관리하는 프로그램
3. 데이터 관리 프로그램(Data Management Program): 작업에 사용되는 데이터와 파일의 표준적인 처리 및 전송을 관리하는 프로그램

### 처리 프로그램
처리 프로그램은 제어 프로그램의 지시를 받아 사용자가 요구한 문제를 해결하기 위한 프로그램으로, 다음과 같이 구분할 수 있다.
1. 언어 번역 프로그램: 사용자가 고급언어로 작성한 원시 프로그램을 기계어 형태의 목적 프로그램으로 변환시키는 것으로, 컴파일러, 어셈블러, 인터프리터 등이 있음.
2. 서비스 프로그램
- 사용자가 컴퓨터를 더욱 효율적으로 사용할 수 있도록 제작된 프로그램
- 분류/병합(Sort,Merge), 유틸리티 프로그램 등이 여기에 해당됨

## 운영체제의 기능
- 프로세서(처리기, Processor), 기억장치(주기억장치, 보조기억장치), 입/출력장치, 파일 및 정보 등의 자원을 관리한다.
- 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공한다.
- 사용자와 시스템 간의 편리한 인터페이스를 제공한다.
- 시스템의 각종 하드웨어와 네트워크를 관리/제어한다.
- 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공한다.
- 시스템의 오류를 검사하고 복구한다.
- 자원 보호 기능을 제공한다.
- 입/출력에 대한 보조 기능을 제공한다.
- 가상 계산기 기능을 제공한다.

## Windows
- Windows는 1990년데 마이크로소프트(Microsoft) 사가 개발한 운영체제이다.
- Windows의 주요 특징
1. 그래픽 사용자 인터페이스(GUI: Graphic User Interface): 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식

### 선점형 멀티태스킹(Preemptive Multi-Tasking)
동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료하고 모든 시스템 자원을 반환하는 형식

### Pnp(Plug and play, 자동 감지 기능)
컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영체제가 자동으로 구성해 주는 기능

### OLE(Object Linking and Embedding)
다른 여러 응용 프로그램에서 작성한 문자나 그림 등의 개체(Object)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embedding) 하여 편집할 수 있게 하는 기능

### 255자의 긴 파일명 
- Windows에서는 파일 이름을 지정할 때 VFAT(Vitual Fle Allocation Table)을 이용하여 최대 255자까지 지정할 수 있음
- 파일 이름으로는 `\ / : * ? “ < >` 을 제외한 모든 문자 및 공백을 사용할 수 있으며, 한글의 경우 127자까지 지정할 수 있음

### Single-User 시스템
- 컴퓨터 한 대를 한 사람만이 독점해서 사용함

## UNIX의 개요 및 특징
UNIX는 1960년데 AT&T 벨(Bell) 연구소, MIT, General Electric이 공동 개발한 운영체제이다.
- 시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제로, 소스가 공개된 개방형 시스템(Open System) 이다.
- 대부분 C 언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높다.
- 크기가 작고 이해하기가 쉽다.
- 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원한다.
- 많은 네트워킹 기능을 제공하므로 통신망(Network) 관리용 운영체제로 적합하다.
- 트리 구조의 파일 시스템을 갖는다.
- 전문적인 프로그램 개발에 용이하다.
- 다양한 유틸리티 프로그램들이 존재한다.

※ 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)
- 다중 사용자(Multi-User)는 여러 사용자가 동시에 시스템을 사용하는 것이고, 다중 작업은 여러 개의 작업이나 프로그램을 동시에 수행하는 것을 의미한다.
- 하나 이상의 작업을 백그라운드에서 수행하므로 여러 작업을 동시에 처리할 수 있다.

## UNIX 시스템의 구성
### 커널(Kernel)
- UNIX의 가장 핵심적인 부분이다.
- 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행된다.
- 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당한다. 
- 프로세스(CPU 스케줄링)관리, 기억장치 관리, 파일 관리, 입/출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러 가지 기능을 수행한다.

### 쉘(Shell)
- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기이다.
- 시스템과 사용자 간의 인터페이스를 담당한다.
- DOS의 COMMAND.COM 과 같은 기능을 수행한다.
- 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능하다.
- 파이프라인 기능을 지원하고 입/출력 재지정을 통해 출력과 입력의 방향을 변경할 수 있다.
- 공용 Shell(Bourne Shell, C Shell, Korn Shell)이나 사용자 자신이 만든 Shell을 사용할 수 있다.

### Utility Program
- 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용한다.
- DOS에서의 외부 명령어에 해당된다.
- 유틸리티 프로그램에는 에디터, 컴파일러, 인터프리터, 디버거 등이 있다.

## 파일 디스크립터(File Descriptor)
파일을 관리하기 위한 시스템(운영체제)이 필요로 하는 파일에 대한 정보를 가진 제어 블록을 의미하며, 파일 제어 블록(FCB: File Control Block) 이라고도 함
- 파일 디스크립터는 파일마다 독립적으로 존재하며, 시스템에 따라 다른 구조를 가질 수 있다.
- 보통 파일 디스크립터는 보조기억장치 내에 저장되어 있다가 해당 파일이 Open될때 주기억장치로 옮겨진다.
- 파일 디스크립터는 파일 시스템이 관리하므로 사용자가 직접 참조할 수 없다.

## 기억장치 관리 - 배치(Placement) 전략
배치 전략은 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략이다.
1. 최초 적합(First Fit): 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법
2. 최적 적합(Best Fit): 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법
3. 최악 적합(Worst Fit): 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법

## 페이징(Paging) 기법
- 페이징 기법은 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법이다.
- 프로그램을 일정한 크기로 나눈 단위를 페이지(Page)라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치위 단위를 페이지 프레임(Page Frame)이라고 한다.
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.
- 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블(Page Map Table)이 필요하다.

## 세그먼테이션(Segmentation) 기법
- 세그먼테이션 기법은 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법이다.
- 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트(Segment) 라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 주소 변환을 위해서 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블(Segment Map Table) 이 필요하다.
- 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.

## 페이지 교체 알고리즘
페이지 교체 알고리즘은 페이지 부재(Page Fault)가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법이다.

1. OPT(OPTimal replacement, 최적 교체)
- 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
- 벨레이디가 제안한 것으로, 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘

2. FIFO(First in First Out)
- 각 페이지가 주기억장치에 적재될 때마다 그떄의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법
- 이해하기 쉽고, 프로그래밍 및 설계가 간단함

3. LRU(Least Recently Used)
- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
- 각 페이지마다 계수기(Counter)나 스택(Stack)을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래 전에 사용된 페이지를 교체함

4. LFU (Least Frequently Used)
- 사용 빈도가 가장 적은 페이지를 교체하는 기법
- 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용됨

5. SCR(Second Chance Replacement, 2차 기회 교체)
가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법

6. NUR(Not Used Recently)
- LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
- 최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음
- 최근의 사용 여부를 확인하기 위해서 각 페이지마다 두 개의 비트, 즉 참조 비트(Reference Bit)와 변형 비트(Modefied Bit, Dirty Bit)가 사용됨.

## 페이지 크기
### 페이지 크기가 작을 경우
- 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다.
- 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋을 유지할 수 있다.
- Locality에 더 일치할 수 있기 때문에 기억장치 효율이 높아진다.
- 디스크 접근 횟수가 많아져서 전체적인 입출력 시간은 늘어난다.

### 페이지 크기가 클 경우
- 페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다.
- 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어난다.
- 프로세스(프로그램)수행에 불필요한 내용까지도 주기억장치에 적재될 수 있다.

## Locality
Locality(국부성, 지역성, 구역성, 국소성)는 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 이있다는 이론이다.
- 스레싱을 방지하기 위한 워킹 셋 이론의 기반이 되었다.
- Locality의 종류에는 시간 구역성(Temporal Locality)과 공간 구역성(Spatial Locality)이 있다.

### 시간 구역성(Temporal Locality)
- 시간 구역성은 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 엑세스하는 현상이다.
- 한 번 참조하는 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음을 의미한다.
- 시간 구역성이 이루어지는 기억 장소: Loop(반복, 순환), 스택(Stack), 부 프로그램(Sub Routine), Counting(1씩 증감), 집계(Totaling)에 사용되는 변수(기억장소)

### 공간 구역성(Spatial Locality)
- 공간 구역성은 프로세스 실행 시 일정 위치의 페이지를 집중적으로 엑세스하는 현상이다.
- 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음을 의미한다.
- 공간 구역성이 이루어지는 기억장소: 배열 순회(Array Traversal, 배열 순례), 순차적 코드의 실행, 프로그래머들이 관련된 변수(데이터를 저장할 기억장소)들을 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때 사용

## 워킹 셋(Workng Set)
워킹 셋은 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합이다.
- 데닝이 제안한 프로그램의 움직임에 대한 모델로, 프로그램의 Locality 특징을 이용한다.
- 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정된다.
- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경된다.

## 스래싱(Thrashing)
스래싱은 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상이다.
- 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중 자주 페이지 부재가 발생함으로써 나타나는 현상으로, 전체 시스템의 성능이 저하된다.
- 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소하게 된다.

### 스래싱 현상 방지 방법
- 다중 프로그래밍의 정도를 적정 수준으로 유지한다.
- 페이지 부재 빈도(Page Fault Frequency)를 조절하여 사용한다.
- 워킹 셋을 유지한다.
- 부족한 자원을 증설하고, 일부 프로세스를 중단시킨다.
- CPU 성능에 대한 자료의 지속적 관리 및 분석으로 임계치를 예상하여 운영한다.

## 프로세스(Process)의 정의
프로세스는 일반적으로 프로새서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미하며, 작업(Job), 태스크(Task)라고도 한다.
- 프로세스는 다음과 같이 여러 형태로 정의할 수 있다.
1. PCB를 가진 프로그램
2. 실기억장치에 저장된 프로그램
3. 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위
4. 프로시저가 활동중인 것
5. 비동기적 행위를 일으키는 주체
6. 지정된 결과를 얻기 위한 일련의 계통적 동작
7. 목적 또는 결과에 달라 발생되는 사건들의 과정
8. 운영체제가 관리하는 실행 단위

## PCB
PCB(Process Control Block, 프로세스 제어 블록)는 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳으로, Task Control Block 또는 Job Control Block 이라고도 한다.
- 각 프로세스가 생성될 떄마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.

### PCB에 저장되어 있는 정보
- 프로세스의 현재 상태
- 포인터
1. 부모 프로세스에 대한 포인터
2. 자식 프로세스에 대한 포인터
3. 프로세스가 위치한 메모리에 대한 포인터
4. 할당된 자원에 대한 포인터

- 프로세스 고유 식별자
- 스케줄링 및 프로세스의 우선순위
- CPU 레지스터 정보
- 주기억장치 관리 정보
- 입/출력 상태 정보
- 계정 정보

## 프로세스 상태 전이
프로세스 상태 전이는 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것을 의미하며, 프로세스의 상태를 다음과 같이 상태 전이도로 표시할 수 있다.

```
제출(Submit) -> 접수(Hold) - Job 스케줄러 -> 준비(Ready) - Dispatch -> 실행(Run) -> 종료(Terminal Exit)
접수(Hold) <- Spooling -> 디스크
실행(Run) -> 입,출력 발생 ->  대기(Wait, Block) -> 입 출력 종료 깨움(Wake up) -> 준비(Ready)
```
- 프로세스의 상태는 제출, 접수, 준비, 실행, 대기 상태로 나눌 수 있으며, 이 중 주요 세 가지 상태는 준비, 실행, 대기 상태이다.
- 제출(Submit): 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
- 접수(Hold): 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태
- 준비(ready): 프로세스가 프로세서를 할당받기 위해  기다리고 있는 상태
- 실행(Run): 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
- 대기(Wait), 보류, 블록(Block): 프로세스에 입/출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고 입/출력 처리가 완료될 때까지 대기하고 있는 상태
- 종료(Terminated, Exit): 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태

## 프로세스 상태 전이 관련 용어
### Dispatch
준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정

### Wake up
입/출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정

### Spooling
시스템의 성능을 향상시키기 위해 입/출력할 데이터를 직접 입출력장치에 보내지 않고 나중에 한꺼번에 입출력하기위해 디스크에 저장하는 과정

### 교통량 제어기(Traffic Controller)
프로세스의 상태에 대한 조사와 통보를 담당함

## 스레드(Thread)
스레드는 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위이다.
- 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 한다.
- 프로세스의 일부 특성을 갖고 있기 때문에 경량(light) 프로세스 라고도 한다.
- 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다.
- 동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능하다.
- 스레드의 분류
### 사용자 수준의 스레드
- 사용자가 만든 라이브러리를 사용하여 스레드를 운용함
- 속도는 빠르지만 구현이 어려움
### 커널 수준의 스레드
- 운영체제의 커널에 의해 스레드를 운용함
- 구현이 쉽지만 속도가 느림

- 스레드 사용의 장점
1. 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성을 증진시킬 수 있다.
2. 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.
3. 응용 프로그램의 응답 시간(Response Time)을 단축시킬 수 있다.
4. 실행 환경을 공유시켜 기억장소의 낭비가 줄어든다.
5. 프로세스들 간의 통신이 향상된다.
6. 스레드는 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신한다.

## 주요 스케줄링 알고리즘
#### FCFS(Fist Come First Service, 선입 선출) = FIFO(First In First Out)
FCFS는 준비상태 큐(대기 큐, 준비 완료 리스트, 작업준비 큐, 스케줄링 큐)에 도착한 순서에 따라 차례로 CPU를 할당하는 기법으로, 가장 간단한 알고리즘이다.
- 먼저 도착한 것이 먼저 처리되어 공평성은 유지되지만 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 된다.

### SJF(Shortest Job First, 단기 작업 우선)
SJF는 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법이다.
- 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘이다.

### HRN(Hightest Response-ratio Next)
실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스(실행)시간을 이용하는 기법이다.
- 우선순위 계산 공식을 이용하여 서비스(실행)시간이 짧은 프로세스나 대기 시간이 긴 프로세스에게 우선순위를 주어 CPU를 할당한다.
- 서비스 실행 시간이 짧거나 대기 시간이 긴 프로세스일 경우 우선순위가 높아진다.
- 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여된다. 
- 우선순위 계산식
```
우선순위 계산식 = (대기시간 + 서비스 시간) / 서비스 시간
```

## UNIX / LINUX의 주요 환경 변수
UNIX나 LINUX에서 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞에 '$'를 입력해야 한다.
- UNIX나 LINUX에서는 set, env, printenv, setenv 중 하나를 입력하면 모든 환경 변수와 값을 표시한다.
- `$DISPLAY`: 현재 X 윈도 디스플레이 위치
- `$PS!`: 쉘 프롬포트 정보
- `$HOME`: 사용자의 홈 디렉터리
- `$PWD`: 현재 작업하는 디렉터리
- `$LANG`: 프로그램 사용 시 기본적으로 지원되는 언어
- `$TERM`: 로긴 터미널 타입
- `$MAIL`: 메일을 보관하는 경로
- `$USER`: 사용자의 이름
- `$PATH`: 실행 파일을 찾는 경로

## UNIX/LINUX 기본 명령어
- `cat`: 파일 내용을 화면에 표시함
- `chdir`: 현재 사용할 디렉터리의 위치를 변경함
- `chmod`: 파일의 보호 모드를 설정하여 파일의 사용 허가를 지정함
- `chown`: 소유자를 변경함
- `cp`: 파일을 복사함
- `exec`: 새로운 프로세스를 수행함
- `find`: 파일을 찾음
- `fork`: 새로운 프로세스를 생성함(하위 프로세스 호출, 프로세스 복제 명령)
- `fsdk`: 파일 시스템을 검사하고 보수함
- `getpid`: 자신의 프로세스 아이디를 얻음
- `getppid`: 부모 프로세스 아이디를 얻음
- `ls`: 현재 디렉터리 내의 파일 목록을 확인함
- `mount/unmount`: 파일 시스템을 마운팅한다 / 마운팅 해제함
- `rm`: 파일을 삭제함
- `wait`: fork 후 exec에 실행되는 프로세스의 상위 프로세스가 하위 프로세스 종료 등의 event를 기다림

## IP 주소(Internet Protocol Address)
IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다.
- 숫자로 8비트씩 4부분, 총 32비트로 구성되어 있다.
- IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다.
### A Class
국가나 대형 통신망에 사용(0~127로 시작), 2^24 = 16,777,216개의 호스트 사용 가능

### B Class
중대형 통신망에 사용(128~191로 시작), 2^16 = 65,536개의 호스트 사용가능

### C Class
소규모 통신망에 사용(192~223으로 시작), 2^8 = 256개의 호스트 사용 가능

### D Class
멀티캐스트용으로 사용 (224~239로 시작)

### E Class
실험적 주소이며 공용되지 않음

## 서브네팅(Subnetting)
서브네팅은 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것을 말한다.
- 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다.
- 서브넷 마스크는 각 클래스마다 다르게 사용된다.

## IPv6(Internet Protocol version 6)
IPv6은 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발되었다.
- 128비트의 긴 주소를 사용하여 주소 부족 문제를 해결할 수 있으며, IPv4에 비해 자료 전송 속도가 빠르다.
- 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있다.
- IPv4와 호환성이 뛰어나다.
- 주소의 확장성, 융통성, 연동성이 뛰어나며, 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원한다.
- 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없다.

## IPv6의 구성
- 16비트씩 8부분, 총 128비트로 구성되어 있다.
- 각 부분을 16진수로 표현하고, 콜론(:)으로 구분한다.
- IPv6은 다음과 같이 세가지 주소 체계로 나누어진다.
1. 유니캐스트(Unicast) 단일 송신자와 단일 수신자 간의 통신(1대1 통신에 사용)
2. 멀티캐스트(Multicast): 단일 송신자와 다중 수신자 간의 통신(1대 다 통신에 사용)
3. 애니캐스트(Anycast): 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신(1대 1 통신에 사용)

## OSI 참조 모델
- 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)이다.
- OSI 7계층은 1~3계층을 하위 계층, 4~7계층을 상위 계층이라고 한다.
- 하위 계층: 물리 계층 -> 데이터 링크 계층 -> 네트워크 계층
- 상위 계층: 전송 계층 -> 세션 계층 -> 표현 계층 -> 응용 계층

### 물리 계층(Physical Layer)
전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의함

### 데이터 링크 계층(Data Link Layer)
- 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템간 연결 설정과 유지 및 종료를 담당함.
- 송신 측과 수신 측의 속도 차이를 해결하기 위한 흐름 제어 기능을 함
- 프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능을 함
- 오류의 검출과 회복을 위한 오류 제어 기능을 함

### 네트워크 계층(Network Layer, 망 계층)
- 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 함.
- 네트워크 연결을 설정, 유지, 해제하는 기능을 함
- 경로 설정(Routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행함

### 전송 계층(Transport Layer)
- 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(End-To-End)간에 투명한 데이터 전송을 가능하게 함
- 종단 시스템 간의 전송 연결 설정, 데이터 설정, 연결 해제 기능을 함
- 주소 설정, 다중화(분할 및 재조립), 오류 제어, 흐름 제어를 수행함

### 세선 계층(Session Layer)
- 송/수신측 간의 관련성을 유지하고 대화 제어를 담당함
- 대화(회화)구성 밑 동기 제어, 데이터 교환 관리 기능을 함

### 표현 계층(Presentation Layer)
- 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능을 함
- 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층
- 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포맷)변환, 문맥 관리 기능을 함

### 응용 계층(Application Layer)
사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공함

## 네트워크 관련 장비
1. 네트워크 인터페이스 카드(NIC: Network Interface Card)
컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치로, 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경함

2. 허브(Hub)
- 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하는 리피터의 역할도 포함함.
- 허브의 정류에는 더미 허브, 스위칭 허브가 있음

3. 리피터(Repeater)
전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행함

4. 브리지(Bridge)
- LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹(세그먼트)을 연결하는 기능을 수행함
- 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있음

5. 스위치(Switch)
- 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치
- 하드웨어를 기반으로 처리하므로 전송 속도가 빠름

6. 라우터(Router)
브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가된 것으로, 서로 다른 LAN이나 LAN과 WAN의 연결도 수행함

7. 게이트웨이(Gateway)
- 전 계층(1~7계층)의 프로토콜 구조가 다른 네트워크의 연결을 수행함
- LAN 에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할을 함

## 응용 계층의 주요 프로토콜
1. FTP(File Transfer Protocol)
컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜

2. SMTP(Simple Mail Transfer Protocol)
전자 우편을 교환하는 서비스

3. TELNET
- 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스
- 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널(Virtual Terminal) 기능을 수행

4. SNMP(Simple Network Management Protocol)
TCP/IP 의 네트워크 관리 프로토콜로, 라우터나 허브 등 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용되는 표준 통신 규약

5. DNS (Domain Name System)
도메인 네임을 IP 주소로 매핑(Mapping) 하는 시스템

6. HTTP(HyperText Transfer Protocol)
월드 와이드 웹(www)에서 HTML 문서를 송수신 하기 위한 표준 프로토콜

## 전송 계층의 주요 프로토콜
1. TCP(Transmission Control Protocol)
- 양방향 연결(Full Duplex Connection)형 서비스를 제공함
- 스트림 위주의 전달(패킷 단위)을 함
- 신뢰성 있는 경로를 확립하고 메시지 전송을 감독함
- 순서 제어, 오류 제어, 흐름 제어 기능을 함
- TCP 프로토콜의 헤더는 기본적으로 20Byte에서 60Byte까지 사용할 수 있는데, 선택적으로 40Byte를 더 추가할 수 있으므로 최대 100Byte까지 크기를 확장할 수 있음.

2. UDP(User Datagram Protocol)
- 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공함
- TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로 오버헤드가 적고, 흐름제어나 순서 제어가 없어 전송 속도가 빠름
- 실시간 전송에 유리하며, 신뢰성보다는 속도가 중요시되는 네트워크에서 사용됨

3. RTCP(Real-Time Control Protocol)
- RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜
- 세션(Session) 에 참여한 각 참여자들에게 주기적으로 제어 정보를 전송함

## 인터넷 계층의 주요 프로토콜
1. IP(Internet Protocol)
- 전송할 데이터에 주소를 지정하고, 경로를 설정하는 기능을 함
- 비연결형인 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않음

2. IMCP(Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜)
IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메세지를 관리하는 역할을 하며, 헤더는 8Byte로 구성됨

3. IMGP(Internet Group Management Protocol, 인터넷 그룹 관리 프로토콜)
멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용됨

4. ARP(Address Resolution Protocol, 주소 분석 프로토콜)
호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로 바꿈

5. RARP(Reverse Address Resolution Protocol)
ARP와 반대로 물리적 주소를 IP 주소로 변환하는 기능을 함