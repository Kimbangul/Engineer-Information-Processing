###1 요구사항 확인
1. 소프트웨어 재공학 과정
- 분석 -> 구성 -> 역공학 -> 이식

2. XP의 5가지 핵심가치
(피존의 용기는 단순하게 소통한다)
피드백, 존중, 용기, 단순성, 소통

- 피드백: 지속적인 테스트와 반복적 결함 수정
- 존중: 모든 프로젝트 관리자는 팀원의 기여 존중
- 용기: 고객 요구사항 변화에 능동적인 대처
- 단순성: 부가적 기능, 사용하지 않는 알고리즘을 배제
- 소통: 개발자, 관리자, 고객 간의 원활한 소통

3. 스크럼마스터
- 업무 배분만 하고 일은 강요하지 않음
- 팀을 스스로 조직하고 관리하도록 지원
- 개발 과정에서 스크럼의 원칙과 가치 지원
- 개발 과정 장애 요소를 찾아 제거

4. 현행 시스템 파악절차 순서
- 1단계: 시스템 구성 파악 -> 시스템 기능 파악 -> 시스템 인터페이스 현황 파악
- 2단계: 아키텍처 파악 -> 소프트웨어 구성 파악
- 3단계: 시스템 하드웨어 현황 파악 -> 네트워크 구성 파악

5. 애플리케이션 개발 단계에서 요구사항을 분석한 뒤, 요구사항을 명세하는 명세 3종류
- 시스템 정의서, 시스템 요구사항 명세서, 소프트웨어 요구사항 명세서

6-1. 구조적 다이어그램 종류 작성
1) 클래스: 시스템을 구성하는 클래스 사이 관계
2) 패키지: 클래스나 유스케이스 등 여러 모델 요소를 그룹화하여 패키지를 구성하고, 그 패키지 사이의 관계를 표현
3) 복합체 구조: 복합 구조의 클래스와 컴포넌트 내부 구조를 표현
4) 객체: 객체 정보를 보여준다. (럼바우 객체지향 분석기법에서 활용됨)
5) 컴포넌트: 컴포넌트 구조 사이의 관계를 표현
6) 배치: 소프트웨어, 하드웨어, 네트워크를 포함한 실행 시스템의 물리 구조를 표현

6-2. 럼바우 객체지향 분석
1) 객체 모델링(Object Modeling)
- 정보 모델링이라고도 하며, 시스템에서 요구하는 객체를 찾고 객체들 간의 관계를 정의. 가장 중요하고 선행되어야 함. 결과물로 객체 다이어그램이 나온다.

2) 동적 모델링(Dynamic Modeling)
- 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현, 결과물로 상태 다이어그램이 나온다.

3) 기능 모델링(Functional Modeling)
- 프로세스들의 자료 흐름을 중심으로 처리 과정을 표현. 결과물로 DFD(자료 흐름도)가 나온다.

7. 행위 다이어그램의 종류
1) 유스케이스: 사용자 관점에서 시스템 행위를 표현
2) 활동: 업무 처리 과정이나 연산이 수행되는 과정을 표현
3) 콜라보레이션: 순차 다이어그램과 같으며, 모델링 공간에 제약이 없어 구조적인 면 중시
4) 상태머신: 객체의 생명주기 표현
5) 순차: 시간 흐름에 따른 객체 사이의 상호작용
6) 통신: 객체 사이의 관계를 중심으로 상호작용 표현
7) 상호작용 개요: 상호작용 다이어그램 사이 제어흐름 표현
8) 타이밍: 객체 상태 변화와 시간 제약을 명시적으로 표현

8. UML에서 표현하는 기본 기능 외 추가적인 기능을 표현하는 것
- 스테레오 타입이라고 부르며 <<>> 로 표기한다.
- 종류: include, extend, interface, exception, constructor

9. 유스케이스 다이어그램 정의와 구성요소
- 정의: 사용자와 다른 외부 시스템이 향후 개발될 시스템을 이용해 수행할 수 있는 기능을 '사용자의 관점' 에서 기술한 것
- 구성요소: 시스템(네모로 표기) / 액터 / 유스케이스(타원형으로 표기) / 관계(화살표)

10. 디자인 패턴
1) 생성패턴: 추상팩토리, 빌더, 팩토리메서드, 프로토타입, 싱글톤 -> 객체를 만들 때 생성
2) 구조패턴: 어댑터, 브릿지, 컴포지트, 데코레이터, 퍼사드, 플라이웨이트, 프록시 -> 구조를 짤 때
3) 행위패턴: 스테이트, 스트레티지(전략), 템플릿메서드, 메멘토, 옵서버, 커맨드, 인터프리터, 책임연쇄, 비지터(visitor), 이터레이터, 미디에이터(중재자) -> 객체들이 어떻게 움직일까

11. 비용산정 모형 분류
1) 하향식 산정방법
- 델파이 기법: 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 기법

2) 상향식 산정방법
1) LoC(코드 라인수): 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구해 비용 산정
2) COCOMO: 보헴이 제안한 모형으로 프로그램 규모에 따라 비용 산정
3) Man Month: 한 사람이 1개월 간 할 수 있는 일의 양을 기준으로 비용 산정

12. 소프트웨어 아키텍처 4+1뷰
1) 유스케이스 뷰: 아키텍처를 도출하고 설계하는 작업을 주도하는 뷰
2) 논리 뷰: 설계 모델의 추상화, 주요 설계 패키지와 서브 시스템, 클래스 식별 뷰
3) 프로세스 뷰: 성능이나 가용성 같은 비기능적 요구사항을 고려하는 뷰
4) 구현 뷰: 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 표현하는 뷰
5) 배포 뷰: 물리적인 노드의 구성과 상호연결 관계를 배포 다이어그램으로 표현하는 뷰

13. 플랫폼 성능 특성 분석 항목 3가지
- 응답시간, 가용성, 사용률

14. CMMi 5단계
* CMMi: 카네기 멜런 대학의 소프트웨어 공학 전문 연구소의 지침
- 초기단계 -> 관리단계 -> 정의단계 -> 정량적 관리단계 -> 최적화 단계

15. 소프트웨어 아키텍처의 평가 및 설계에 사용되는 다양한 방법론과 기술
- SAAM(Software Architecture Analysis Method)
- ATAM (Architecture Trade-off Analysis Method)
- CBAM (Cost Benefit Analysis Method)
- ADR (Active Design Review)
- ARID (Active Review for Intermediate Designs)

###2. 데이터 입출력 구현
1. 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 스키마의 종류는?
- 외부 스키마: 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
- 개념 스키마: 데이터베이스의 전체적인 논리적 구조, 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재함.
- 내부 스키마: 물리적 저장장치 입장에서 본 데이터베이스 구조, 실제로 저장될 레코드의 형식이나 저장 데이터 항목의 표현방법과 내부 레코드 물리적 순서 등을 나타냄

2. 튜플, 차수, 속성
- 튜플: 릴레이션을 구성하는 각각의 행으로, 튜플의 수를 카디널리티 또는 기수라고 한다. 중복이 허용될 수 있으며 셀 수 있는 수량의 순서 있는 열거이다. (=레코드), (튜플의 수 = 카디널리티)
- 카디널리티: 특정 데이터 집합의 유니크한 값의 개수로, 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표이다.
- 차수: 한 릴레이션에 들어있는 애트리뷰트 수를 차수라고 한다.
- 속성: 하나의 릴레이션은 현실세계의 어떤 개체를 표현하는데, 이 개체에 저장하고 싶은 속성 정보를 뜻한다. (속성의 수 = 디그리 = 차수)
- 릴레이션 인스턴스: 어느 한 시점에서 릴레이션의 내용(상태), 저장된 데이터 전체를 의미한다.

3. 일반 집합 연산자
- 합집합(∪): 두 릴레이션의 튜플의 합집합, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거한다.
- 교집합(∩): 두 릴레이션의 튜플의 교집합
- 차집합(–): 두 릴레이션의 튜플의 차집합
- 교차곱(×): 두 릴레이션의 튜플들의 순서쌍

4. 관계대수와 관계해석
- Select: 선택조건을 만족하는 튜플의 부분집합을 구해서 새로운 릴레이션을 만든다. 행(가로)에 해당하는 튜플을 구하는 것으로 수평연산
표기형식:σ(조건) (릴레이션이름)
- Project: 속성 리스트에 제시된 속성 값만을 추출해 새로운 릴레이션을 만드는 연산. 열에 해당하는 속성을 추출하므로 수직연산이며 속성만 추출하므로 '중복을 제거함'
표기형식: π(속성리스트)(릴레이션이름)
- Join: 공통 속성을 중심으로 두 개 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
표기형식: (릴레이션속성)▷◁(키속성r-릴레이션R의속성)=(키속성s-릴레이션S의속성)S
- Division: 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것으로 수평연산. Division은 X⊂Y(부분집합)인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
표기형식: R[속성r ÷ 속성a]S

5. 관계형 데이터베이스의 제약조건
- 개체 무결성: 기본 테이블의 기본키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다.
- 참조무결성: 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉, 릴레이션은 참조할 수 없는 외래키값을 가질 수 없다는 규정
- 도메인무결성: 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
- 사용자정의무결성: 속성 값들이 사용자가 정의한 제약조건에 만족되어야 한다는 규정
- NULL 무결성: 릴레이션의 특정 속성 값이 Null이 될 수 없도록 하는 규정
- 관계 무결성: 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 릴레이션과 다른 릴레이션의 튜플들 사이에 관계의 적정성 여부를 지정한 규정

* 도메인이란? : 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자들의 집합(예: 성별 애트리뷰트의 도메인은 "남"과 "여" 이다.)

6. 정규형의 과정 설명(도부이결다조)
1) 도메인이 원자값(비정규 -> 1정규형)
2) 부분적 함수 종속 제거 (1정규형 -> 2정규형)
3) 이행적 함수 종속 제거 (2정규형 -> 3정규형)
4) 결정자이면서 후보키가 아닌 것 제거 (3정규형 -> BCNF정규형)
5) 다치 종속 제거 (BCNF정규형 -> 4정규형)
6) 조인 종속성 이용 (4정규형 -> 5정규형)

6. 반정규화
- 정의: 시스템의 성능을 향상하고 개발 및 운영의 편의성을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위
- 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만, 데이터의 일관성 및 정합성이 저하될 수 있다.
- 방법: 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가

7. 시스템 카탈로그
- 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
- 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다.
- 카탈로그들이 생성되면 데이터 사전에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 사전이라고도 한다.

8. 트랜잭션의 특성
- 원자성(Atomicity): 트랜잭션의 연산은 데이터베이스에 모두 반영되거나 전혀 반영되지 않아야 한다. (Commit, Rollback)의 성질
- 일관성(Consistency): 트랜잭션이 그 실행을 성공적으로 완료하면, 언제나 일관성 있는 데이터베이스 상태로 변환된다.
- 독립성, 격리성(Isolation): 둘 이상의 트랜잭션이 동시에 병행되어 실행되는 경우 어느 하나의 트랜잭션 실행 중에는 다른 트랜잭션의 연산이 끼어 들 수 없다.
- 지속성, 영속성(Durability): 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장 나더라도 영구적으로 반영되어야 한다.

7. 접근 통제 기술
- 임의 접근통제(DAC): 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여
- 강제 접근통제(MAC): 주체와 객체 등급을 비교하여 접근 권한을 부여
- 역할기반 접근통제(RBAC): 사용자의 역할에 따라 접근 권한을 부여

8. 파티션의 정의와 종류
- 정의: 데이터베이스에서 파티션은 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 말한다.
(1) 범위 분할: 지정한 열의 기준으로 분할함
(2) 해시 분할: 해시 함수를 적용한 결과값에 따라 데이터를 분할함
(3) 조합 분할: 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식

9. 분산 데이터베이스의 목표
- 위치 투명성: 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스 할 수 있다.
- 중복 투명성: 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행한다.
- 병행 투명성: 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.
- 장애 투명성: 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다.

10. 클러스터
- 데이터 저장시 데이터 액세스의 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적인 방법

11. 데이터 모델 구성 3요소
- 구조: 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현
- 연산: 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로 데이터베이스를 조작하는 도구
- 제약조건: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

12. 함수적 종속성(Functional Dependency)
- 속성 Y가 속성 X에 함수적으로 종속된다는 말은 속성 X를 이용하여 속성 Y를 식별할 수 있다는 말이다.
- 완전 함수종속
- 부분 함수종속

13. SQL DDL, DML, DCL 종류
- DDL: CREATE, ALTER, DROP, RENAME, TRUNCATE
- DML: SELECT, INSERT, UPDATE, DELETE
- DCL: GRANT, REVOKE
- TCL: COMMIT, ROLLBACK, SAVEPOINT

학생 테이블에 대한 권한 부여:
GRANT SELECT, INSERT ON student TO kim, lee;

학생 테이블에 대한 권한 회수:
REVOKE SELECT, INSERT ON student from lee;

### 3. 통합 구현
1. 웹 서비스는 네트워크에 분산된 정보를 서비스 형태로 개방하여 표준화된 방식으로 공유하는 기술로 서비스 지향 아키텍처 개념을 실현하는 대표적 (SOA)기술이다.
- UDDI: 웹 서비스에 대한 정보인 WSDL을 등록하고 검색하기 위한 저장소로, 공개적으로 접근/검색이 가능한 레지스트리
- WSDL: 웹 서비스명, 제공 위치, 메세지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML로 구현되어 있는 언어
- SOAP: HTTP, HTTPS, SMTP 등을 이용하여 XML 기반의 메세지를 네트워크 상태에서 교환하는 프로토콜

2. 연계(인터페이스) 구성
- 송신 시스템, 중계 시스템, 수신 시스템

3. 연계 테스트 진행 순서
- 연계 케이스 작성 -> 연계 테스트 환경 구축 -> 연계 테스트 수행 -> 연계 테스트 수행 결과 검증

4. 연계 방식 종류 - 직접 연계
- DB Link: 한 데이터베이스에서 네트워크상의 다른 데이터베이스에 접속하기 위한 설정을 해 주는 오라클 객체
- DB Connection Pool: 수신 시스템 WAS에서 송신 시스템 DB로 연결되는 Connection Pool을 생성하고 프로그램 소스에서 WAS에 설정된 Connection Pool명을 참고하여 구현한다.
- JDBC: 수신 시스템의 Batch, Online 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템의 DB와 연결을 생성한다.
- 화면 링크: 웹 애플리케이션 화면에서 하이퍼링크를 사용한다. (ex: a태그)
- API / Open API: 송신시스템의 DB와 연결하여 데이터를 제공하는 인터페이스 프로그램

5. 연계 방식 종류 - 간접 연계
- EAI: 실제 송수신 처리와 진행 현황을 모니터링 및 통제하는 EAI 서버, 송수신 시스템에 설치되는 어댑터 (Client)를 말한다. 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해 주는 솔루션
- 구축유형: Point to Point, Hub & Spoke, Message Bus, Hybrid
(1) Point-to-Point: 중간에 미들웨어를 두지 않고 각 애플리케이션 간 Point to Point 형태 연결
(2) Hub & Spoke: 단일 접점이 허브 시스템을 통해 데이터를 전송하는 중앙 집중적 방식
(3) Message Bus: 애플리케이션 사이 미들웨어를 두어서 처리하는 방식
(4) Hybrid: (2), (3) 혼합방식으로 데이터 병목현상을 최소화하는 방식
- Web Service/ESB: 웹 서비스가 설명된 WSDL과 SOAP 프로토콜을 이용한 시스템을 연계한다. 미들웨어인 ESB에서 서비스 간 연동을 위한 변환 처리로 다중 플랫폼을 지원한다.
- Socket: 소켓을 생성하여 포트를 할당하고, 클라이언트의 요청을 연결하여 통신하는 네트워크 프로그램의 기반 기술이다.

6. 객체지향 설계원칙 (설계 5대 원칙)
(1) 단일 책임 원칙 (Single Responsibility Principle): 모든 클래스는 각각 하나의 책임만 가져야 한다.
클래스는 그 책임을 완전히 캡슐화해야 한다.
ex) 계산 클래스는 오직 사칙연산 기능만 책임진다.

(2) 개방/폐쇄 원칙(Open Closed Principle)
확장에는 열려 있고, 수정에는 닫혀있어야 한다.
기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
ex) 캐릭터를 설계할 때 각각의 캐릭터가 움직임이 다른 경우, 하위 클래스에게 움직임을 구현 위임

(3) 리스코프 치환 원칙 (Liskov Subsititution Principle)
자식 클래스는 언제나 부모의 클래스를 대체할 수 있다.

(4) 인터페이스 분리 원칙 (Interface Separation Principle)
한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.

(5) 의존 역전 원칙 (Dependency Inversion Principle)
의존 관계를 맺을 때 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺을 것

### 4. 서버 프로그램 구현
1. 개발 언어의 선정 기준 5가지
- 적정성, 효율성, 이식성, 친밀성, 범용성

2. 소프트웨어 아키텍처의 설계 과정
- 설계 목표 설정 -> 시스템 타입 설정 -> 아키텍처 패턴 적용 -> 서브 시스템 구체화 -> 검토

3. 아키텍처 패턴
(1) 레이어 패턴: 시스템을 계층으로 구분하여 구성하는 고전적인 방법의 패턴
(2) 클라이언트 - 서버: 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
(3) 파이프-필터 패턴: 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴
(4) 모델-뷰-컨트롤러 패턴: 서브 시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴
(5) 기타: 마스터-슬레이브 패턴, 브로커 패턴, 피어-투-피어 패턴, 이벤트-버스 패턴, 블랙보드 패턴

5. 객체 지향 분석의 방법론
- 럼바우 방법: 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법 (객체모델링, 동적모델링, 기능모델링 순으로 이뤄진다.)
- 부치 방법: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용함
- 자콥스 방법: 유스케이스를 강조하여 사용
- Coad와 Youdon 방법: E-R 다이어그램을 사용하여 객체의 행위를 모델링함
- Wirfs-Brock 방법: 분석과 설계 간의 구분이 없으며 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행한다.

6. 객체지향 설계원칙 5가지
- 단일 책임 원칙: 객체는 단 하나의 책임만 가져야 한다.
- 개방-폐쇄 원칙: 기존의 코드를 변경하지 않고, 기능을 추가할 수 있도록 설계해야 한다.
- 리스코프 치환 원칙: 자식 클래스는 최소한 부모 클래스의 기능을 수행할 수 있어야 한다.
- 인터페이스 분리 원칙: 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다.
- 의존 역전 원칙: 의존 관계 성립시, 추상성이 높은 클래스와 의존 관계를 맺어야 한다.

7. 소프트웨어 아키텍처 설계 기본 원리
- 모듈화: 소프트웨어 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
- 추상화: 문제의 전체적이고 포괄적인 개념을 설계한 후, 차례로 세분화하여 구체화시켜 나가는 것
- 단계적 분해: 문제를 상위의 중요 개념으로부터 하위의 중요 개념으로 구체화시키는 분할 기법
- 정보 은닉: 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

8. 모듈의 독립성은 결합도와 응집도에 의해서 측정된다.
- 모듈의 독립성을 높이기 위해서는 결합도는 약하게, 응집도는 높게 해야 한다.

9. IPC: 모듈 간 통신 방식을 구현하기 위한 대표적인 프로그래밍 인터페이스 집합
- Inter-Process Communication: 프로세스 간 통신
- Shared memory: 공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식
- Socket: 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스 간에 통신하는 방식
- Semaphores: 공유 자원에 대한 접근 제어를 통해 통신하는 방식
- Pipes & Named Pipes: "Pipe"라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식
- Message Queueing: 메세지가 발생하면 이를 전달하는 방식으로 통신하는 방식

10. 서버 개발 과정은 DTO/VO, SQL, DAO, Service, Controller를 각각 구현하는 과정이다.
- DTO/VO 구현: 데이터 교환을 위해 사용할 객체 만드는 과정
- SQL 구현: 데이터 삽입/변경/삭제 등의 작업을 수행할 SQL문을 생성하는 과정
- DAO 구현: 데이터베이스에 접근하고, SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정
- Service 구현: 사용자의 요청에 응답하기 위한 로직을 구현하는 과정
- Controller 구현: 사용자의 요청에 적절한 서비스를 호출하여 그 결과를 사용자에게 반환하는 코드를 구현하는 과정

11. 소프트웨어 재사용을 위한 공통 모듈화
1) 분할과 정복 (Divide & Conquer): 복잡한 문제를 분해해서 모듈 단위로 해결
2) 자료추상화: 함수 내의 자료 구조, 표현 내역을 숨기고 인터페이스를 통해 접근
3) 모듈 독립성: 각 모듈의 결합도를 줄이고 응집도를 높인다.
4) 정보 은닉: 중요한 정보나 노출 가능성이 큰 모듈을 은닉한다.
5) 비용과 모듈: 모듈 수가 많아지면, 비용도 증가한다

12. MVC 패턴
- Model-View-Controller 의 줄임말고, 애플리케이션을 세 가지 주요 구성 요소인 모델(Model), 뷰(View), 컨트롤러(Controller)로 분리하여 개발의 효율성과 유지보수성을 높인다
- Model: 데이터와 비즈니스 로직을 담당. 데이터를 관리하고 비즈니스 핵심 로직을 처리하고, 데이터를 가공하며 애플리케이션의 상태를 유지
- View: 사용자 인터페이스 담당. 데이터 표시나 버튼, 텍스트 필드 등을 포함
- Controller: 사용자의 입력을 처리하고 모델을 업데이트하며 뷰를 업데이트함. 모델과 뷰 사이에서 연결하는 역할

13. 배치 프로그램: 일정 스케줄마다 돌아가면서 일괄 처리하는 프로그램

14. 결합도(Coupling): 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관관계 (결합도가 강한 순서: 내공외제스자)
내용 결합도(Content) -> 공통 결합도(Common) -> 외부 결합도(External) -> 제어 결합도(Control) -> 스탬프 결합도(Stamp) -> 자료 결합도(Data)
1) 내용: 한 모듈이 다른 모듈의 내부 기능 및 내부 자료를 직접 참조하거나 수정
2) 공통: 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도(전역변수 쓸 때)
3) 외부: 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때 결합도
4) 제어: 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어요소(flag)를 전달하는 결합도(제어요소를 전달(if 등))
5) 스탬프: 모듈 간의 인터페이스로 배열이나 오브젝트, 포인터 등 동일한 동일한 자료 구조가 전달될 때의 결합도
6) 자료: 모듈 간의 인터페이스가 자료 요소로만 구성되는 결합도 func a(x)를 a(10) 으로 호출

15. 응집도(Cohesion): 모듈의 내부 요소들이 서로 연관되어 있는 정도(응집도가 강한 순서, 기순교절시논우)
기능적 응집도(Functional) -> 순차적 응집도(Sequential) -> 교환적 응집도(Communication) -> 절차적 응집도(Procedural) -> 시간적 응집도(Temporal) -> 논리적 응집도(Logical) -> 우연적 응집도(Coincidental)
1) 기능적: 모듈 내부 기능 요소들이 단일 문제와 연관되어 수행
2) 순차적: 모듈 내 하나 활동으로 나온 출력 데이터를 그 다음 활동 입력 데이터로 사용
3) 교환적: 동일한 입력과 출력을 사용해 서로 다른 기능을 수행하는 구성 요소가 모임
4) 절차적: 모듈 안의 구성요소들이 기능을 순차적으로 수행할 경우 응집도
5) 시간적: 특정 시간에 처리하는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
6) 논리적: 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈을 형성
7) 우연적: 서로 관련 없는 요소로 하나의 모듈 구성

### 5. 인터페이스 구현
1. AJAX의 특징
- 비동기 통신, 부분 업데이트, 다양한 데이터 형식 지원, 빠른 응답시간, 서버와 클라이언트 분리

2. 정보보안의 3요소
- 기밀성: 인가된 사용자만 정보 자산에 접근할 수 있다.
- 무결성: 시스템 내 정보는 오직 인가된 사용자가 인가된 방법으로만 수정할 수 있다.
- 가용성: 사용자가 필요할 때 데이터에 접근할 수 있는 능력

3. 시큐어 코딩 가이드: 입력 데이터 검증 및 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용

4. 인터페이스 보안 기능을 적용해야 하는 3영역
- 데이터베이스 영역
- 애플리케이션 영역
- 네트워크 영역

### 6. 화면 설계
1. 기능적 요구사항/비기능적 요구사항
- 기능적: 시스템 입출력으로 포함되어야 할 사항, 동기화 등의 기타 요구사항, 제품을 구현하기 위해 소프트웨어가 가져야 할 기능적 속성
- 비기능적: 품질에 관한 요구사항(사용성, 신뢰성, 이식성, 표준, 윤리적 등), 제품 품질 기준 등의 만족을 위해 소프트웨어가 가져야 할 특성

2. UI의 기본 원칙
- 직관성: 누구나 쉽게 이해하고 사용할 수 있어야 함
- 유효성: 사용자의 목적을 정확하고 완벽하게 달성해야 함
- 학습성: 누구나 쉽게 배우고 익힐 수 있어야 함
- 유연성: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함

3. MUI(Menu User Interface): 메뉴를 기반으로 작업할 수 있는 환경

### 7. 애플리케이션 테스트 관리
1. 소스코드 품질 분석 도구 종류인 정적 분석과 동적 분석 기법
- 정적분석: 프로그램을 실행하지 않고 명세서나 소스코드를 대상으로 분석하는 도구
종류: 워크스루, 인스펙션, 코드 검사
(1) 코드 워크스루: 코드를 작성한 프로그래머가 테스터나 다른 프로그래머한테 형식을 갖춰 발표
(2) 인스펙션: 개발팀에서 작성한 결과물을 분석하여 개발 표준 위배 여부 판단, 잘못 작성된 부분을 수정하는 작업

- 동적분석: 프로그램을 실행하여 메모리 누수 현황, 발생한 스레드 결함 등을 분석하기 위한 도구
종류: 블랙박스 테스트, 화이트박스 테스트

2. 화이트박스 테스트
- 모듈의 원시 코드를 오픈한 상태에서 원시 코드의 모든 문장을 한 번 이상 테스트하여 테스트 케이스를 설계하는 방법
- 종류
(1) 기초 경로 검사(Base Path Test)
(2) 조건검사, 루프검사, 데이터 흐름 검사

3. 블랙박스 테스트
- 소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트로, 기능 테스트라고도 한다.
(1) 동적분할 검사: 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법
(2) 경계값 분석: 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높으므로 입력 조건의 경계값으로 테스트
(3) 원인효과 그래프 검사: 입력 자료 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석 후 효용성이 높은 테스트 케이스를 선정해서 테스트
(4) 오류 예측 검사: 과거 경험이나 테스터의 감각으로 테스트 -> 보충적 검사 기법
(5) 비교 검사: 여러 버전의 프로그램에 동일한 자료를 제공해 동일한 결과가 출력되는지 테스트

4. 개발 단계에 따른 테스트 분류
1) 단위 테스트: 코딩 직후 소프트웨어 설계 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트
2) 통합 테스트: 단위 테스트가 완료된 모듈을 결합하여 하나의 시스템으로 완성시키는 과정의 테스트
3) 시스템 테스트: 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽히 수행되는지 점검하는 테스트
4) 인수 테스트: 개발한 소프트웨어가 사용자의 요구사항을 충족하는지 중점을 두고 테스트 (사용자가 직접 테스트한다.)

5. 통합 테스트 수행 방법 비교
5-1. 상향식
- 모듈: 드라이버
- 방법: 가장 하부의 모듈부터 통합해 가면서 진행
- 수행: 하위 -> 상위
- 장점: 장애 위치 확인 용이, 모든 모듈이 개발 준비되어 있지 않아도 가능
- 단점: 초기 프로토타입 불가, 중요한 모듈들이 마지막에 테스트될 가능성
- 예시: 클라이언트만 구현된 상태, 가상의 서버가 드라이버

5-2. 하향식
- 모듈: 스텁
- 방법: 가장 상부의 모듈부터 통합해 가면서 진행
- 수행: 상위 -> 하위
- 장점: 장애 위치 확인 용이, 초기 프로토타입 가능
- 단점: 많은 스텁 필요, 낮은 수준 모듈은 부적절한 테스트 가능성
- 예시: 서버만 구현된 상태, 가상의 클라가 스텁

6. 테스트 하네스 도구
- 정의: 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트와 모듈이 정상적으로 테스트되도록 하는 도구
- 구성요소
1) 테스트 드라이버: 테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 도구
2) 테스트 스텁: 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈
3) 테스트 슈트: 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스 집합
4) 테스트 스크립트: 자동화된 테스트 실행 절차에 대한 명세서
5) 목(mock) 오브젝트: 사전에 사용자의 행위를 조건부로 정의해두면, 그 상황에 맞는 예정된 행위를 수행하는 객체

7. 애플리케이션 성능 측정 지표 4가지
1) 처리량: 일정 시간 내에 애플리케이션이 처리하는 일의 양 (Throughout)
2) 응답시간: 애플리케이션 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간(Response Time)
3) 경과시간: 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간 (Turn Around Time)
4) 자원 사용률: 애플리케이션이 의뢰한 작업을 처리하는 동안 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률(Resource Time)

8. 소프트웨어 테스트의 산출물 4가지
- 테스트 계획서, 테스트 케이스, 테스트 시나리오, 테스트 결과서

9. 테스트 오라클
- 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법
1) 참 오라클: 모든 입력값에 적합한 결과를 생성하여 발생한 오류를 모두 검출할 수 있는 오라클
2) 일관성 검사 오라클: 애플리케이션 변경이 있을 때, 수행 전과 수행 후의 결과값이 같은지 확인하는 오라클
3) 샘플링 오라클: 일반적인 업무에 사용하는 테스트 오라클로, 특정한 몇 개의 테스트 케이스의 입력값에 대해서만 기대하는 결과를 제공하는 오라클
4) 휴리스틱(추정) 오라클: 임의의 입력값에 대해 올바른 결과를 제공하고, 나머지 값에 대해서는 추정으로 처리하는 오라클 (샘플링 개선방법)

10. 화이트박스 테스트의 검증 기준
- 문장, 분기, 조건, 분기/조건

11. 테스트 시나리오: 여러 테스트 케이스의 집합으로 테스트 케이스의 동작 순서를 정의한 기술문서

12. V-모델: 소프트웨어 개발 단계와 애플리케이션 테스트를 연결한 모델
- 요구사항 -> 분석 -> 설계 -> 구현 -> 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트

13. 소프트웨어 테스트의 원리
1) 결합 검증(파레토 법칙): 결과 80%가 전체 원인 20%에서 발생
2) 살충제 패러독스: 같은 테스트 케이스를 반복하면 결함을 발견할 수 없다.
3) 오류-부재의 궤변: 사용자의 요구사항을 만족하지 못하는 오류를 제거했어도, 해당 애플리케이션의 품질이 높다고 말할 수 없다.

### 8. SQL 응용
1. ALTER: 테이블 컬럼 추가, 컬럼 수정, 컬럼 삭제
ALTER TABLE 테이블명 ADD 컬럼 데이터타입 [제약조건];
ALTER TABLE 테이블명 MODIFY 컬럼 데이터타입 [제약조건];
ALTER TABLE 테이블명 DROP 컬럼명;

2. DROP: 테이블 삭제
DROP TABLE 테이블명 [CASCADE | RESTRICT];
- CASCADE: 참조하는 테이블까지 함께 제거
- RESTRICT: 다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않음

3. TRUNCATE: 테이블 내 데이터 삭제
TRUNCATE TABLE 테이블명;

4. SELECT
SELECT [DISTINCT] 속성명, 속성명
FROM 테이블이름
WHERE 조건
      (BETWEEN A AND B)
      (LIKE 패턴)
      (IS NULL)
GROUP BY 속성명
HAVING 그룹조건
ORDER BY 속성 [ASC | DESC];
* 서브쿼리 : 쿼리 안에 쿼리

5. INSERT (튜플 행 삽입)
INSERT INTO 테이블명 (속성명)
VALUES (데이터);

6. UPDATE (튜플 데이터 수정)
UPDATE 테이블명
SET 속성명 = 데이터
WHERE 조건;

7. DELETE (튜플 삭제)
DELETE FROM 테이블명
WHERE 조건;
ex) DELETE FROM 학생 WHERE 이름 = '민수';

8. 권한 부여/권한 회수
GRANT 권한 ON 테이블 TO 사용자;
REVOKE 권한 ON 테이블 FROM 사용자;

9. JOIN
- INNER JOIN (내부 조인): 양쪽 테이블에 모두 있는 것이 표기
SELECT 열
FROM 테이블 INNER JOIN 두 번째 테이블
ON 조인조건
WHERE 검색조건

- OUTER JOIN(외부 조인): INNER와 달리 '한 쪽에만 데이터가 있어도' 출력
SELECT 열
FROM 테이블
<LEFT|RIGHT|FULL> OUTER JOIN 두 번째 테이블
ON 조인조건
WHERE 검색조건
- LEFT: 왼쪽 테이블의 모든 값이 출력
- RIGHT: 오른쪽 테이블의 모든 값이 출력
- FULL: 왼쪽 또는 오른쪽 모든 값이 출력

- CROSS JOIN(상호 조인): 한 쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인시키는 기능
SELECT *
FROM 첫 번째 테이블
CROSS JOIN 두 번째 테이블;

- SELF JOIN(자체 조인): 자기 자신과 조인함 (1개 테이블 이용)
SELECT *
FROM 테이블 별칭A
INNER JOIN 테이블 별칭B ON 조인조건
WHERE 검색 조건;