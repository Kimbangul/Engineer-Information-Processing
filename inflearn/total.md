###1 요구사항 확인

1. 소프트웨어 재공학 과정

- 분석 -> 구성 -> 역공학 -> 이식

2. XP의 5가지 핵심가치
   (피존의 용기는 단순하게 소통한다)
   피드백, 존중, 용기, 단순성, 소통

- 피드백: 지속적인 테스트와 반복적 결함 수정
- 존중: 모든 프로젝트 관리자는 팀원의 기여 존중
- 용기: 고객 요구사항 변화에 능동적인 대처
- 단순성: 부가적 기능, 사용하지 않는 알고리즘을 배제
- 소통: 개발자, 관리자, 고객 간의 원활한 소통

3. 스크럼마스터

- 업무 배분만 하고 일은 강요하지 않음
- 팀을 스스로 조직하고 관리하도록 지원
- 개발 과정에서 스크럼의 원칙과 가치 지원
- 개발 과정 장애 요소를 찾아 제거

4. 현행 시스템 파악절차 순서

- 1단계: 시스템 구성 파악 -> 시스템 기능 파악 -> 시스템 인터페이스 현황 파악
- 2단계: 아키텍처 파악 -> 소프트웨어 구성 파악
- 3단계: 시스템 하드웨어 현황 파악 -> 네트워크 구성 파악

5. 애플리케이션 개발 단계에서 요구사항을 분석한 뒤, 요구사항을 명세하는 명세 3종류

- 시스템 정의서, 시스템 요구사항 명세서, 소프트웨어 요구사항 명세서

6-1. 구조적 다이어그램 종류 작성

1. 클래스: 시스템을 구성하는 클래스 사이 관계
2. 패키지: 클래스나 유스케이스 등 여러 모델 요소를 그룹화하여 패키지를 구성하고, 그 패키지 사이의 관계를 표현
3. 복합체 구조: 복합 구조의 클래스와 컴포넌트 내부 구조를 표현
4. 객체: 객체 정보를 보여준다. (럼바우 객체지향 분석기법에서 활용됨)
5. 컴포넌트: 컴포넌트 구조 사이의 관계를 표현
6. 배치: 소프트웨어, 하드웨어, 네트워크를 포함한 실행 시스템의 물리 구조를 표현

6-2. 럼바우 객체지향 분석

1. 객체 모델링(Object Modeling)

- 정보 모델링이라고도 하며, 시스템에서 요구하는 객체를 찾고 객체들 간의 관계를 정의. 가장 중요하고 선행되어야 함. 결과물로 객체 다이어그램이 나온다.

2. 동적 모델링(Dynamic Modeling)

- 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현, 결과물로 상태 다이어그램이 나온다.

3. 기능 모델링(Functional Modeling)

- 프로세스들의 자료 흐름을 중심으로 처리 과정을 표현. 결과물로 DFD(자료 흐름도)가 나온다.

7. 행위 다이어그램의 종류

1) 유스케이스: 사용자 관점에서 시스템 행위를 표현
2) 활동: 업무 처리 과정이나 연산이 수행되는 과정을 표현
3) 콜라보레이션: 순차 다이어그램과 같으며, 모델링 공간에 제약이 없어 구조적인 면 중시
4) 상태머신: 객체의 생명주기 표현
5) 순차: 시간 흐름에 따른 객체 사이의 상호작용
6) 통신: 객체 사이의 관계를 중심으로 상호작용 표현
7) 상호작용 개요: 상호작용 다이어그램 사이 제어흐름 표현
8) 타이밍: 객체 상태 변화와 시간 제약을 명시적으로 표현

8. UML에서 표현하는 기본 기능 외 추가적인 기능을 표현하는 것

- 스테레오 타입이라고 부르며 <<>> 로 표기한다.
- 종류: include, extend, interface, exception, constructor

9. 유스케이스 다이어그램 정의와 구성요소

- 정의: 사용자와 다른 외부 시스템이 향후 개발될 시스템을 이용해 수행할 수 있는 기능을 '사용자의 관점' 에서 기술한 것
- 구성요소: 시스템(네모로 표기) / 액터 / 유스케이스(타원형으로 표기) / 관계(화살표)

10. 디자인 패턴

1) 생성패턴: 추상팩토리, 빌더, 팩토리메서드, 프로토타입, 싱글톤 -> 객체를 만들 때 생성
2) 구조패턴: 어댑터, 브릿지, 컴포지트, 데코레이터, 퍼사드, 플라이웨이트, 프록시 -> 구조를 짤 때
3) 행위패턴: 스테이트, 스트레티지(전략), 템플릿메서드, 메멘토, 옵서버, 커맨드, 인터프리터, 책임연쇄, 비지터(visitor), 이터레이터, 미디에이터(중재자) -> 객체들이 어떻게 움직일까

11. 비용산정 모형 분류

1) 하향식 산정방법

- 델파이 기법: 전문가의 경험적 지식을 통한 문제 해결 및 미래예측을 위한 기법

2. 상향식 산정방법
1. LoC(코드 라인수): 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구해 비용 산정
1. COCOMO: 보헴이 제안한 모형으로 프로그램 규모에 따라 비용 산정
1. Man Month: 한 사람이 1개월 간 할 수 있는 일의 양을 기준으로 비용 산정

12) 소프트웨어 아키텍처 4+1뷰

1. 유스케이스 뷰: 아키텍처를 도출하고 설계하는 작업을 주도하는 뷰
2. 논리 뷰: 설계 모델의 추상화, 주요 설계 패키지와 서브 시스템, 클래스 식별 뷰
3. 프로세스 뷰: 성능이나 가용성 같은 비기능적 요구사항을 고려하는 뷰
4. 구현 뷰: 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 표현하는 뷰
5. 배포 뷰: 물리적인 노드의 구성과 상호연결 관계를 배포 다이어그램으로 표현하는 뷰

13) 플랫폼 성능 특성 분석 항목 3가지

- 응답시간, 가용성, 사용률

14. CMMi 5단계

- CMMi: 카네기 멜런 대학의 소프트웨어 공학 전문 연구소의 지침

* 초기단계 -> 관리단계 -> 정의단계 -> 정량적 관리단계 -> 최적화 단계

15. 소프트웨어 아키텍처의 평가 및 설계에 사용되는 다양한 방법론과 기술

- SAAM(Software Architecture Analysis Method)
- ATAM (Architecture Trade-off Analysis Method)
- CBAM (Cost Benefit Analysis Method)
- ADR (Active Design Review)
- ARID (Active Review for Intermediate Designs)

###2. 데이터 입출력 구현

1. 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 스키마의 종류는?

- 외부 스키마: 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
- 개념 스키마: 데이터베이스의 전체적인 논리적 구조, 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재함.
- 내부 스키마: 물리적 저장장치 입장에서 본 데이터베이스 구조, 실제로 저장될 레코드의 형식이나 저장 데이터 항목의 표현방법과 내부 레코드 물리적 순서 등을 나타냄

2. 튜플, 차수, 속성

- 튜플: 릴레이션을 구성하는 각각의 행으로, 튜플의 수를 카디널리티 또는 기수라고 한다. 중복이 허용될 수 있으며 셀 수 있는 수량의 순서 있는 열거이다. (=레코드), (튜플의 수 = 카디널리티)
- 카디널리티: 특정 데이터 집합의 유니크한 값의 개수로, 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표이다.
- 차수: 한 릴레이션에 들어있는 애트리뷰트 수를 차수라고 한다.
- 속성: 하나의 릴레이션은 현실세계의 어떤 개체를 표현하는데, 이 개체에 저장하고 싶은 속성 정보를 뜻한다. (속성의 수 = 디그리 = 차수)
- 릴레이션 인스턴스: 어느 한 시점에서 릴레이션의 내용(상태), 저장된 데이터 전체를 의미한다.

3. 일반 집합 연산자

- 합집합(∪): 두 릴레이션의 튜플의 합집합, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거한다.
- 교집합(∩): 두 릴레이션의 튜플의 교집합
- 차집합(–): 두 릴레이션의 튜플의 차집합
- 교차곱(×): 두 릴레이션의 튜플들의 순서쌍

4. 관계대수와 관계해석

- Select: 선택조건을 만족하는 튜플의 부분집합을 구해서 새로운 릴레이션을 만든다. 행(가로)에 해당하는 튜플을 구하는 것으로 수평연산
  표기형식:σ(조건) (릴레이션이름)
- Project: 속성 리스트에 제시된 속성 값만을 추출해 새로운 릴레이션을 만드는 연산. 열에 해당하는 속성을 추출하므로 수직연산이며 속성만 추출하므로 '중복을 제거함'
  표기형식: π(속성리스트)(릴레이션이름)
- Join: 공통 속성을 중심으로 두 개 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
  표기형식: (릴레이션속성)▷◁(키속성r-릴레이션R의속성)=(키속성s-릴레이션S의속성)S
- Division: 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것으로 수평연산. Division은 X⊂Y(부분집합)인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
  표기형식: R[속성r ÷ 속성a]S

5. 관계형 데이터베이스의 제약조건

- 개체 무결성: 기본 테이블의 기본키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다.
- 참조무결성: 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉, 릴레이션은 참조할 수 없는 외래키값을 가질 수 없다는 규정
- 도메인무결성: 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
- 사용자정의무결성: 속성 값들이 사용자가 정의한 제약조건에 만족되어야 한다는 규정
- NULL 무결성: 릴레이션의 특정 속성 값이 Null이 될 수 없도록 하는 규정
- 관계 무결성: 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 릴레이션과 다른 릴레이션의 튜플들 사이에 관계의 적정성 여부를 지정한 규정

* 도메인이란? : 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자들의 집합(예: 성별 애트리뷰트의 도메인은 "남"과 "여" 이다.)

6. 정규형의 과정 설명(도부이결다조)

1) 도메인이 원자값(비정규 -> 1정규형)
2) 부분적 함수 종속 제거 (1정규형 -> 2정규형)
3) 이행적 함수 종속 제거 (2정규형 -> 3정규형)
4) 결정자이면서 후보키가 아닌 것 제거 (3정규형 -> BCNF정규형)
5) 다치 종속 제거 (BCNF정규형 -> 4정규형)
6) 조인 종속성 이용 (4정규형 -> 5정규형)

6. 반정규화

- 정의: 시스템의 성능을 향상하고 개발 및 운영의 편의성을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위
- 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만, 데이터의 일관성 및 정합성이 저하될 수 있다.
- 방법: 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가

7. 시스템 카탈로그

- 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
- 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다.
- 카탈로그들이 생성되면 데이터 사전에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 사전이라고도 한다.

8. 트랜잭션의 특성

- 원자성(Atomicity): 트랜잭션의 연산은 데이터베이스에 모두 반영되거나 전혀 반영되지 않아야 한다. (Commit, Rollback)의 성질
- 일관성(Consistency): 트랜잭션이 그 실행을 성공적으로 완료하면, 언제나 일관성 있는 데이터베이스 상태로 변환된다.
- 독립성, 격리성(Isolation): 둘 이상의 트랜잭션이 동시에 병행되어 실행되는 경우 어느 하나의 트랜잭션 실행 중에는 다른 트랜잭션의 연산이 끼어 들 수 없다.
- 지속성, 영속성(Durability): 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장 나더라도 영구적으로 반영되어야 한다.

7. 접근 통제 기술

- 임의 접근통제(DAC): 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여
- 강제 접근통제(MAC): 주체와 객체 등급을 비교하여 접근 권한을 부여
- 역할기반 접근통제(RBAC): 사용자의 역할에 따라 접근 권한을 부여

8. 파티션의 정의와 종류

- 정의: 데이터베이스에서 파티션은 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 말한다.
  (1) 범위 분할: 지정한 열의 기준으로 분할함
  (2) 해시 분할: 해시 함수를 적용한 결과값에 따라 데이터를 분할함
  (3) 조합 분할: 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식

9. 분산 데이터베이스의 목표

- 위치 투명성: 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스 할 수 있다.
- 중복 투명성: 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행한다.
- 병행 투명성: 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.
- 장애 투명성: 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리한다.

10. 클러스터

- 데이터 저장시 데이터 액세스의 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적인 방법

11. 데이터 모델 구성 3요소

- 구조: 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질을 표현
- 연산: 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로 데이터베이스를 조작하는 도구
- 제약조건: 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

12. 함수적 종속성(Functional Dependency)

- 속성 Y가 속성 X에 함수적으로 종속된다는 말은 속성 X를 이용하여 속성 Y를 식별할 수 있다는 말이다.
- 완전 함수종속
- 부분 함수종속

13. SQL DDL, DML, DCL 종류

- DDL: CREATE, ALTER, DROP, RENAME, TRUNCATE
- DML: SELECT, INSERT, UPDATE, DELETE
- DCL: GRANT, REVOKE
- TCL: COMMIT, ROLLBACK, SAVEPOINT

학생 테이블에 대한 권한 부여:
GRANT SELECT, INSERT ON student TO kim, lee;

학생 테이블에 대한 권한 회수:
REVOKE SELECT, INSERT ON student from lee;

### 3. 통합 구현

1. 웹 서비스는 네트워크에 분산된 정보를 서비스 형태로 개방하여 표준화된 방식으로 공유하는 기술로 서비스 지향 아키텍처 개념을 실현하는 대표적 (SOA)기술이다.

- UDDI: 웹 서비스에 대한 정보인 WSDL을 등록하고 검색하기 위한 저장소로, 공개적으로 접근/검색이 가능한 레지스트리
- WSDL: 웹 서비스명, 제공 위치, 메세지 포맷, 프로토콜 정보 등 웹 서비스에 대한 상세 정보가 기술된 XML로 구현되어 있는 언어
- SOAP: HTTP, HTTPS, SMTP 등을 이용하여 XML 기반의 메세지를 네트워크 상태에서 교환하는 프로토콜

2. 연계(인터페이스) 구성

- 송신 시스템, 중계 시스템, 수신 시스템

3. 연계 테스트 진행 순서

- 연계 케이스 작성 -> 연계 테스트 환경 구축 -> 연계 테스트 수행 -> 연계 테스트 수행 결과 검증

4. 연계 방식 종류 - 직접 연계

- DB Link: 한 데이터베이스에서 네트워크상의 다른 데이터베이스에 접속하기 위한 설정을 해 주는 오라클 객체
- DB Connection Pool: 수신 시스템 WAS에서 송신 시스템 DB로 연결되는 Connection Pool을 생성하고 프로그램 소스에서 WAS에 설정된 Connection Pool명을 참고하여 구현한다.
- JDBC: 수신 시스템의 Batch, Online 프로그램에서 JDBC 드라이버를 이용하여 송신 시스템의 DB와 연결을 생성한다.
- 화면 링크: 웹 애플리케이션 화면에서 하이퍼링크를 사용한다. (ex: a태그)
- API / Open API: 송신시스템의 DB와 연결하여 데이터를 제공하는 인터페이스 프로그램

5. 연계 방식 종류 - 간접 연계

- EAI: 실제 송수신 처리와 진행 현황을 모니터링 및 통제하는 EAI 서버, 송수신 시스템에 설치되는 어댑터 (Client)를 말한다. 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해 주는 솔루션
- 구축유형: Point to Point, Hub & Spoke, Message Bus, Hybrid
  (1) Point-to-Point: 중간에 미들웨어를 두지 않고 각 애플리케이션 간 Point to Point 형태 연결
  (2) Hub & Spoke: 단일 접점이 허브 시스템을 통해 데이터를 전송하는 중앙 집중적 방식
  (3) Message Bus: 애플리케이션 사이 미들웨어를 두어서 처리하는 방식
  (4) Hybrid: (2), (3) 혼합방식으로 데이터 병목현상을 최소화하는 방식
- Web Service/ESB: 웹 서비스가 설명된 WSDL과 SOAP 프로토콜을 이용한 시스템을 연계한다. 미들웨어인 ESB에서 서비스 간 연동을 위한 변환 처리로 다중 플랫폼을 지원한다.
- Socket: 소켓을 생성하여 포트를 할당하고, 클라이언트의 요청을 연결하여 통신하는 네트워크 프로그램의 기반 기술이다.

6. 객체지향 설계원칙 (설계 5대 원칙)
   (1) 단일 책임 원칙 (Single Responsibility Principle): 모든 클래스는 각각 하나의 책임만 가져야 한다.
   클래스는 그 책임을 완전히 캡슐화해야 한다.
   ex) 계산 클래스는 오직 사칙연산 기능만 책임진다.

(2) 개방/폐쇄 원칙(Open Closed Principle)
확장에는 열려 있고, 수정에는 닫혀있어야 한다.
기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
ex) 캐릭터를 설계할 때 각각의 캐릭터가 움직임이 다른 경우, 하위 클래스에게 움직임을 구현 위임

(3) 리스코프 치환 원칙 (Liskov Subsititution Principle)
자식 클래스는 언제나 부모의 클래스를 대체할 수 있다.

(4) 인터페이스 분리 원칙 (Interface Separation Principle)
한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.

(5) 의존 역전 원칙 (Dependency Inversion Principle)
의존 관계를 맺을 때 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺을 것

### 4. 서버 프로그램 구현

1. 개발 언어의 선정 기준 5가지

- 적정성, 효율성, 이식성, 친밀성, 범용성

2. 소프트웨어 아키텍처의 설계 과정

- 설계 목표 설정 -> 시스템 타입 설정 -> 아키텍처 패턴 적용 -> 서브 시스템 구체화 -> 검토

3. 아키텍처 패턴
   (1) 레이어 패턴: 시스템을 계층으로 구분하여 구성하는 고전적인 방법의 패턴
   (2) 클라이언트 - 서버: 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
   (3) 파이프-필터 패턴: 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴
   (4) 모델-뷰-컨트롤러 패턴: 서브 시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴
   (5) 기타: 마스터-슬레이브 패턴, 브로커 패턴, 피어-투-피어 패턴, 이벤트-버스 패턴, 블랙보드 패턴

4. 객체 지향 분석의 방법론

- 럼바우 방법: 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법 (객체모델링, 동적모델링, 기능모델링 순으로 이뤄진다.)
- 부치 방법: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용함
- 자콥스 방법: 유스케이스를 강조하여 사용
- Coad와 Youdon 방법: E-R 다이어그램을 사용하여 객체의 행위를 모델링함
- Wirfs-Brock 방법: 분석과 설계 간의 구분이 없으며 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행한다.

6. 객체지향 설계원칙 5가지

- 단일 책임 원칙: 객체는 단 하나의 책임만 가져야 한다.
- 개방-폐쇄 원칙: 기존의 코드를 변경하지 않고, 기능을 추가할 수 있도록 설계해야 한다.
- 리스코프 치환 원칙: 자식 클래스는 최소한 부모 클래스의 기능을 수행할 수 있어야 한다.
- 인터페이스 분리 원칙: 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다.
- 의존 역전 원칙: 의존 관계 성립시, 추상성이 높은 클래스와 의존 관계를 맺어야 한다.

7. 소프트웨어 아키텍처 설계 기본 원리

- 모듈화: 소프트웨어 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것
- 추상화: 문제의 전체적이고 포괄적인 개념을 설계한 후, 차례로 세분화하여 구체화시켜 나가는 것
- 단계적 분해: 문제를 상위의 중요 개념으로부터 하위의 중요 개념으로 구체화시키는 분할 기법
- 정보 은닉: 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

8. 모듈의 독립성은 결합도와 응집도에 의해서 측정된다.

- 모듈의 독립성을 높이기 위해서는 결합도는 약하게, 응집도는 높게 해야 한다.

9. IPC: 모듈 간 통신 방식을 구현하기 위한 대표적인 프로그래밍 인터페이스 집합

- Inter-Process Communication: 프로세스 간 통신
- Shared memory: 공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식
- Socket: 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스 간에 통신하는 방식
- Semaphores: 공유 자원에 대한 접근 제어를 통해 통신하는 방식
- Pipes & Named Pipes: "Pipe"라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식
- Message Queueing: 메세지가 발생하면 이를 전달하는 방식으로 통신하는 방식

10. 서버 개발 과정은 DTO/VO, SQL, DAO, Service, Controller를 각각 구현하는 과정이다.

- DTO/VO 구현: 데이터 교환을 위해 사용할 객체 만드는 과정
- SQL 구현: 데이터 삽입/변경/삭제 등의 작업을 수행할 SQL문을 생성하는 과정
- DAO 구현: 데이터베이스에 접근하고, SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정
- Service 구현: 사용자의 요청에 응답하기 위한 로직을 구현하는 과정
- Controller 구현: 사용자의 요청에 적절한 서비스를 호출하여 그 결과를 사용자에게 반환하는 코드를 구현하는 과정

11. 소프트웨어 재사용을 위한 공통 모듈화

1) 분할과 정복 (Divide & Conquer): 복잡한 문제를 분해해서 모듈 단위로 해결
2) 자료추상화: 함수 내의 자료 구조, 표현 내역을 숨기고 인터페이스를 통해 접근
3) 모듈 독립성: 각 모듈의 결합도를 줄이고 응집도를 높인다.
4) 정보 은닉: 중요한 정보나 노출 가능성이 큰 모듈을 은닉한다.
5) 비용과 모듈: 모듈 수가 많아지면, 비용도 증가한다

12. MVC 패턴

- Model-View-Controller 의 줄임말고, 애플리케이션을 세 가지 주요 구성 요소인 모델(Model), 뷰(View), 컨트롤러(Controller)로 분리하여 개발의 효율성과 유지보수성을 높인다
- Model: 데이터와 비즈니스 로직을 담당. 데이터를 관리하고 비즈니스 핵심 로직을 처리하고, 데이터를 가공하며 애플리케이션의 상태를 유지
- View: 사용자 인터페이스 담당. 데이터 표시나 버튼, 텍스트 필드 등을 포함
- Controller: 사용자의 입력을 처리하고 모델을 업데이트하며 뷰를 업데이트함. 모델과 뷰 사이에서 연결하는 역할

13. 배치 프로그램: 일정 스케줄마다 돌아가면서 일괄 처리하는 프로그램

14. 결합도(Coupling): 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관관계 (결합도가 강한 순서: 내공외제스자)
    내용 결합도(Content) -> 공통 결합도(Common) -> 외부 결합도(External) -> 제어 결합도(Control) -> 스탬프 결합도(Stamp) -> 자료 결합도(Data)

1) 내용: 한 모듈이 다른 모듈의 내부 기능 및 내부 자료를 직접 참조하거나 수정
2) 공통: 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도(전역변수 쓸 때)
3) 외부: 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때 결합도
4) 제어: 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어요소(flag)를 전달하는 결합도(제어요소를 전달(if 등))
5) 스탬프: 모듈 간의 인터페이스로 배열이나 오브젝트, 포인터 등 동일한 동일한 자료 구조가 전달될 때의 결합도
6) 자료: 모듈 간의 인터페이스가 자료 요소로만 구성되는 결합도 func a(x)를 a(10) 으로 호출

15. 응집도(Cohesion): 모듈의 내부 요소들이 서로 연관되어 있는 정도(응집도가 강한 순서, 기순교절시논우)
    기능적 응집도(Functional) -> 순차적 응집도(Sequential) -> 교환적 응집도(Communication) -> 절차적 응집도(Procedural) -> 시간적 응집도(Temporal) -> 논리적 응집도(Logical) -> 우연적 응집도(Coincidental)

1) 기능적: 모듈 내부 기능 요소들이 단일 문제와 연관되어 수행
2) 순차적: 모듈 내 하나 활동으로 나온 출력 데이터를 그 다음 활동 입력 데이터로 사용
3) 교환적: 동일한 입력과 출력을 사용해 서로 다른 기능을 수행하는 구성 요소가 모임
4) 절차적: 모듈 안의 구성요소들이 기능을 순차적으로 수행할 경우 응집도
5) 시간적: 특정 시간에 처리하는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
6) 논리적: 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈을 형성
7) 우연적: 서로 관련 없는 요소로 하나의 모듈 구성

### 5. 인터페이스 구현

1. AJAX의 특징

- 비동기 통신, 부분 업데이트, 다양한 데이터 형식 지원, 빠른 응답시간, 서버와 클라이언트 분리

2. 정보보안의 3요소

- 기밀성: 인가된 사용자만 정보 자산에 접근할 수 있다.
- 무결성: 시스템 내 정보는 오직 인가된 사용자가 인가된 방법으로만 수정할 수 있다.
- 가용성: 사용자가 필요할 때 데이터에 접근할 수 있는 능력

3. 시큐어 코딩 가이드: 입력 데이터 검증 및 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용

4. 인터페이스 보안 기능을 적용해야 하는 3영역

- 데이터베이스 영역
- 애플리케이션 영역
- 네트워크 영역

### 6. 화면 설계

1. 기능적 요구사항/비기능적 요구사항

- 기능적: 시스템 입출력으로 포함되어야 할 사항, 동기화 등의 기타 요구사항, 제품을 구현하기 위해 소프트웨어가 가져야 할 기능적 속성
- 비기능적: 품질에 관한 요구사항(사용성, 신뢰성, 이식성, 표준, 윤리적 등), 제품 품질 기준 등의 만족을 위해 소프트웨어가 가져야 할 특성

2. UI의 기본 원칙

- 직관성: 누구나 쉽게 이해하고 사용할 수 있어야 함
- 유효성: 사용자의 목적을 정확하고 완벽하게 달성해야 함
- 학습성: 누구나 쉽게 배우고 익힐 수 있어야 함
- 유연성: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함

3. MUI(Menu User Interface): 메뉴를 기반으로 작업할 수 있는 환경

### 7. 애플리케이션 테스트 관리

1. 소스코드 품질 분석 도구 종류인 정적 분석과 동적 분석 기법

- 정적분석: 프로그램을 실행하지 않고 명세서나 소스코드를 대상으로 분석하는 도구
  종류: 워크스루, 인스펙션, 코드 검사
  (1) 코드 워크스루: 코드를 작성한 프로그래머가 테스터나 다른 프로그래머한테 형식을 갖춰 발표
  (2) 인스펙션: 개발팀에서 작성한 결과물을 분석하여 개발 표준 위배 여부 판단, 잘못 작성된 부분을 수정하는 작업

- 동적분석: 프로그램을 실행하여 메모리 누수 현황, 발생한 스레드 결함 등을 분석하기 위한 도구
  종류: 블랙박스 테스트, 화이트박스 테스트

2. 화이트박스 테스트

- 모듈의 원시 코드를 오픈한 상태에서 원시 코드의 모든 문장을 한 번 이상 테스트하여 테스트 케이스를 설계하는 방법
- 종류
  (1) 기초 경로 검사(Base Path Test)
  (2) 조건검사, 루프검사, 데이터 흐름 검사

3. 블랙박스 테스트

- 소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 완전히 작동되는 것을 입증하는 테스트로, 기능 테스트라고도 한다.
  (1) 동적분할 검사: 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법
  (2) 경계값 분석: 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높으므로 입력 조건의 경계값으로 테스트
  (3) 원인효과 그래프 검사: 입력 자료 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석 후 효용성이 높은 테스트 케이스를 선정해서 테스트
  (4) 오류 예측 검사: 과거 경험이나 테스터의 감각으로 테스트 -> 보충적 검사 기법
  (5) 비교 검사: 여러 버전의 프로그램에 동일한 자료를 제공해 동일한 결과가 출력되는지 테스트

4. 개발 단계에 따른 테스트 분류

1) 단위 테스트: 코딩 직후 소프트웨어 설계 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트
2) 통합 테스트: 단위 테스트가 완료된 모듈을 결합하여 하나의 시스템으로 완성시키는 과정의 테스트
3) 시스템 테스트: 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽히 수행되는지 점검하는 테스트
4) 인수 테스트: 개발한 소프트웨어가 사용자의 요구사항을 충족하는지 중점을 두고 테스트 (사용자가 직접 테스트한다.)

5. 통합 테스트 수행 방법 비교
   5-1. 상향식

- 모듈: 드라이버
- 방법: 가장 하부의 모듈부터 통합해 가면서 진행
- 수행: 하위 -> 상위
- 장점: 장애 위치 확인 용이, 모든 모듈이 개발 준비되어 있지 않아도 가능
- 단점: 초기 프로토타입 불가, 중요한 모듈들이 마지막에 테스트될 가능성
- 예시: 클라이언트만 구현된 상태, 가상의 서버가 드라이버

5-2. 하향식

- 모듈: 스텁
- 방법: 가장 상부의 모듈부터 통합해 가면서 진행
- 수행: 상위 -> 하위
- 장점: 장애 위치 확인 용이, 초기 프로토타입 가능
- 단점: 많은 스텁 필요, 낮은 수준 모듈은 부적절한 테스트 가능성
- 예시: 서버만 구현된 상태, 가상의 클라가 스텁

6. 테스트 하네스 도구

- 정의: 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트와 모듈이 정상적으로 테스트되도록 하는 도구
- 구성요소

1. 테스트 드라이버: 테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 도구
2. 테스트 스텁: 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈
3. 테스트 슈트: 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스 집합
4. 테스트 스크립트: 자동화된 테스트 실행 절차에 대한 명세서
5. 목(mock) 오브젝트: 사전에 사용자의 행위를 조건부로 정의해두면, 그 상황에 맞는 예정된 행위를 수행하는 객체

7) 애플리케이션 성능 측정 지표 4가지

1. 처리량: 일정 시간 내에 애플리케이션이 처리하는 일의 양 (Throughout)
2. 응답시간: 애플리케이션 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간(Response Time)
3. 경과시간: 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간 (Turn Around Time)
4. 자원 사용률: 애플리케이션이 의뢰한 작업을 처리하는 동안 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률(Resource Time)

8) 소프트웨어 테스트의 산출물 4가지

- 테스트 계획서, 테스트 케이스, 테스트 시나리오, 테스트 결과서

9. 테스트 오라클

- 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법

1. 참 오라클: 모든 입력값에 적합한 결과를 생성하여 발생한 오류를 모두 검출할 수 있는 오라클
2. 일관성 검사 오라클: 애플리케이션 변경이 있을 때, 수행 전과 수행 후의 결과값이 같은지 확인하는 오라클
3. 샘플링 오라클: 일반적인 업무에 사용하는 테스트 오라클로, 특정한 몇 개의 테스트 케이스의 입력값에 대해서만 기대하는 결과를 제공하는 오라클
4. 휴리스틱(추정) 오라클: 임의의 입력값에 대해 올바른 결과를 제공하고, 나머지 값에 대해서는 추정으로 처리하는 오라클 (샘플링 개선방법)

10) 화이트박스 테스트의 검증 기준

- 문장, 분기, 조건, 분기/조건

11. 테스트 시나리오: 여러 테스트 케이스의 집합으로 테스트 케이스의 동작 순서를 정의한 기술문서

12. V-모델: 소프트웨어 개발 단계와 애플리케이션 테스트를 연결한 모델

- 요구사항 -> 분석 -> 설계 -> 구현 -> 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트

13. 소프트웨어 테스트의 원리

1) 결합 검증(파레토 법칙): 결과 80%가 전체 원인 20%에서 발생
2) 살충제 패러독스: 같은 테스트 케이스를 반복하면 결함을 발견할 수 없다.
3) 오류-부재의 궤변: 사용자의 요구사항을 만족하지 못하는 오류를 제거했어도, 해당 애플리케이션의 품질이 높다고 말할 수 없다.

### 8. SQL 응용

1. ALTER: 테이블 컬럼 추가, 컬럼 수정, 컬럼 삭제
   ALTER TABLE 테이블명 ADD 컬럼 데이터타입 [제약조건];
   ALTER TABLE 테이블명 MODIFY 컬럼 데이터타입 [제약조건];
   ALTER TABLE 테이블명 DROP 컬럼명;

2. DROP: 테이블 삭제
   DROP TABLE 테이블명 [CASCADE | RESTRICT];

- CASCADE: 참조하는 테이블까지 함께 제거
- RESTRICT: 다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않음

3. TRUNCATE: 테이블 내 데이터 삭제
   TRUNCATE TABLE 테이블명;

4. SELECT
   SELECT [DISTINCT] 속성명, 속성명
   FROM 테이블이름
   WHERE 조건
   (BETWEEN A AND B)
   (LIKE 패턴)
   (IS NULL)
   GROUP BY 속성명
   HAVING 그룹조건
   ORDER BY 속성 [ASC | DESC];

- 서브쿼리 : 쿼리 안에 쿼리

5. INSERT (튜플 행 삽입)
   INSERT INTO 테이블명 (속성명)
   VALUES (데이터);

6. UPDATE (튜플 데이터 수정)
   UPDATE 테이블명
   SET 속성명 = 데이터
   WHERE 조건;

7. DELETE (튜플 삭제)
   DELETE FROM 테이블명
   WHERE 조건;
   ex) DELETE FROM 학생 WHERE 이름 = '민수';

8. 권한 부여/권한 회수
   GRANT 권한 ON 테이블 TO 사용자;
   REVOKE 권한 ON 테이블 FROM 사용자;

9. JOIN

- INNER JOIN (내부 조인): 양쪽 테이블에 모두 있는 것이 표기
  SELECT 열
  FROM 테이블 INNER JOIN 두 번째 테이블
  ON 조인조건
  WHERE 검색조건

- OUTER JOIN(외부 조인): INNER와 달리 '한 쪽에만 데이터가 있어도' 출력
  SELECT 열
  FROM 테이블
  <LEFT|RIGHT|FULL> OUTER JOIN 두 번째 테이블
  ON 조인조건
  WHERE 검색조건
- LEFT: 왼쪽 테이블의 모든 값이 출력
- RIGHT: 오른쪽 테이블의 모든 값이 출력
- FULL: 왼쪽 또는 오른쪽 모든 값이 출력

- CROSS JOIN(상호 조인): 한 쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인시키는 기능
  SELECT \*
  FROM 첫 번째 테이블
  CROSS JOIN 두 번째 테이블;

- SELF JOIN(자체 조인): 자기 자신과 조인함 (1개 테이블 이용)
  SELECT \*
  FROM 테이블 별칭A
  INNER JOIN 테이블 별칭B ON 조인조건
  WHERE 검색 조건;

### 9. 소프트웨어 보안 구축

1. 소프트웨어 개발 보안 요소

- 기밀성: 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용됨
- 무결성: 시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있음
- 인증: 시스템 내 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지 확인하는 행위
- 부인 방지: 데이터 송수신한 자가 송수신 사실을 부인할 수 없도록 송수신 증거를 제공

2. 암호 알고리즘의 종류
   2-1. 암호화 방식에 따른 분류
   (1) 스트림 암호화 기법(LFSR, RC4)
   (2) 블록 암호화 방식(DES, SEED, AES, ARIA)

2-2. 공개키 암호화
공개키는 사용자에게 공개하고, 복호화할 때 비밀키는 관리자가 비밀리에 관리. 대표적으로 RSA 기법이 있음

2-3. 방향에 따른 알고리즘
(1) 단방향: HASH 알고리즘

- SHA 시리즈: 93년 NSA가 설계하고 NIST에 의해 발표됨
  SHA-1: NSA에서 미 정부 표준 지정
- MD5: 91년 R.Rivest가 MD4를 대체하기 위해 고안한 암호화 해시함수 (블록크기 512비트, 키는 128비트)
- N-NASH: 89년 일본의 NTT에서 발표한 암호화 해시함수, 블록/키가 모두 128비트
- SNEFRU: 90년 R.C.Merkle가 발표한 해시 함수, 32비트 프로세스에서 구현을 용이하게 할 목적으로 개발됨

(2) 양방향

- SEED: KISA가 개발한 블록 암호화 알고리즘. 블록 크기는 128비트이며 키에 따라 128, 256으로 분류
- ARIA: 04년 국가정보원과 산학연합회가 개발한 블록 암호화 알고리즘
- DES: 1975년 NBS에서 발표한 개인키 암호화 알고리즘, DES를 3번 적용한 3DES도 있음
- AES: 01년 NIST에서 발표한 개인키 암호화 알고리즘, DES의 한계를 느낀 NIST에서 공모 후 발표
- RSA: 1978년 MIT의 라이베스트, 샤미르, 애들먼에 의해 제안된 공개키 암호화 알고리즘. 큰 숫자를 소인수분해하기 어렵다는 것에 기반하여 제작됨

3. 보안 솔루션

- VPN (Virtual Private Network): 인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용 회선을 사용하는 것처럼 해주는 보안 솔루션
- NAC (Network Access Control): 네트워크에 접속하는 내부 PC의 MAC 주소를 IP 관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션
- ESM (Enterprise Security Management): 방화벽, 침입 탐지 시스템, 가상 사설망 등 보안 솔루션을 하나로 모은 통합 보안 관리 시스템

4. 서비스 공격 유형

- Ping of Death: Ping 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비시키는 서비스 거부 공격 방법
- SMURFING(스머핑): IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법
  해결: 각 네트워크 라우터에서 브로드캐스트 주소를 사용할 수 없게 미리 설정해놓음
- SYN Flooding: TCP의 3-Way-Handshake 과정을 의도적으로 중단시켜 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법
  해결: SYN Flooding에 대비하여 'SYN' 수신 대기 시간을 줄이거나 침입 차단 시스템 도입
- TearDrop: 데이터 송수신 과정에서 패킷의 크기가 클 때 분할순서를 알기위해 Fragment Offset을 함께 보내는데 이 값을 변경시켜 패킷을 재조립할 때 오류로 인한 과부하를 발생시켜 시스템이 다운되는 공격
  해결: Fragment Offset이 잘못되면 해당 패킷 폐기
- LAND Attack: 패킷 전송 시 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 공격대상에게 전송하는 것으로, 이 패킷을 받는 공격 대상은 자기 자신에 대해 무한히 응답한다.
  해결: 송/수신 IP 주소의 적절성을 검사
- UDP Flooding: 대의 UDP 패킷을 이용하여 대상 호스트의 네트워크 자원을 소모시키는 공격
- Ping flooding: 대상 시스템에 ICMP 패킷을 계속해서 보내서 시스템이 요청에 응답하느라 다른 일을 못하도록 하는 공격
- DDoS 공격: 여러 곳 분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행
  해결법: 대역폭 용량과 서버용량 증설, 비정상 트래픽 파악, 방화벽 배포 등
- 피싱(Phising): 진짜 웹 사이트와 거의 동일하게 꾸며진 가짜 웹사이트를 통해 개인정보를 탈취
- 파밍(Pharming): 도메인을 탈취하거나, 악성코드를 통해 DNS의 이름을 속여 진짜 웹사이트로 오인하게 만들어 개인정보 탈취
- 스미싱(Smishing): 네트워크상에서 다른 상대방들의 패킷 교환을 엿들음
- 큐싱(Qshing): 사용자 인증 등이 필요한 것처럼 속여 QR코드를 통해 악성 앱을 내려받게 함
- 랜섬웨어: 인터넷 사용자의 컴퓨터에 침입해 내부 문서 파일 등 암호화해 사용자가 열지 못하게 하는 방법
- 키 로거: 컴퓨터 사용자의 키보드 움직임을 탐지해 개인정보를 몰래 빼감
- XSS: 게시판의 글에 원본과 함께 악성코드를 삽입하여 글을 읽으면 악성코드를 실행하여 클라이언트 공격
- 제로데이 공격 (Zero-Day Attack): 조사된 정보를 바탕으로 정보 시스템, 웹 애플리케이션 등의 알려지지 않은 취약점 및 보안 시스템에서 탐지되지 않는 악성코드를 감염시킴
- 무작위 대입 공격(Brute-force): 패스워드에 사용될만한 문자열의 범위를 정하고, 그 범위 내에서 생성 가능한 패스워드를 활용하는 공격 방법
- APT 공격: 특정 타깃을 목표로 하여 다양한 수단을 통한 지속적이고 지능적인 맞춤형 공격 기법으로 특수목적의 조직이 하나의 표적에 대해 다양한 IT 기술을 이용하여, 지속적으로 정보를 수집하고, 취약점을 분석하여 피해를 주는 공격 기법
- 스피어 피싱: 일반적인 이메일로 위장한 메일을 지속적으로 발송하여 링크나 첨부된 파일을 클릭하게 유도한 후 개인정보 탈취
- 백도어: 프로그램이나 손상된 시스템에 허가되지 않은 접근을 할 수 있도록 정상적인 보안 절차를 우회하는 악성 소프트웨어
- Rainbow Table Attack: 패스워드 크래킹 기법으로, 패스워드 별로 해시값을 미리 생성해놓은 테이블을 사용하여 Reduction 함수의 반복 수행을 통해 일치하는 해시값으로 패스워드 탈취
- CSRF: 불특정 다수를 대상으로 로그인된 사용자가 자신의 의지와 상관없이 공격자의 의도에 따라 행위를 하게 하는 공격
- TOCTOU: 병렬 시스템을 사용할 때 두 시점 사이의 타이밍을 노리는 공격 또는 그런 공격을 가능하게 하는 버그 유형
- 웜(Worm): 감염된 컴퓨터에서 자가 복제해 다른 컴퓨터로 복사본을 확산시키는 악성 프로그램
- 트로이 목마: 정상적인 프로그램으로 가장하여 사용자가 직접 설치하게 유도 후에 백도어를 만들어 공격자가 침입하게 만드는 악성 프로그램. 감염된 이후에 스스로 복제하는 능력은 없지만 시스템 내부 정보를 공격자의 컴퓨터로 빼돌리게 한다.

4. 보안 솔루션 유형

- 방화벽: 내부 보안 정책을 만족하는 트래픽만에 방화벽을 통과할 수 있다.
- 웹 방화벽: 클라이언트가 보낸 요청을 검사하여 악의적인 요청과 침입을 검사하고 차단함
- IDS(Intrusion Detection System): 침입 공격에 대하여 외부 침입을 탐지하는 것을 목표로 하는 보안 솔루션
- IPS(Intrusion Prevention System): 침입 공격에 대하여 방지하는 것을 목표로 하는 보안 솔루션, 침입을 탐지하면 이에 대한 대처까지 수행.
- DMZ: 보안 조치가 취해진 네트워크 영역
- NAC (Network Access Control): 사용자 컴퓨터 및 네트워크 단말기가 네트워크에 접근하기 전에 보안 정책 준수 여부를 검사하여 네트워크 접근을 통제하는 보안 솔루션
- DLP (Data Loss Prevention): 기업 데이터 유출을 방지하는 것을 목표로 하는 보안 솔루션
- ESM (Enterprise Security Management): 방화벽, 침입 탐지 시스템, 가상 사설망 등 보안 솔루션을 하나로 모은 통합 보안 관리 시스템
- VPN(Virtual Private Network): 안전하지 않은 공용 네트워크를 이용하여 사설 네트워크를 구성하는 기술

5. 서버인증-사용자 인증 기법

- 지식 기반 인증: 사용자가 기억하는 지식(ID/PW)
- 소유 기반 인증: 소지하고 있는 물품, 공인인증서
- 생체 기반 인증: 사용자의 고유한 생체 정보 이용

6. 서버 접근 통제

- DAC(임의 접근 통제): 정보 소유자가 보안 레벨을 결정하고 이에 대한 접근제어를 설정하는 방식
- MAC(강제적 접근 통제): 중앙에서 정보를 수집하고 분류하여 보안 레벨을 결정하고 정책적으로 접근제어를 수행
- RBAC(역할 기반 접근 통제): 사람이 아닌 직책에 대해 권한을 부여하여 효율적인 권한 관리

### 10. 프로그래밍 언어 활용

1. 프로그래밍별 참/거짓값
   1-1. C
   printf("%d", 5<3); -> 0
   printf("%d", 5>3); -> 1

1-2. Java
System.out.println(5<3); -> false
System.out.println(5>3); -> true

1-3. Python
print(5<3); -> False
print(5>3); -> True

2. C언어 이중포인터: 포인터의 개념에 다시 포인터

- 포인터는 접근했을 때 그 주소가 가지고 있는 값을 반환하게 되어 있는데, 그것을 다시 포인터로 활용하면 그 값이 다시 주소로 활용되는 것

```c
#include <stdio.h>
int main() {
 int *array[3];
 int a = 12, b = 24, c = 36;
 array[0] = &a;
 array[1] = &b;
 array[2] = &c;
 printf(“%d”, *array[1] + **array+1);
```

// 24(1번 인덱스) + 12(배열의 첫 요소의 값) + 1 = 37
// 주소의 이름은 array[0]의 주소를 의미한다.
// array[0]의 주소의 값은 a의 메모리 주소이며, 그 값을 출력하는 것이 아니라 그 값을 다시 주소로 찾아간 이후에 그 내부의 값을 가져옴


3. 관계 연산자/비트연산자
```java
public static void main(String[] args) {
 int w=3, x=4, y=3, z=5;

 if((w == 2 | w == y & !(y > z)&(1 == x^y != z)) {
      w = x + y;

      if(7 == x^y!= w) {
            System.out.println(w);
      } else {
            System.out.println(x);
      }
} else {
      w = y + z;

      if(7 == y^z != w){
          System.out.println(w);
      } else {
          System.out.println(z);
      }
}
```
* 우선순위: 괄호 > 관계 > 비트
w 값은 7

4. Java언어 관련 용어
- instance 변수: 객체마다 다른 메모리 공간
- static 변수: 클래스 변수, 공유 변수라 부르며 객체들이 공통된 값을 공유한다. (클래스명, 변수명)
- println: 개행한다. print: 개행하지 않는다

5. Python 기출
```python
a = 100 # 이진수: 1100100
result = 0
for i in range(1, 3): # 1,2까지만
  result = a >> i
  result = result + 1
print(result)
```
첫 번째 시프트: 110010 -> 50 (+1)
두 번째 시프트: 11001 -> 25 (+1)
마지막 result 는 26이다.

6. Python 자료형 종류와 메서드
6-1. List
- append(): 리스트 끝에 요소를 추가한다.
- clear(): 리스트의 모든 요소를 삭제한다.
- copy(): 리스트의 복사본을 돌려준다.
- count(): 특정 값을 가진 요소의 개수를 반환한다.
- extend(): 다른 리스트의 요소를 현재 리스트 끝에 추가한다.
- index(): 특정 값을 가진 첫 번째 요소의 인덱스를 반환한다.
- insert(index, element): 리스트의 지정된 위치에 요소를 삽입합니다. ex) list.insert(1, 'a')는 리스트의 두 번째 위치에 'a'를 삽입합니다.
- pop([index]): 지정된 인덱스의 요소를 제거하고 그 요소를 반환합니다. 인덱스를 지정하지 않으면 마지막 요소를 제거하고 반환합니다. ex) list.pop(1)은 리스트의 두 번째 요소를 제거하고 그 값을 반환합니다.
- remove(value): 리스트에서 첫 번째로 일치하는 값을 제거합니다. ex) list.remove('a')는 리스트에서  첫 번째로 등장하는 'a'를 제거합니다.
- reverse(): 리스트의 요소 순서를 반대로 뒤집습니다.
- sort(): 리스트의 요소들을 정렬합니다. key는 정렬 기준을 지정하는 함수이고, reverse가 True이면 내림차순으로 정렬합니다. ex) list.sort()는 오름차순으로 정렬하고, list.sort(reverse=True)는 내림차순으로 정렬합니다.

6-2. Dictionary
- clear(): 딕셔너리의 모든 요소를 제거합니다.
- copy(): 딕셔너리의 복사본을 반환합니다.
- fromkeys(): 특정 키와 값으로 만들어서 딕셔너리를 반환
- get(): 지정된 키의 값을 반환합니다. 예를 들어, dict.get('a', 0) 은 키 'a'의 값을 반환하고, 키가 없으면 0을 반환합니다.
- items(): 딕셔너리의 (키,값) 쌍을 담은 뷰 객체를 반환합니다. 예를 들어 dict.items()는 dict_items([('a',1), ('b',2)])을 반환합니다.
- keys(): 딕셔너리의 키를 담은 뷰 객체를 반환합니다. 예를 들어, dict.keys()는 dict_keys(['a', 'b']) 를 반환합니다.
- pop(key, default = None): 지정된 키의 값을 반환하고 그 키-값 쌍을 딕셔너리에서 제거합니다. 키가 없으면 default 값을 반환합니다.
- popitem(): 임의의 키-값 쌍을 제거하고 반환합니다. 딕셔너리가 비어 있으면 KeyError가 발생합니다. ex) dict.popitem()은 임의의 키-값 쌍을 반환하고 딕셔너리까지 제거합니다.
- setdefault(): 특정 키의 값을 리턴한다. 키가 없는 경우 특정 값을 삽입한다.
- update(): 특정 키-값을 가진 딕셔너리를 추가
- values(): 딕셔너리의 값을 담은 뷰 객체를 반환합니다. 예를 들어, dict.values()는 dict_values([1,2])를 반환합니다.

6-3. Tuple: 튜플은 변경할 수 없는 시퀀스형 자료구조로, 주로 데이터를 읽기 전용으로 사용할 때 유용합니다. 튜플은 몇 가지 메서드만을 제공합니다.
- count(value): 튜플에서 지정된 값의 개수를 반환합니다. 예를 들어, (1, 2, 2, 3).count(2)는 2를 반환합니다.
- index(value, [start, [stop]]): 튜플에서 지정된 값의 첫 번째 인덱스를 반환합니다. 시작 및 끝 인덱스를 선택적으로 지정할 수 있습니다. 예를 들어, (1,2,3).index(2)는 1을 반환합니다.

6-4. Set: Python의 set 자료형은 고유한 값들의 집합을 나타내는 데이터 구조입니다. 중복되지 않는 요소들의 모임을 표현합니다. set은 변경 가능.
- add(element): 집합에 요소를 추가합니다. 예를 들어, set.add(1)은 집합에 1을 추가합니다.
- remove(element): 집합에서 지정된 요소를 제거합니다. 요소가 집합에 없으면 KeyError가 발생합니다. 예를 들어, set.remove(1)은 집합에서 1을 제거합니다.

7. Python 문법 주의할 것들
7-1. for문 횟수
- range(0,3): 0, 1, 2
- range(6): 0, 1, 2, 3, 4, 5
```python
for n in range(0, 3):
  print(n, end=', ') # 0, 1, 2가 나온다.
```

7-2. 슬라이싱
- str = Hello World
- str[0:3]: Hel (맨 뒤에 있는 것은 -1)
- str[-3:]: rld (마이너스는 숫자 그대로)
- str[8:]: rld (그 숫자부터 뒤 끝까지)

```python
a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
print(a[:7:2]) # 시작부터 6까지 2개씩 건너뛰기
# 답: [0, 20, 40, 60] <- 리스트가 되어야 함
```

```python
a = 100
result = 0
for i in range(1, 3):
  result = a >> i # 쉬프트 연산자
  print('{0:08b}'.format(result))
  result = result + 1

print(result)
```
>> 00110010
>> 00011001
>> 26

- 파이썬의 print는 기본적으로 개행이 들어간다.
- continue: 반복문의 처음으로 돌아가서 다음 횟수로 넘어가라.

8. Java의 static 개념
```java
class Person (
  static int person_count = 0;
  public int age = 0;
  public String name;

  Person(String param_name) {
    this.name = param_name;
    person_count++;
    age++;
  }

  public void print_info(){
    System.out.println("인구 :" + person_count);
    System.out.println(name + “:” + age);
  }
)

public static void main(String[] args){
 Person p1 = new Person("홍길동");
 p1.print_info();
 Person p2 = new Person("김길동");
 p2.print_info();
}
```

person_count는 공용공간이다.
>> 인구: 1
>> 홍길동: 1
>> 인구: 2 -> 이 부분은 공용공간이라 여러 객체가 공유해서 사용한다.
>> 김길동: 1

9. C언어의 구조체 문제
```c
#include <stdio.h>

struct Student {
  char name[12];
  int score1, score2, total, final_total;
};

struct Student students[3] = {{"Data1", 53, 88, 0, 0}, {"Data2", 45, 91, 0, 0}, {"Data3", 22, 75, 0, 0}};

int main() {
  struct student* ptr;
  ptr = &students[0];
  (ptr + 1) -> total = (ptr + 1) -> score1 + (ptr + 2) -> score2;
  (ptr + 1) -> final_total = (ptr + 1) -> total + ptr -> score1 + ptr -> score2; 
  printf("%d\n", (ptr + 1) -> total + (ptr + 1) -> final_total);

  return 0;
}
```

>> 출력값: 381

### 11. 응용 sw 기초 기술 활용
1. 운영체제의 목적 (처반사신)
- 처리 능력(Throughout): 일정 시간 내에 시스템이 처리하는 일의 양을 늘리기 위함
- 반환 시간(Turn around Time): 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간을 줄이기 위함
- 사용 가능도(Availability): 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도를 증대하기 위함
- 신뢰도 (Reliability): 시스템이 주어진 문제를 정확하게 해결하는 정도를 올리기 위함

2. 운영체제 운영방식
- 일괄 처리 시스템(Batch Processing System)
- 다중프로그래밍시스템 (Multi-Programming)
- 시분할시스템 (Time Sharing System)
- 실시간처리시스템 (Real Time Processing)
- 다중모드시스템 (Multi-Mode)
- 분산처리시스템 (Distributed Processing)

3. UNIX의 구성요소
- 커널(Kernal): 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 한다. 프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 데이터 전송 등을 수행한다.
- 쉘(Shell): 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기, 시스템과 사용자 간의 인터페이스
- 유틸리티 프로그램: 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용함. 예시로 에디터, 컴파일러, 인터프리터, 디버거가 있다.

4. 스래싱(Thrashing): 가상메모리 기법의 페이징 기법에서 페이지 부재가 계속 발생되어 프로세스가 수행되는 시간보다 페이지 교체에 소비되는 시간이 더 많이 드는 현상을 일컫는 용어

5-1. 2개의 프로세스가 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상인 교착상태 (DeadLock) 이 발생하기 위한 4가지 조건은? (상점비환)
- 상호배제(Mutual Exclusion): 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 한다.
- 점유와 대기(Hold and Wait): 이미 자원을 가진 프로세스가 다른 자원의 할당을 요구한다.
- 비선점(Non-Preemption): 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없다.
- 환형 대기(Circular Wait): 이미 자원을 가진 프로세스가 앞이나 뒤의 프로세스 자원을 요구한다.

5-2. 교착상태의 해결방법 (예발회회)
- 예방(Prevention): 교착 상태 발생의 4가지 조건 중에서 어느 하나를 제거함
- 회피(Avoidance): 교착 상태가 발생할 가능성을 배제하지 않고, 교착 상태가 발생하면 적절하게 빠져나감. 은행원 알고리즘이 사용됨
- 발견(Detection): 시스템에 교착 상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것
- 회복(Recovery): 교착 상태를 일으킨 프로세스를 종료하거나 교착 상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복함

6. 세마포어(Semaphore): Dijkstra가 제안한 상호 배제 알고리즘으로 각 프로세스가 임계구역에 대해 각각의 프로세스들이 접근하기 위하여 사용되는 P와 V 연산을 통해 프로세스 사이 동기를 유지하고 상호 배제의 원리를 보장하는 알고리즘

7. 무결성 제약조건
- 개체무결성: 기본 테이블의 기본키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다.
- 참조무결성: 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉, 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
- 도메인무결성: 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
- 고유무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 달라야하는 제약 조건
- NULL무결성: 릴레이션의 특정 속성 값이 Null이 될 수 없도록 하는 규정
- 키 무결성: 한 릴레이션(테이블)에는 최소한 하나의 키가 존재해야 하는 제약조건

8. 이상(Anomaly): 관계 데이터베이스의 논리적 설계 과정에서 하나의 릴레이션에 많은 속성이 있어 데이터의 종속과 중복으로 여러 가지 문제가 발생함. 릴레이션을 처리하는 데 발생하는 여러 문제로 삽입, 삭제, 갱신이 있음
1) 삽입 이상: 자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가 가능한 현상
2) 삭제 이상: 어떤 정보를 삭제하면, 유용한 다른 정보까지 삭제되어버리는 현상
3) 갱신 이상: 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상

9. 데이터베이스 회복 중 회복기법
1) 즉시갱신 회복기법: 트랜잭션 수행 도중에도 변경 내용을 즉시 데이터베이스에 기록
2) 지연갱신 회복기법: 커밋이 발생하기 전까지 데이터베이스에 기록하지 않음. 변경 내용을 로그 파일에만 저장
3) 검사시점 회복기법: 체크포인트 회복 기법. 장애 발생시 검사점 이전에 처리된 트랜잭션은 회복에서 제외하고 검사점 이후에 처리된 트랜잭션은 회복 작업 수행
4) 그림자 페이징: 트랜잭션이 실행되는 메모리상의 현재 페이지 테이블과 하드디스크의 그림자 페이지테이블을 이용한다.
5) 미디어 회복기법: 디스크와 같은 비휘발성 저장 장치 대비 회복 기법으로 백업, 미러링, RAID 등을 이용해 별도의 물리적인 저장장치에 덤프

9-2. 데이터베이스 회복 중 REDO, UNDO
- REDO(재수행)
- UNDO(취소)

10. 병행제어: 여러 개의 트랜잭션을 병행 수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것
10-1. 로킹: (어떤 단위를 액세스하기 전에 잠금을 요청해서 Lock이 허락되어야만 액세스 가능) 단위 -> 병행 제어에서 한꺼번에 로킹할 수 있는 객체의 크기
로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준은 낮아진다.
로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하지만, 병행성 수준이 낮아진다.

11. 서브네팅
- 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것
- 4바이트의 IP 주소 중, 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다.

12-1. IPv6의 특징
1) 128비트의 확장된 주소 공간
2) 인증성, 기밀성, 데이터 무결성 지원
3) IPv4 확장 헤더를 추가하여 네트워크 기능 확장
4) 시스템 관리, 주소 자동설정으로 시스템 관리 시간과 비용 줄여줌
- 주소체계: Unicast, Anycast, Multicast
- Unicast: 단일 송신 / 단일 수신(1:1)
- Anycast: 단일 송신 / 가장 가까운 단일 수신(1:1)
- Multicast: 단일 송신 / 다중 수신 (1대 다)

12-2. IPv4 특징과 종류
- 8bit씩 4개 필드로 구성되어 있음 (총 32bit)
- 유니캐스트, 멀티캐스트, 브로드캐스트가 있음
- 헤더 옵션이 40byte로 제한되어 있음

13. DNS: 문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하는 시스템을 DNS(Domain Name System)이라고 한다.

14. OSI 7계층 (물데네전세표응)
- 하위 계층: 물리 -> 데이터링크 -> 네트워크 계층
- 상위 계층: 전송 -> 세션 -> 표현 -> 응용 계층

14-1) 물리계층 (Physical Layer): 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 절차적 특성에 관한 규칙을 정의한다.
표준: RS-232C, X.21
장비: 리피터 (거리가 증가할수록 감쇠하는 디지털 신호의 장거리 전송을 위해 수신한 신호를 재생하거나 출력 전압을 높여 전송)
허브(여러 대의 컴퓨터를 연결하여 네트워크로 보내거나 하나의 네트워크로 수신된 정보를 여러 컴퓨터에 송신하는 장비)

14-2) 데이터 링크 계층(Data Link Layer): 2개의 인접한 개방 시스템 간의 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당
송/수신 측 속도 차이 해결을 위한 흐름 제어 기능, 프레임의 시작/끝을 구별하기 위한 프레임 동기화 기능, 프레임의 순서적 전송을 위한 순서 제어 기능
표준: HDLC, LAPB, MAC, LLC, PPP 등
장비: 랜카드, 브리지, 스위치(브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치)

14-3) 네트워크 계층(Network Layer, 망 계층)
개방 시스템 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능을 한다.
네트워크 연결을 설정/유지/해제하는 기능
경로 설정, 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송을 수행
표준: X.25, IP
장비: 라우터(브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택하는 기능이 추가된 장치)

14-4) 전송 계층(Transport Layer)
논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(End-to-End) 간에 투명한 데이터 전송을 가능케 한다.
상위 3계층의 인터페이스를 담당
종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능
주소 설정, 다중화, 오류제어, 흐름제어
표준) TCP, UDP
- TCP: 두 개의 호스트를 연결하고 데이터스트림을 교환하게 해주는 네트워크 프로토콜. 데이터와 패킷이 보내진 순서대로 전달하는 것을 보장
- UDP: IP를 사용하는 네트워크 내에서 컴퓨터 간 메세지를 교환하고 제한된 서비스만을 제공하는 통신 프로토콜. 도착한 데이터의 손상 정보를 알 수 있는 checksum 제공. 비 연결형으로 고속전송(장비) 게이트웨이

14-5) 세션 계층(Session Layer)
송/수신 간의 관련성을 유지하고 대화 제어를 담당
대화 구성 및 동기 제어
동기점은 오류가 있는 데이터의 회복을 위해 사용하는 것으로, 소동기점과 대동기점이 있다.
예제 프로토콜) NetBIOS, RPC, PPTP
- NetBIOS: 세션 계층에서 네트워크 애플리케이션간의 통신을 돕기 위해 사용합니다.
- RPC: 네트워크 상에서 원격 프로시저를 호출하는 기술로, 클라이언트와 서버 간의 세션 설정하여 관리한다.

14-6) 표현 계층(Presentation Layer)
응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신의 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환한다.
표준) JPEG, MPEG, SMB, AFP

14-7) 응용 계층(Application Layer)
사용자가 OSI 환경에 접근할 수 있도록 서비스를 제공한다. 정보 교환, 전자사서함, 파일 전송, 가상 터미널 등을 제공한다.
표준) HTTP, FTP, DHCP, DNS

15. TCP/IP 프로토콜의 계층
15-1) 응용계층(Application Layer): OSI 7계층의 응용, 표현, 세션 계층. 응용 프로그램 간의 데이터 송수신 제공
(TELNET, FTP, DNS, SNMP, HTTP)

15-2) 전송계층(Transport Layer): OSI 7계층의 전송 계층
호스트 간의 신뢰성 있는 통신 제공
종류: TCP, UDP, RTCP

15-3) 인터넷 계층(Internet Layer)
OSI 7계층의 네트워크 계층. 데이터 전송을 위한 주소 지정, 경로 설정을 제공함
종류: IP, ICMP, IGMP, ARP, RARP

- ICMP: 인터넷 프로토콜의 비신뢰적인 특성을 보완하기 위한 프로토콜. IP 패킷을 처리할 때 발생하는 에러 발생 원인을 알려주거나 네트워크 상태를 진단해주는 기능을 제공
- IGMP: 인터넷 그룹 관리 프로토콜은 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는 데 사용하는 통신 프로토콜
- ARP: 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC 주소)로 바꿈 (IP to MAC)
- RARP: ARP와 반대로 물리적 주소(MAC 주소)를 IP 주소로 변환하는 기능을 함(MAC to IP)

15-4) 네트워크 액세스 계층
OSI 7계층의 데이터 링크, 물리 계층. 실제 데이터(프레임)을 송수신하는 역할
종류: Ethernet, IEEE 802, X.25, ARQ, HDLC 등
- X.25: 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜
- RS-232C: 공중 전화 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜
- HDLC: 비트 위주의 데이터 링크 제어 프로토콜

16. 스위치
- L2 스위치: OSI 2계층에 속하는 장비, MAC 주소를 기반으로 프레임 전송, 일반적으로 부르는 스위치
- L3 스위치: OSI 3계층에 속하는 장비, L2 스위치에 라우터 기능이 추가된 것으로 IP 주소를 기반으로 패킷 전송. 서로 다른 네트워크 간의 연결이 가능
- L4 스위치: OSI 4계층에 속하는 장비, 로드 밸런서가 달린 L3 스위치로, TCP/UDP를 기반으로 서버의 부하가 적은 곳에 로드 밸런싱 기능을 제공
- L7 스위치: OSI 7계층에 속하는 장비, IP 주소, TCP/UDP 포트 정보에 패킷 내용까지 참조하여 세밀하게 로드밸런싱 제공

17. 키: 데이터베이스 조건에 만족하는 튜플을 찾거나, 순서대로 정렬할 때 기준이 되는 속성
- 기본키: 후보키 중에서 특별히 선정된 주키, 중복된 값을 가질 수 없으며 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성. 기본키는 NULL을 가질 수 없다.
- 후보키: 기본키로 사용할 수 있는 속성들. 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재하며 후보키는 유일성과 최소성을 만족시켜야 한다.
- 슈퍼키: 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만 최소성은 만족시키지 못함
- 대체키: 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키
- 외래키: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합

18. 교환 회선방식
1) 교환회선: 회선교환, 축적교환으로 나뉨
- 회선교환: 물리적 전용선을 활용하여 데이터 전달 경로가 정해진 후 동일 경로로만 전달
2) 축적교환: 메세지 교환, 패킷 교환으로 나뉨
- 메세지: 하나의 메세지 단위로 저장 - 전달 방식에 의해 데이터를 교환
- 패킷: 메세지를 일정한 길이의 전송 단위인 패킷으로 나누어 전송하는 방식. 실패한 패킷은 재전송이 가능하고 현재 컴퓨터 네트워크에서 주로 사용하는 방식이다.
3) 패킷교환: 가상회선, 데이터그램으로 나뉨
- 가상회선: 데이터를 전송하기 전에 논리적 연결이 설정되는데 이를 가상회선이라 한다. (회선교환 방식 + 데이터그램 방식) 의 장점을 결합한 통신 방식. 처음 패킷을 최적 경로로 고정하고 그 다음 패킷을 나눠 고속 전송, 통신 기술에는 ATM이 있으며 정해진 시간 안에 다량의 데이터를 연속으로 보낼 때 좋다.
- 데이터그램: 데이터를 전송하기 전에 논리적 연결을 하지 않고, 패킷을 독립적으로 전송. 패킷 교환 방식으로 동작하면서 IP 주소를 사용하는 인터넷을 의미. 가상회선 방식과 달리 특정 교환기가 고장나도 그 경로를 피해서 전송할 수 있기 때문에 신뢰성이 가능하다.

19. 프로토콜의 기본 3요소
- 구문: 데이터의 형식이나 부호화 및 신호 레벨을 규정한 것
- 의미: 전송의 조작이나 오류 제어를 위한 제어 정보에 대한 규정
- 타이밍: 접속되어 있는 개체 간의 통신 속도의 조정이나 메세지의 순서 제어 등을 규정

20. IP 주소와 서브넷마스크가 주어졌을 때 네트워크 주소와 해당 네트워크 주소와 브로드캐스트 주소를 제외한 호스트 개수
* 서브넷: 부분 네트워크 / 마스크: AND 연산

21. 라우팅 프로토콜의 종류와 예시
21-1. 내부 라우팅 프로토콜(IGP) - 내부 게이트웨이 프로토콜 (자치시스템 내)
- RIP: 거리벡터 알고리즘. 홉수만 본다(Hop count)
- OSPF: 링크 상태 변화시에만 라우팅 정보를 전송, 홉수/대역폭/지연시간 등을 고려하며 다익스트라 알고리즘을 기반으로 한다.

21-2. 외부 라우팅 프로토콜(EGP) - 외부 게이트웨이 프로토콜(자치시스템 간)
- EGP: 다른 그룹과 라우팅 정보를 교환하는 프로토콜
- BGP: 유일한 EGP의 프로토콜로 AS(Autonomous System)라는 집단끼리 상호작용하는 프로토콜

### 12. 제품 소프트웨어 패키징
1. DRM
- 정의: 디지털 콘텐츠의 생성부터 실제 사용자까지 유통되는 과정에 걸쳐 콘텐츠를 안전하게 관리 및 보호하고 허가된 사용자만이 접근할 수 있도록 제한하는 기술
- 기술적 요구사항: 지속적 보호, 이용 편리성, 유연성, 통합의 용이성

2. 디지털 콘텐츠의 사용권한 유형
- 렌더 퍼미션: 사용자에게 콘텐츠가 표현되고 이용되는 권리 형태를 정의
- 트랜스포트 퍼미션: 사용자들 간의 권리 교환가능
- 데리버티브 퍼미션: 콘텐츠 추출 변형이 가능

3. 버전관리 도구
- CVS: 동시 버전 시스템, 여러 개발자가 협력하여 작업할 수 있으며 GNU 일반 공중 사용 허가서하에 배포됨. 서버와 클라이언트 구조의 중앙 통제 방식으로 다수의 인원이 동시에 범용적인 운영체제로 접근가능한 버전 관리 도구.
- RCS: 파일 수정을 한 사람만으로 제한하는 도구. 파일 수정 중엔 파일을 잠금처리하며 다수의 사람들이 동시에 수정할 수 없음
- SVN: CVS보다 속도 개선. 2000년부터 콜랩넷에서 개발. 아파치 최상의 프로젝트. 소스코드를 올리면서 로그를 남기고 상황에 따라 롤백이 가능한 중앙 집중형 버전 관리 시스템
- Bitkeeper: SVN과 비슷하나 대규모 프로젝트에서 빠른 속도를 내도록 개발
- Git: Linux 커널 개발에 이용하기 위해 개발, 로컬 저장소에서 소스코드를 관리한 후 작업이 완료되면 중앙 저장소에 push하는 방법으로 프로그램을 관리하는 분산 버전 관리 시스템

4. 빌드 자동화 도구의 처리 절차
- 종속성 다운로드 -> 컴파일 -> 패키징 -> 테스트 -> 배포

### 디자인 패턴 정리
#### 생성
1. 빌더 Builder: 생성 단계를 캡슐화하여 구축 공정을 동일하게
2. 프로토타입 Prototype: 기존 객체를 복제해서 새 객체를 생성 가능
3. 팩토리메서드 Factory Method: 상위 클래스에서 객체 생성 인터페이스 정의, 하위 생성
4. 추상 팩토리 Abstract Factory: 생성군을 하나로 모아두고, 팩토리 중에 선택
5. 싱글턴 Singleton: 유일한 하나의 인스턴스를 보장하는 패턴

#### 구조
1. 브릿지 Bridge: 추상과 구현을 분리해서 결합도를 낮춘 패턴
2. 데코레이터 Decorator: 소스를 변경하지 않고 기능을 확장하는 패턴
3. 퍼사드 Facade: 하나의 인터페이스 통해 느슨한 결합 제공
4. 플라이웨이트 Flyweight: 대량의 작은 객체들을 공유하는 패턴
5. 프록시 Proxy: 대리인이 대신 그 일을 처리하는 패턴. 실제 객체를 호출하면 중간에 가로채서 다른 동작을 수행.
6. 컴포지트 Composite: 개별 객체와 복합 객체를 클라이언트에서 통일 사용
7. 어댑터 Adapter: 인터페이스 때문에 사용 못하는 클래스를 함께 사용

#### 행위
1. 인터프리터 Interpreter: 언어 규칙 클래스를 이용하는 패턴
2. 템플릿메서드 Template Method: 알고리즘 골격의 구조를 정의한 패턴
3. 책임의 고리 Chain of Responsibility: 객체끼리 연결 고리를 만들어 내부적으로 전달하는 패턴
4. 커맨드 Command: 요청 자체를 캡슐화해 파라미터로 넘기는 패턴
5. 이터레이터 Iterator: 내부 표현은 보여주지 않고 순회하는 패턴
6. 미디에이터 Mediator: 객체 간 상호작용을 캡슐화한 패턴
7. 메멘토 Mementor: 상태 값을 미리 저장해두었다가 복구하는 패턴
8. 옵저버 Observer: 상태가 변할 때 의존자에게 알리고 자동 업데이트
9. 스테이트 State: 객체 내부 상태에 따라서 행위를 변경하는 패턴
10. 스트레티지 Strategy: 여러 알고리즘을 캡슐화해 대체가 가능하게 함
11. 비지터 Visitor: 오퍼레이션을 별도의 클래스에 새롭게 정의한 패턴


### 관계 데이터 모델 구성요소
1) 릴레이션: 행과 열로 구성된 테이블
2) 튜플: 릴레이션의 행(Row)에 해당하는 요소
3) 속성: 릴레이션의 열(Column)에 해당하는 요소
4) 카디널리티: 튜플(Row)의 수
5) 차수: 애트리뷰트(Column)의 수 -> 속성의 수

### 접근통제 유형
- DAC: 임의 접근통제, 신분(소유자 등) 기준
- MAC: 강제 접근통제, 정책, 보안의 등급
- RBAC: 역할기반 접근통제, 신분 X, 개인역할 O

### 테스트 종류 정리
- 정적검사: 워크스루, 인스펙션, 동료검토
- 동적검사: 화이트박스 테스트, 블랙박스 테트트

