## 1. GoF(Gang of Four)의 디자인 패턴
GoF의 디자인 패턴은 유형애 따라 **생성** 패턴 5개, **구조** 패턴 5개, **행위** 패턴 11개 총 23개의 패턴으로 구성된다.

1. `생성 패턴(Creation Pattern)`
- 객체의 *생성과 참조 기능을 캡슐화* 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해준다.
- 추상 팩토리(Abstract Factory), 빌더(Builder), 팩토리 메소드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton)

2. `구조 패턴(Structural Pattern)`
- *클래스나 객체들을 조합*하여 더 큰 구조로 만들 수 있게 해주는 패턴으로 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.
- 어댑터(Adapter), 브리지(bridge), 컴포지트(Composite), 데코레이터(Decorator), 퍼싸드(Facade), 플라이웨이트(Flyweight), 프록시(Proxy)

3. `행위 패턴(Behavioral Pattern)`
- 클래스나 객체들이 서로 *상호작용*하는 방법이나 *책임 분배 방식*을 정의하는 패턴으로, 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화할 수 있도록 도와준다.
- 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(interpreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)

## 2. 객체지향 방법론
1. `속성`: 객체를 나타내는 성질, 값, 데이터
2. `메소드`: 객체의 속성을 이용한 일련의 동작들
3. `캡슐화`: 데이터와 해당 데이터의 처리 기능을 하나로 묶어냄, 재사용이 용이
4. `정보은닉`: 다른 객체에게 자신의 정보를 숨김
5. `추상화`: 객체의 공통적인 속성을 상위 객체로 도출
6. `상속성`: 상위 객체의 속성을 하위 객체가 물려받아 사용
7. `다형성`: 하나의 수행 방법으로 여러 형태의 기능을 수행
> '+' 연산자의 경우 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능으로 사용된다.
8. `클래스`: 공통된 속성과 연산(행위)를 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미. 객체지향 프로그램에서 *데이터를 추상화*하는 단위이다.

## 3. 객체의 연관성
연관성은 두 개 이상의 객체(클래스)들이 상호 참조하는 관계를 말하며 종류는 다음과 같다.

1. `is number of`: 연관화
- 두 개 이상의 객체가 상호 관련되어 있음을 의미함

2. `is instance of`: 분류화
- 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것

3. `is part of`: 집단화
- 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것

4. `is a`
- *일반화*: 공통적인 성질들로 추상화한 상위 객체를 구성하는 것(추상화)
- *특수화/상세화*: 상위 객체를 구체화하여 하위 객체를 구성하는 것

## 4. 객체지향 분석의 방법론
- `Rumbaugh(럼바우) 방법`: 가장 일반적으로 사용되는 방법으로, 분석 활동을 *객체 모델, 동적 모델, 기능 모델* 로 나누어 수행하는 방법

- `Booch(부치) 방법`: *미시적(Micro)* 개발 방법과 *거시적(Macro)* 개발 프로세스를 모두 사용하는 분석 방법으로, <u>클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의</u>함

- `Jacobson 방법`: *Use Case*를 강조하여 사용하는 분석 방법

- `Coad와 Yourdon 방법`: *E-R 다이어그램*을 사용하여 객체의 행위를 모델링하며, <u>객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의</u> 등의 과정으로 구성하는 기법

- `Wirfs-Brock 방법`: 분석과 설계 간의 구분이 없고, *고객 명세서를 평가* 해서 실제 작업까지 연속적으로 수행하는 기법

## 5. 코드의 종류
1. `순차 코드(Sequence Code)`
- 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 *일련번호를 부여* 하는 방법으로, 순서 코드 또는 일련번호 코드라고도 함.

2. `블록 코드(Block Code)`
- 코드화 대상 항목 중에서 *공통성이 있는 것끼리 블록으로 구분*하고 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 함
> 1001~1100: 총무부, 1101~1200: 영업부

3. `10진 코드(Decimal Code)`
- 코드화 대상 항목을 *0~9까지 10진 분할*하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 함
>  1000: 공학, 1100: 소프트웨어 공학, 1110: 소프트웨어 설계

4. `그룹 분류 코드(Group Classfication Code)`
- 코드화 대상 항목을 일정 기준에 따라 *대분류, 중분류, 소분류* 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법
> ex: 1-10-001: 본사-총무부-인사계, 2-01-001: 지사-총무부-인사계

5. `연상 코드(Memoric Code)`
- 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법
> TV-40: 40인치 TV, L-15-220: 15W 220V의 램프

6. `표의 숫자 코드(Significant Digit Code)`
- 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 *물리적 수치를 그대로 코드에 적용*시키는 방법으로, 유효 숫자 코드라고도 함
> 120-720-1500: 두께x폭x길이가 120x720x1500인 강판

7. `합성 코드(Combined Code)`
- 필요한 기능을 하나의 코드로 수행하기 어려운 경우 *2개 이상의 코드를 조합*하여 만드는 방법
> 연상 코드 + 순차 코드 => KE-711: 대한항공 711기, AC-253: 에어캐나다 253기

## 6. 플랫폼의 성능 측정 기준
- **가용성(Availability)**: 필요할 때 즉시 사용 가능한 정도(사용 가능도)
- **응답 시간(Response Time)**: 명령에 반응하는 시간(*처리 시간과 다름*)
- **정확성(Accuracy)**: 처리 결과가 기대한 값과 비교해서 정확한지 측정
- **사용률(Utilization)**: 데이터 처리에 시스템 자원을 사용하는 정도

## 7. 자료 사전
- `=`: 자료의 정의, *~로 구성되어 있다(is composed of)*
- `+`: 자료의 연결, *그리고(and)*
- `()`: 자료의 생략, *생략 가능한 자료(Optional)*
- `[|]`: 자료의 선택, *또는(or)*
- `{}`: 자료의 반복 *(Interation of)*
> { }n : n번 이상 반복 / { } nm : m 이상 n 이하로 반복
- `* *`: 자료의 설명 *주석(Comment)*

## 8. 요구사항 검증 방법
요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 경함 여부를 검토 담당자들이 수작업으로 분석

1. `동료검토(Peer Review)`
- 요구사항 명세서 *작성자가 명세서 내용을 직접 설명*하고 동료들이 이를 들으면서 결함을 발견

2. `워크스루(Walk Through)`
- 검토 회의 전 *요구사항 명세서를 미리 배포*하여 사전 검토한 후 *짧은 검토 회의* 를 통해 결함 발견

3. `인스펙션(Inspection)`
- 요구사항 *명세서 작성자를 제외한 다른 검토 전문가*들이 요구사항 명세서를 확인하면서 결함 발견

## 9. CASE의 주요 기능
CASE(Computer Aided Softsare Engineering)는 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 *컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화*하는 것이다.

- `주요 기능`: 소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원 등 

## 10. XP(eXtreme Programming)의 5가지 가치
- 의사소통, 단순성, 용기, 존중, 피드백

## 11. DBMS 분석 시 고려사항
- 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용

## 12. HIPO(Hierachy Input Process Output)
-  시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로, *입력, 처리, 출력*의 기능을 나타냄
- *하향식 소프트웨어 개발*을 위한 문서화 도구
- 체계적인 문서 관리 가능
- 기호, 도표 등을 사용하므로 이해가 쉬움
- 기능과 자료의 의존 관계를 동시에 표현 가능
- 변경, 유지보수가 용이
- `HIPO Chart`: 시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것

### HIPO 차트의 종류
- `가시적 도표(도식 목차)`: 시스템의 전체적인 기능과 흐름을 보여주는 계층(Tree) 구조도
- `총체적 도표(총괄도표, 개요도표)`: 프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표
- `세부적 도표(상세 도표)`: 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

## 13. UI(사용자 인터페이스) 설계 원칙
1. `직관성`: 누구나 쉽게 이해하고 사용할 수 있어야 한다.
2. `유효성`: 사용자의 목적을 정확하고 완벽하게 달성해야 한다.
3. `학습성`: 누구나 쉽게 배우고 익힐 수 있어야 한다.
4. `유연성`: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.

## 14. 럼바우(Rumbaugh)의 객체지향 분석 절차
1. `객체 모델링`
정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 **속성과 연산 식별 및 객체들 간의 관계를 규정**하여 *객체 다이어그램* 으로 표시하는 것

2. `동적 모델링`
*상태 다이어그램(상태도)*을 이용하여 시간의 흐름에 따른 객체들 간의 **제어 흐름, 동작 순서** 등의 동적인 행위를 표현하는 모델링

3. `기능 모델링`
*자료 흐름도(DFD)* 를 이용하여 다수의 프로세스들간의 자료 흐름을 중심으로 **처리 과정** 을 표현한 모델링

## 15. 데이터 흐름도(DFD)의 구성 요소
- 프로세스(Process), 자료 저장소(Data Store), 자료 흐름(Flow), 단말(Terminator)

## 16. UML(Unified Modeling Language)
스테레오 타입은 UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용되며, *길러멧*이라고 부르는 겹화살괄호(`<<>>`)에 표현할 형태를 기술한다.

- `<<include>>`: 연결된 다른 UML요소에 대해 포함 관계에 있는 경우 
- `<<extend>>`: 연결된 다른 UML요소에 대해 확장 관계에 있는 경우
- `<<interface>>`: 인터페이스를 정의
- `<<exception>>`: 예외를 정의
- `<<constructor>>`: 생성자 역할을 수행

## 17. 미들웨어(Middleware)
미들웨어는 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어이다.

1. `DB(DataBase)`
- 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
- DB를 이용하여 시스템을 구축하는 경우 보통 **2-Tier** 아키텍처라고 함

2. `RPC(Remote Procedure Call)`
- 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어

3. `MOM(Message Oriented Middleware)`(메시지 지향 미들웨어)
- 메세지 기반의 비동기형 메세지를 전달하는 방식의 미들웨어
- 온라인 업무보다는 **이기종 분산 데이터 시스템의 데이터 동기**를 위해 많이 사용됨

4. `TP-Monitor(Transaction Processing Monitor)`
- 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 *트랜잭션을 처리 및 감시*하는 미들웨어
- 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용됨

5. `ORB(Object Request Broker)`(객체 요청 브로커)
- *객체 지향* 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
- 최근에는 TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음

6. `WAS(Web Application Server)`(웹 애플리케이션 서버)
- 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용
- 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어

## 18. 요구사항 분석
- 사용자 요구의 *타당성을 조사*하고 *비용과 일정에 대한 제약을 설정*한다.
- 사용자의 *요구를 정확하게 추출하여 목표*를 정하고, 어떤 방식으로 해결할 것인지를 결정
- 사용자의 요구사항을 *정확하고 일관성 있게 분석하여 문서화* 해야 한다.
- `UML(Unified Modeling Language)`, `자료 흐름도(DFD)`, `자료 사전(DD)`, `소단위 명세서(Mini-Spec)`, `개체 관계도(ERD)`, `상태 전이도(STD)`, `제어 명세서` 등의 도구를 이용한다.

## 19. 공통 모듈 구현 시 준수해야 할 명세 기법
여러 프로그램에서 공통적으로 사용할 수 있는 모듈 구현 시, 다음의 명세 기법을 준수하여야 한다.

1. `정확성`: 시스템 구현 시 *해당 기능이 필요*하다는 것을 알 수 있도록 정확히 작성
2. `명확성`: 해당 기능을 *이해할 때 중의적으로 해석되지 않도록* 명확히 작성
3. `완전성`: 시스템 *구현을 위해 필요한 모든 것*을 기술
4. `일관성`: 공통 기능들 간 *상호 충돌이 발생하지 않도록* 작성
5. `추적성`: 기능에 대한 요구사항이 *출처, 관련 시스템 등의 관계를 파악할 수 있도록* 작성

## 20. Structural Diagram(구조적 다이어그램)의 종류
1. 클래스 다이어그램
- 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현
- 시스템의 구조를 파악하고 구조상의 문제점을 도출할 수 있음

2. 객체 다이어그램
- 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
- *럼바우 객체지향 분석 기법* 에서 객체 모델링에 활용됨

3. 컴포넌트 다이어그램
- 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현함
- *구현 단계에서 사용*

4. 배치 다이어그램
- 결과물, 프로세스, 컴포넌트 등 **물리적 요소들의 위치를 표현**
- *노드와 의사소통(통신) 경로*로 표현
- *구현 단계에서 사용*

5. 복합체 구조 다이어그램
- 클래스나 컴포넌트가 복합 구조를 갖는 경우 *그 내부 구조를 표현*

6. 패키지 다이어그램
- 유스케이스나 클래스 등의 **모델 요소들을 그룹화**한 패키지들의 관계를 표현

## 21. 경계 값 분석 기법
- 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법

## 22. 트리 관련 용어
1. `노드(Node)`: 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(branch)를 합친 것
2. `근 노드(Root Node)`: 트리의 맨 위에 있는 노드
3. `디그리(Degree, 차수)`: 각 노드에서 뻗어 나온 가지의 수
4. `단말 노드(Terminal Node)` = 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
5. `자식 노드(Son Node)`: 어떤 노드에 연결된 다음 레벨의 노드들
6. `부모 노드(Parent Node)`: 어떤 노드에 연결된 이전 레벨의 노드들
7. `형제 노드(Brother Node)`: 동일한 부모를 갖는 노드들
8. `트리의 디그리`: **노드들의 디그리 중에서 가장 많은 수**

## 23. 블랙박스 테스트의 종류
1. `동치 분할 검사(Equivalence Partitioning Testing)`
- *입력 자료에 초점*을 맞춰 테스트 케이스(동치 클래스)를 만들고 검사하는 방법으로, 동등 분할 기법이라고도 함
- 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 *균등하게* 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법

2. `경계값 분석(Boundary value Analysis)`
- 입력 자료에만 치중한 동치 분할 기법을 보완
- 입력 조건의 중간값보다 *경계값*에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 *경계값을 테스트 케이스로 선정*하여 검사

3. `원인-효과 그래프 검사(Cause-Effect Graphinf Testing)`
- 입력 데이터 간의 관계와 출력에 영향을 미치는 *상황을 체계적으로 분석*한 후, 효용성이 높은 테스트 케이스를 선정

4. `오류 예측 검사(Error Guessing)`
- 과거의 경험이나 확인자의 감각으로 테스트
- 다른 블랙 박스 테스트 기법으로는 찾아낼 수 없는 오류를 찾아내는 일련의 보충적 검사 기법이며, 데이터 확인 검사라고도 함

5. `비교 검사(Comparision Testing)`
- *여러 버전의 프로그램에 동일한 테스트 자료를 제공*하여 동일한 결과가 출력되는지 테스트

## 24. 테스트 드라이버와 스텁의 차이점
1. `드라이버(Driver)`
- 테스트 대상의 *하위 모듈을 호출*하는 도구로, 매개변수를 전달하고 모듈 테스트 수행 후의 결과를 도출
- 상향식 테스트에서 사용
- 이미 존재하는 하위 모듈과 *존재하지 않는 상위 모듈* 간의 인터페이스 역할을 함

2. `스텁(Stub)`
- 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈
- 상위 모듈은 있지만 하위 모듈이 없는 경우 *하위 모듈을 대체*
- 하향식 테스트에서 사용, 시험용 모듈이기 때문에 일반적으로 드라이버보다 작성하기 쉬움

## 25. ISO/ISE 9126 - 소프트웨어 품질 특성과 평가를 위한 표준 지침
1. `기능성`: 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부
- 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성

2. `신뢰성`: 소프트웨어가 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는 정도
- 성숙성, 고장 허용성, 회복성

3. `사용성`: 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대해 사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도
- 이해성, 학습성, 운용성, 친밀성

4. `효율성`: 사용자가 요구하는 기능을 할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도
- 시간 효율성, 자원 효율성

5. `유지 보수성`: 환경의 변화 또는 새로운 요구사항 발생 시 소프트웨어를 개선하거나 확장할 수 있는 정도
- 분석성, 변경성, 안정성, 시험성

6. `이식성`: 소프트웨어가 다른 환경에도 얼마나 쉽게 적용할 수 있는지 정도
- 적용성, 설치성, 대체성, 공존성

## 26. 애플리케이션 테스트 관련 용어
1. `결함 집중(Detect Clustering)`: 대부분의 결함이 소수의 특정 모듈에 집중해서 발생하는 것
2. `파레토의 법칙(Pareto Principle)`: 테스트로 발견된 80%의 오류는 20%의 모듈에서 발견됨
3. `살충제 패러독스(Pesricide Paradox)`: 같은 테스트 케이스를 가지고, 테스트를 계속해서 반복하는 경우 어느 시점부터는 더 이상 결함을 발견할 수 없음
4. `오류-부재의 궤변(Absence of Errors Fallacy)`: 소프트웨어의 결함을 모두 분석해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없음

## 27. DRM(디지털 저작권 관리)의 기술 요소
- `암호화(Encryption)`: 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술
- `키 관리(Key Management)`: 콘텐츠를 암호화한 키에 저장 및 분배 기술
- `암호화 파일 생성(Packager)`: 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
- `식별 기술(idenfication)`: 콘텐츠에 대한 식별 체계 표현 기술
- `저작권 표현(Right Expression)`: 라이선스의 내용 표현 기술
- `정책 관리(Policy Management)`: 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
- `크랙 방지(Tamper Resitanse)`: 크랙에 의한 콘텐츠 사용 방지 기술
- `인증(Authntication)`: 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

### 28. 인터페이스 보안 기능 적용
1. 네트워크 영역
- 인터페이스 송/수신간 스니핑 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 *트래픽에 대한 암호화*를 설정함
- 암호화는 인터페이스 아키텍처에 따라 *IPSec, SSL, S-HTTP*등의 다양한 방식으로 적용함

2. 애플리케이션 영역
- *소프트웨어 개발 보안 가이드*를 참조하여 애플리케이션 코드 상의 보안 취약점을 보완

3. 데이터베이스 영역
- 데이터베이스, 스키마, 엔티티의 접근 권한과 프로시저, 트리거 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용

4. IPSec(IP Security): 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜로, 암호화 수행시 양방향 암호화를 지원함

## 29. 인터페이스 구현 검증 도구
1. `xUnit`
- 같은 테스트 코드를 여러 번 작성하지 않게 도와주고, 테스트마다 예상 결과를 기억할 필요가 없게 하는 자동화된 해법을 제공하는 단위 테스트 프레임워크
- Smalltalk에 처음 적용되어 SUnit 이라는 이름이었으나 Java용의 JUnit, C++ 용의 CppUnit, .NET용의 NUnit, Http용의 HttpUnit 등 *다양한 언어에 적용*되면서 xUnit 으로 통칭되고 있음

2. `STAF`
- 서비스 호출 및 *컴포넌트 재사용* 등 다양한 환경을 지원하는 테스트 프레임워크
- 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성할 수 있도록 지원
- 분산 소프트웨어의 경우 각 분산 환경에 설치된 *데몬이 프로그램 테스트에 대한 응답을 대신*하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성함.

3. `FITNesse`
- *웹 기반* 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크

4. `NTAF`
- FitNess의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크

5. `Selenium`
- 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크

6. `watir`
- *Ruby*를 사용하는 애플리케이션 테스트 프레임워크

## 30. SW 패키징 도구 활용 시 고려 사항
- 사용자의 시스템 환경, 즉 운영체제(OS), CPU, 메모리 등에 필요한 *최소 환경을 정의*한다.
- UI는 사용자가 눈으로 직접 확인할 수 있도록 *시각적인 자료와 함께 제공*하고 *메뉴얼과 일치*시켜 패키징한다.
- 소프트웨어는 단순히 패키징하여 배포하는 것으로 끝나는 것이 아니라 **하드웨어와 함께 관리**될 수 있도록 *Managed Service*형태로 제공하는 것이 좋다.
- 사용자에게 배포되는 소프트웨어이므로 내부 콘텐츠에 대한 *암호화 및 보안*을 고려한다.
- 다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관리) 연동을 고려한다.
- 제품 소프트웨어 종류에 *적합한 알고리즘*을 적용한다.

## 31. 소프트웨어 형상 관리
형상 관리(SCM: Software Configuration Management)는 소프트웨어의 개발 과정에서 *소프트웨어의 변경 사항을 관리하기 위해* 개발된 일련의 활동이다.

## 32. White Box Testing
화이트박스 테스트는 모듈의 원시 코드를 오픈 시킨 상태에서 원시 코드의 *논리적인 모든 경로를 테스트* 하여 테스트 케이스를 설계하는 방법이다.

- 모듈 안 작동을 **직접 관찰** 한다.
- 원시 코드(모듈)의 **모든 문장을 한 번 이상 실행**한다.
- 프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행함으로서 **논리적 경로를 제어한다.**

### 화이트박스 테스트의 종류
1. `기초 경로 검사(Base Path Testing)`: 대표적인 화이트박스 테스트 설계 기법, 절차적 설계의 **논리적 복잡성을 측정**할 수 있게 해 줌, 실행 경로의 기초를 정의하는 데 지침으로 사용

2. `제어 구조 검사(Control Structure Testing)`
- 조건 검사(Condition Testing): 프로그램 모듈 내에 있는 **논리적 조건을 테스트**
- 루프 검사(Loop Testing): 프로그램의 **반복 구조에 초점을 맞춰** 테스트 
- 데이터 흐름 검사(Data Flow Testing): **변수의 정의**와 **변수 사용의 위치**에 초점을 맞춰 테스트


## 33. 외계인 코드(Alien Code)
아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드

## 34. 트리의 운행(순회)법
```
  A
 /\
B  C
```
1. `Preorder 운행(전위 순회)`: *Root-> Left -> Right* / A -> B -> C
2. `Inorder 운행(중위 순회)`: *Left -> Root -> Right* / B -> A -> C
3. `Postorder 운행(후위 순회)`: *Left -> Right -> Root* / B -> C -> A