## 1. GoF(Gang of Four)의 디자인 패턴
GoF의 디자인 패턴은 유형애 따라 **생성** 패턴 5개, **구조** 패턴 5개, **행위** 패턴 11개 총 23개의 패턴으로 구성된다.

1. `생성 패턴(Creation Pattern)`
- 객체의 *생성과 참조 기능을 캡슐화* 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해준다.
- 추상 팩토리(Abstract Factory), 빌더(Builder), 팩토리 메소드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton)

2. `구조 패턴(Structural Pattern)`
- *클래스나 객체들을 조합*하여 더 큰 구조로 만들 수 있게 해주는 패턴으로 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.
- 어댑터(Adapter), 브리지(bridge), 컴포지트(Composite), 데코레이터(Decorator), 퍼싸드(Facade), 플라이웨이트(Flyweight), 프록시(Proxy)

3. `행위 패턴(Behavioral Pattern)`
- 클래스나 객체들이 서로 *상호작용*하는 방법이나 *책임 분배 방식*을 정의하는 패턴으로, 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화할 수 있도록 도와준다.
- 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(interpreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)

## 2. 객체지향 방법론
1. `속성`: 객체를 나타내는 성질, 값, 데이터
2. `메소드`: 객체의 속성을 이용한 일련의 동작들
3. `캡슐화`: 데이터와 해당 데이터의 처리 기능을 하나로 묶어냄, 재사용이 용이
4. `정보은닉`: 다른 객체에게 자신의 정보를 숨김
5. `추상화`: 객체의 공통적인 속성을 상위 객체로 도출
6. `상속성`: 상위 객체의 속성을 하위 객체가 물려받아 사용
7. `다형성`: 하나의 수행 방법으로 여러 형태의 기능을 수행
> '+' 연산자의 경우 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능으로 사용된다.
8. `클래스`: 공통된 속성과 연산(행위)를 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미. 객체지향 프로그램에서 *데이터를 추상화*하는 단위이다.

## 3. 객체의 연관성
연관성은 두 개 이상의 객체(클래스)들이 상호 참조하는 관계를 말하며 종류는 다음과 같다.

1. `is number of`: 연관화
- 두 개 이상의 객체가 상호 관련되어 있음을 의미함

2. `is instance of`: 분류화
- 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것

3. `is part of`: 집단화
- 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것

4. `is a`
- *일반화*: 공통적인 성질들로 추상화한 상위 객체를 구성하는 것(추상화)
- *특수화/상세화*: 상위 객체를 구체화하여 하위 객체를 구성하는 것

## 4. 객체지향 분석의 방법론
- `Rumbaugh(럼바우) 방법`: 가장 일반적으로 사용되는 방법으로, 분석 활동을 *객체 모델, 동적 모델, 기능 모델* 로 나누어 수행하는 방법

- `Booch(부치) 방법`: *미시적(Micro)* 개발 방법과 *거시적(Macro)* 개발 프로세스를 모두 사용하는 분석 방법으로, <u>클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의</u>함

- `Jacobson 방법`: *Use Case*를 강조하여 사용하는 분석 방법

- `Coad와 Yourdon 방법`: *E-R 다이어그램*을 사용하여 객체의 행위를 모델링하며, <u>객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의</u> 등의 과정으로 구성하는 기법

- `Wirfs-Brock 방법`: 분석과 설계 간의 구분이 없고, *고객 명세서를 평가* 해서 실제 작업까지 연속적으로 수행하는 기법

## 5. 코드의 종류
1. `순차 코드(Sequence Code)`
- 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 *일련번호를 부여* 하는 방법으로, 순서 코드 또는 일련번호 코드라고도 함.

2. `블록 코드(Block Code)`
- 코드화 대상 항목 중에서 *공통성이 있는 것끼리 블록으로 구분*하고 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 함
> 1001~1100: 총무부, 1101~1200: 영업부

3. `10진 코드(Decimal Code)`
- 코드화 대상 항목을 *0~9까지 10진 분할*하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 함
>  1000: 공학, 1100: 소프트웨어 공학, 1110: 소프트웨어 설계

4. `그룹 분류 코드(Group Classfication Code)`
- 코드화 대상 항목을 일정 기준에 따라 *대분류, 중분류, 소분류* 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법
> ex: 1-10-001: 본사-총무부-인사계, 2-01-001: 지사-총무부-인사계

5. `연상 코드(Memoric Code)`
- 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법
> TV-40: 40인치 TV, L-15-220: 15W 220V의 램프

6. `표의 숫자 코드(Significant Digit Code)`
- 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 *물리적 수치를 그대로 코드에 적용*시키는 방법으로, 유효 숫자 코드라고도 함
> 120-720-1500: 두께x폭x길이가 120x720x1500인 강판

7. `합성 코드(Combined Code)`
- 필요한 기능을 하나의 코드로 수행하기 어려운 경우 *2개 이상의 코드를 조합*하여 만드는 방법
> 연상 코드 + 순차 코드 => KE-711: 대한항공 711기, AC-253: 에어캐나다 253기

## 6. 플랫폼의 성능 측정 기준
- **가용성(Availability)**: 필요할 때 즉시 사용 가능한 정도(사용 가능도)
- **응답 시간(Response Time)**: 명령에 반응하는 시간(*처리 시간과 다름*)
- **정확성(Accuracy)**: 처리 결과가 기대한 값과 비교해서 정확한지 측정
- **사용률(Utilization)**: 데이터 처리에 시스템 자원을 사용하는 정도

## 7. 자료 사전
- `=`: 자료의 정의, *~로 구성되어 있다(is composed of)*
- `+`: 자료의 연결, *그리고(and)*
- `()`: 자료의 생략, *생략 가능한 자료(Optional)*
- `[|]`: 자료의 선택, *또는(or)*
- `{}`: 자료의 반복 *(Interation of)*
> { }n : n번 이상 반복 / { } nm : m 이상 n 이하로 반복
- `* *`: 자료의 설명 *주석(Comment)*

## 8. 요구사항 검증 방법
요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 경함 여부를 검토 담당자들이 수작업으로 분석

1. `동료검토(Peer Review)`
- 요구사항 명세서 *작성자가 명세서 내용을 직접 설명*하고 동료들이 이를 들으면서 결함을 발견

2. `워크스루(Walk Through)`
- 검토 회의 전 *요구사항 명세서를 미리 배포*하여 사전 검토한 후 *짧은 검토 회의* 를 통해 결함 발견

3. `인스펙션(Inspection)`
- 요구사항 *명세서 작성자를 제외한 다른 검토 전문가*들이 요구사항 명세서를 확인하면서 결함 발견

## 9. CASE의 주요 기능
CASE(Computer Aided Softsare Engineering)는 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 *컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화*하는 것이다.

- `주요 기능`: 소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원 등 

## 10. XP(eXtreme Programming)의 5가지 가치
- 의사소통, 단순성, 용기, 존중, 피드백

## 11. DBMS 분석 시 고려사항
- 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용

## 12. HIPO(Hierachy Input Process Output)
-  시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로, *입력, 처리, 출력*의 기능을 나타냄
- *하향식 소프트웨어 개발*을 위한 문서화 도구
- 체계적인 문서 관리 가능
- 기호, 도표 등을 사용하므로 이해가 쉬움
- 기능과 자료의 의존 관계를 동시에 표현 가능
- 변경, 유지보수가 용이
- `HIPO Chart`: 시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것

### HIPO 차트의 종류
- `가시적 도표(도식 목차)`: 시스템의 전체적인 기능과 흐름을 보여주는 계층(Tree) 구조도
- `총체적 도표(총괄도표, 개요도표)`: 프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표
- `세부적 도표(상세 도표)`: 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

## 13. UI(사용자 인터페이스) 설계 원칙
1. `직관성`: 누구나 쉽게 이해하고 사용할 수 있어야 한다.
2. `유효성`: 사용자의 목적을 정확하고 완벽하게 달성해야 한다.
3. `학습성`: 누구나 쉽게 배우고 익힐 수 있어야 한다.
4. `유연성`: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.

## 14. 럼바우(Rumbaugh)의 객체지향 분석 절차
1. `객체 모델링`
정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 **속성과 연산 식별 및 객체들 간의 관계를 규정**하여 *객체 다이어그램* 으로 표시하는 것

2. `동적 모델링`
*상태 다이어그램(상태도)*을 이용하여 시간의 흐름에 따른 객체들 간의 **제어 흐름, 동작 순서** 등의 동적인 행위를 표현하는 모델링

3. `기능 모델링`
*자료 흐름도(DFD)* 를 이용하여 다수의 프로세스들간의 자료 흐름을 중심으로 **처리 과정** 을 표현한 모델링

## 15. 데이터 흐름도(DFD)의 구성 요소
- 프로세스(Process), 자료 저장소(Data Store), 자료 흐름(Flow), 단말(Terminator)

## 16. UML(Unified Modeling Language)
스테레오 타입은 UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용되며, *길러멧*이라고 부르는 겹화살괄호(`<<>>`)에 표현할 형태를 기술한다.

- `<<include>>`: 연결된 다른 UML요소에 대해 포함 관계에 있는 경우 
- `<<extend>>`: 연결된 다른 UML요소에 대해 확장 관계에 있는 경우
- `<<interface>>`: 인터페이스를 정의
- `<<exception>>`: 예외를 정의
- `<<constructor>>`: 생성자 역할을 수행

## 17. 미들웨어(Middleware)
미들웨어는 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어이다.

1. `DB(DataBase)`
- 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
- DB를 이용하여 시스템을 구축하는 경우 보통 **2-Tier** 아키텍처라고 함

2. `RPC(Remote Procedure Call)`
- 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어

3. `MOM(Message Oriented Middleware)`(메시지 지향 미들웨어)
- 메세지 기반의 비동기형 메세지를 전달하는 방식의 미들웨어
- 온라인 업무보다는 **이기종 분산 데이터 시스템의 데이터 동기**를 위해 많이 사용됨

4. `TP-Monitor(Transaction Processing Monitor)`
- 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 *트랜잭션을 처리 및 감시*하는 미들웨어
- 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용됨

5. `ORB(Object Request Broker)`(객체 요청 브로커)
- *객체 지향* 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
- 최근에는 TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음

6. `WAS(Web Application Server)`(웹 애플리케이션 서버)
- 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용
- 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어

## 18. 요구사항 분석
- 사용자 요구의 *타당성을 조사*하고 *비용과 일정에 대한 제약을 설정*한다.
- 사용자의 *요구를 정확하게 추출하여 목표*를 정하고, 어떤 방식으로 해결할 것인지를 결정
- 사용자의 요구사항을 *정확하고 일관성 있게 분석하여 문서화* 해야 한다.
- `UML(Unified Modeling Language)`, `자료 흐름도(DFD)`, `자료 사전(DD)`, `소단위 명세서(Mini-Spec)`, `개체 관계도(ERD)`, `상태 전이도(STD)`, `제어 명세서` 등의 도구를 이용한다.

## 19. 공통 모듈 구현 시 준수해야 할 명세 기법
여러 프로그램에서 공통적으로 사용할 수 있는 모듈 구현 시, 다음의 명세 기법을 준수하여야 한다.

1. `정확성`: 시스템 구현 시 *해당 기능이 필요*하다는 것을 알 수 있도록 정확히 작성
2. `명확성`: 해당 기능을 *이해할 때 중의적으로 해석되지 않도록* 명확히 작성
3. `완전성`: 시스템 *구현을 위해 필요한 모든 것*을 기술
4. `일관성`: 공통 기능들 간 *상호 충돌이 발생하지 않도록* 작성
5. `추적성`: 기능에 대한 요구사항이 *출처, 관련 시스템 등의 관계를 파악할 수 있도록* 작성

## 20. Structural Diagram(구조적 다이어그램)의 종류
1. 클래스 다이어그램
- 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현
- 시스템의 구조를 파악하고 구조상의 문제점을 도출할 수 있음

2. 객체 다이어그램
- 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
- *럼바우 객체지향 분석 기법* 에서 객체 모델링에 활용됨

3. 컴포넌트 다이어그램
- 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현함
- *구현 단계에서 사용*

4. 배치 다이어그램
- 결과물, 프로세스, 컴포넌트 등 **물리적 요소들의 위치를 표현**
- *노드와 의사소통(통신) 경로*로 표현
- *구현 단계에서 사용*

5. 복합체 구조 다이어그램
- 클래스나 컴포넌트가 복합 구조를 갖는 경우 *그 내부 구조를 표현*

6. 패키지 다이어그램
- 유스케이스나 클래스 등의 **모델 요소들을 그룹화**한 패키지들의 관계를 표현

## 21. 경계 값 분석 기법
- 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법

## 22. 트리 관련 용어
1. `노드(Node)`: 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(branch)를 합친 것
2. `근 노드(Root Node)`: 트리의 맨 위에 있는 노드
3. `디그리(Degree, 차수)`: 각 노드에서 뻗어 나온 가지의 수
4. `단말 노드(Terminal Node)` = 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
5. `자식 노드(Son Node)`: 어떤 노드에 연결된 다음 레벨의 노드들
6. `부모 노드(Parent Node)`: 어떤 노드에 연결된 이전 레벨의 노드들
7. `형제 노드(Brother Node)`: 동일한 부모를 갖는 노드들
8. `트리의 디그리`: **노드들의 디그리 중에서 가장 많은 수**

## 23. 블랙박스 테스트의 종류
1. `동치 분할 검사(Equivalence Partitioning Testing)`
- *입력 자료에 초점*을 맞춰 테스트 케이스(동치 클래스)를 만들고 검사하는 방법으로, 동등 분할 기법이라고도 함
- 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 *균등하게* 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법

2. `경계값 분석(Boundary value Analysis)`
- 입력 자료에만 치중한 동치 분할 기법을 보완
- 입력 조건의 중간값보다 *경계값*에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 *경계값을 테스트 케이스로 선정*하여 검사

3. `원인-효과 그래프 검사(Cause-Effect Graphinf Testing)`
- 입력 데이터 간의 관계와 출력에 영향을 미치는 *상황을 체계적으로 분석*한 후, 효용성이 높은 테스트 케이스를 선정

4. `오류 예측 검사(Error Guessing)`
- 과거의 경험이나 확인자의 감각으로 테스트
- 다른 블랙 박스 테스트 기법으로는 찾아낼 수 없는 오류를 찾아내는 일련의 보충적 검사 기법이며, 데이터 확인 검사라고도 함

5. `비교 검사(Comparision Testing)`
- *여러 버전의 프로그램에 동일한 테스트 자료를 제공*하여 동일한 결과가 출력되는지 테스트

## 24. 테스트 드라이버와 스텁의 차이점
1. `드라이버(Driver)`
- 테스트 대상의 *하위 모듈을 호출*하는 도구로, 매개변수를 전달하고 모듈 테스트 수행 후의 결과를 도출
- 상향식 테스트에서 사용
- 이미 존재하는 하위 모듈과 *존재하지 않는 상위 모듈* 간의 인터페이스 역할을 함

2. `스텁(Stub)`
- 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈
- 상위 모듈은 있지만 하위 모듈이 없는 경우 *하위 모듈을 대체*
- 하향식 테스트에서 사용, 시험용 모듈이기 때문에 일반적으로 드라이버보다 작성하기 쉬움

## 25. ISO/ISE 9126 - 소프트웨어 품질 특성과 평가를 위한 표준 지침
1. `기능성`: 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부
- 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성

2. `신뢰성`: 소프트웨어가 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는 정도
- 성숙성, 고장 허용성, 회복성

3. `사용성`: 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대해 사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도
- 이해성, 학습성, 운용성, 친밀성

4. `효율성`: 사용자가 요구하는 기능을 할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도
- 시간 효율성, 자원 효율성

5. `유지 보수성`: 환경의 변화 또는 새로운 요구사항 발생 시 소프트웨어를 개선하거나 확장할 수 있는 정도
- 분석성, 변경성, 안정성, 시험성

6. `이식성`: 소프트웨어가 다른 환경에도 얼마나 쉽게 적용할 수 있는지 정도
- 적용성, 설치성, 대체성, 공존성

## 26. 애플리케이션 테스트 관련 용어
1. `결함 집중(Detect Clustering)`: 대부분의 결함이 소수의 특정 모듈에 집중해서 발생하는 것
2. `파레토의 법칙(Pareto Principle)`: 테스트로 발견된 80%의 오류는 20%의 모듈에서 발견됨
3. `살충제 패러독스(Pesricide Paradox)`: 같은 테스트 케이스를 가지고, 테스트를 계속해서 반복하는 경우 어느 시점부터는 더 이상 결함을 발견할 수 없음
4. `오류-부재의 궤변(Absence of Errors Fallacy)`: 소프트웨어의 결함을 모두 분석해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없음

## 27. DRM(디지털 저작권 관리)의 기술 요소
- `암호화(Encryption)`: 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술
- `키 관리(Key Management)`: 콘텐츠를 암호화한 키에 저장 및 분배 기술
- `암호화 파일 생성(Packager)`: 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
- `식별 기술(idenfication)`: 콘텐츠에 대한 식별 체계 표현 기술
- `저작권 표현(Right Expression)`: 라이선스의 내용 표현 기술
- `정책 관리(Policy Management)`: 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
- `크랙 방지(Tamper Resitanse)`: 크랙에 의한 콘텐츠 사용 방지 기술
- `인증(Authntication)`: 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

### 28. 인터페이스 보안 기능 적용
1. 네트워크 영역
- 인터페이스 송/수신간 스니핑 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 *트래픽에 대한 암호화*를 설정함
- 암호화는 인터페이스 아키텍처에 따라 *IPSec, SSL, S-HTTP*등의 다양한 방식으로 적용함

2. 애플리케이션 영역
- *소프트웨어 개발 보안 가이드*를 참조하여 애플리케이션 코드 상의 보안 취약점을 보완

3. 데이터베이스 영역
- 데이터베이스, 스키마, 엔티티의 접근 권한과 프로시저, 트리거 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용

4. IPSec(IP Security): 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜로, 암호화 수행시 양방향 암호화를 지원함

## 29. 인터페이스 구현 검증 도구
1. `xUnit`
- 같은 테스트 코드를 여러 번 작성하지 않게 도와주고, 테스트마다 예상 결과를 기억할 필요가 없게 하는 자동화된 해법을 제공하는 단위 테스트 프레임워크
- Smalltalk에 처음 적용되어 SUnit 이라는 이름이었으나 Java용의 JUnit, C++ 용의 CppUnit, .NET용의 NUnit, Http용의 HttpUnit 등 *다양한 언어에 적용*되면서 xUnit 으로 통칭되고 있음

2. `STAF`
- 서비스 호출 및 *컴포넌트 재사용* 등 다양한 환경을 지원하는 테스트 프레임워크
- 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성할 수 있도록 지원
- 분산 소프트웨어의 경우 각 분산 환경에 설치된 *데몬이 프로그램 테스트에 대한 응답을 대신*하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성함.

3. `FITNesse`
- *웹 기반* 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크

4. `NTAF`
- FitNess의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크

5. `Selenium`
- 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크

6. `watir`
- *Ruby*를 사용하는 애플리케이션 테스트 프레임워크

## 30. SW 패키징 도구 활용 시 고려 사항
- 사용자의 시스템 환경, 즉 운영체제(OS), CPU, 메모리 등에 필요한 *최소 환경을 정의*한다.
- UI는 사용자가 눈으로 직접 확인할 수 있도록 *시각적인 자료와 함께 제공*하고 *메뉴얼과 일치*시켜 패키징한다.
- 소프트웨어는 단순히 패키징하여 배포하는 것으로 끝나는 것이 아니라 **하드웨어와 함께 관리**될 수 있도록 *Managed Service*형태로 제공하는 것이 좋다.
- 사용자에게 배포되는 소프트웨어이므로 내부 콘텐츠에 대한 *암호화 및 보안*을 고려한다.
- 다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관리) 연동을 고려한다.
- 제품 소프트웨어 종류에 *적합한 알고리즘*을 적용한다.

## 31. 소프트웨어 형상 관리
형상 관리(SCM: Software Configuration Management)는 소프트웨어의 개발 과정에서 *소프트웨어의 변경 사항을 관리하기 위해* 개발된 일련의 활동이다.

## 32. White Box Testing
화이트박스 테스트는 모듈의 원시 코드를 오픈 시킨 상태에서 원시 코드의 *논리적인 모든 경로를 테스트* 하여 테스트 케이스를 설계하는 방법이다.

- 모듈 안 작동을 **직접 관찰** 한다.
- 원시 코드(모듈)의 **모든 문장을 한 번 이상 실행**한다.
- 프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행함으로서 **논리적 경로를 제어한다.**

### 화이트박스 테스트의 종류
1. `기초 경로 검사(Base Path Testing)`: 대표적인 화이트박스 테스트 설계 기법, 절차적 설계의 **논리적 복잡성을 측정**할 수 있게 해 줌, 실행 경로의 기초를 정의하는 데 지침으로 사용

2. `제어 구조 검사(Control Structure Testing)`
- 조건 검사(Condition Testing): 프로그램 모듈 내에 있는 **논리적 조건을 테스트**
- 루프 검사(Loop Testing): 프로그램의 **반복 구조에 초점을 맞춰** 테스트 
- 데이터 흐름 검사(Data Flow Testing): **변수의 정의**와 **변수 사용의 위치**에 초점을 맞춰 테스트


## 33. 외계인 코드(Alien Code)
아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드

## 34. 트리의 운행(순회)법
```
  A
 /\
B  C
```
1. `Preorder 운행(전위 순회)`: *Root-> Left -> Right* / A -> B -> C
2. `Inorder 운행(중위 순회)`: *Left -> Root -> Right* / B -> A -> C
3. `Postorder 운행(후위 순회)`: *Left -> Right -> Root* / B -> C -> A

## 35, 36. 빅오 표기법
1. `O(1)`: 입력값(n)에 관계 없이 일정하게 문제 해결애 하나의 단계만을 가짐. (스택의 삽입(Push), 삭제(Pop))
2. `O(log2n)`: 문제 해결에 필요한 단계가 입력값(n) 또는 조건에 의해 *감소*함. (이진 트리, 이진 검색)
3. `O(n)`: 문제 해결에 필요한 단계가 입력값(n)과 1:1의 관계를 가짐 (for문)
4. `O(nlog2n)`: 문제 해결에 필요한 단계가 *n(log2n)*번만큼 수행됨. (*힙 정렬, 2-Way 합병 정렬*)
5. `O(n^2)`: 문제 해결에 필요한 단계가 입력값(n)의 제곱만큼 수행됨(삽입 정렬, 쉘 정렬, 선택 정렬, 버블 정렬, 퀵 정렬)
6. `O(2^n)`: 문제 해결에 필요한 단계가 2의 입력갑(n)제곱만큼 수행됨(*피보나치 수열*)

## 37. ISO/IEC 9126 '기능성' 의 하위 특성
- 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성

## 38. EAI(Enterprise Application Integration)
EAI는 *기업 내 각종 애플리케이션 또는 플랫폼* 간의 *정보 전달, 연계, 통합 등 상호 연동*이 가능하게 해 주는 솔루션으로, 비즈니스 간 통합 및 연계성을 증대시켜 효율성과 각 시스템 간의 확장성을 높여 준다.

### EAI의 구축 유형
1. `Point-to-Point`
- 가장 기본적인 통합 방식, 애플리케이션을 *1:1*로 연결함. 
- 변경 및 재사용이 어ㅓㅕ움

2. `Hub & Spoke`
- 단일 접점인 허브 시스템을 통해 데이터를 전송하는 *중앙 집중형 방식*
- 확장 및 유지 보수 용이
- 허브 장애 발생 시 *시스템 전체에 영향을 미침*

3. `Message Bus(ESB 방식)`
- 애플리케이션 사이에 *미들웨어*를 두어 처리하는 방식
- 확장성이 뛰어나며 *대용량 처리가 가능함*

4. `Hybrid`
- *Hub&Spoke*와 *Message Bus*의 통합 방식
- 그룹 내에서는 Hub&Spoke 방식을, 그룹 간에는 Message Bus 방식을 사용
- 필요한 경우, 한 가지 방식으로 EAI 구현이 가능함
- *데이터 병목 현상을 최소화할 수 있음*

## 39. 소스 코드 품질 정적 분석 도구
- 작성한 소스 코드를 *실행하지 않고* 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구
- 비교적 애플리케이션 개발 초기의 결함을 찾는 데 사용되고, 개발 완료 시점에서는 개발된 소스 코드의 품질을 검증하는 차원에서 사용
- *자료 흐름이나 논리 흐름을 분석* 하여 비정상적인 패턴 감지
- 동적 분석 도구로는 발견하기 어려운 결함을 찾아내고, 소스 코드에서 **코딩의 복잡도, 모델 의존성, 불일치성** 등을 분석 가능
- 종류: `pmd`, `cppcheck`, `sonarCube`, `checkstyle`, `ccm`, `cobertura`

## 40. 반정규화 - 중복 테이블 추가
1. `테이블 통합`
- 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 작업의 효율성을 향상시킬 수 있음
- `집계 테이블 추가`, `진행 테이블 추가`, `특정 부분만을 포함하는 테이블의 추가`

## 41. DDL (Data Define Language, 데이터 정의어)
DDL은 스키마, 도메인, 테이블, 뷰, 인덱스를 정의하거나 변경 또는 삭제할 때 사용하는 언어이다.
- *논리적 데이터 구조와 물리적 데이터 구조의 사상을 정의*한다.
- 데이터베이스 *관리자나 설계자*가 사용한다.

### DDL의 유형
1. `CREATE`: 스키마, 도메인, 테이블, 뷰, 인덱스를 정의함
2. `ALTER`: 테이블에 대한 정의 변경에 사용
3. `DROP`: 스키마, 도메인, 테이블, 뷰, 인덱스를 삭제함

## 43. 키(Key)
키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트를 말한다.

1. `후보키(Candidate Key)`
- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기  위해 사용하는 속성들의 부분집합, 즉 *기본키로 사용할 수 있는 속성*
- 후보키는 릴레이션에 있는 모든 튜플에 대해 *유일성*과 *희소성*을 만족시켜야 함

2. `기본키(Primary Key)`
- 후보키 중에서 특별히 선정된 주키(Main Key)로 *중복된 값을 가질 수 없음*
- 한 릴레이션에서 특정 튜플을 *유일하게 구분*할 수 있는 속성
- 기본키는 *NULL 값을 가질 수 없다*.

3. `대체키(Alternate key)`
- 후보키가 둘 이상일 때 *기본키를 제외한 나머지 후보키*, 보조키라고도 함

4. `슈퍼키(Super Key)`
- 한 릴레이션 내에 있는 *속성들의 집합으로 구성된 키*로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 집합과 동일한 값은 나타내지 않음
- 릴레이션을 구성하는 모든 튜플에 대해 *유일성은 만족하나 희소성은 만족시키지 못함*(어떤 속성끼리 묶던 중복값이 안나오고 서로 구별만 할 수 있으면 된다)

5. `외래키(Foreign Key)`
- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미함.
- 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 함. 

## 44. 정규화 과정
1. `비정규 릴레이션 -> 1NF`: 모든 도메인이 원자값이어야 함
2. `1NF -> 2NF`: 부분적 함수 종속을 제거
3. `2NF -> 3NF`: 이행적 함수 종속 제거
4. `3NF -> BCNF`: 결정자이면서 후보키가 아닌 것 제거
5. `BCNF -> 4NF`: 다치 종속 제거
6. `4NF -> 5NF`:  조인 종속성 이용

## 45. 무결성(Intergraty)
무결성이란 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미한다.

- `개체 무결성(Entity Integrity)`: 기본 테이블의 *기본키*를 구성하는 어떤 속성도 *null값이나 중복값을 가질 수 없음*
- `도메인 무결성(Domain Integrity)`: 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
- `참조 무결성(Referential Integrity)`: 외래키 값은 Null 이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 *참조할 수 없는 외래키 값을 가질 수 없다*는 규정
- `사용자 행위 무결성(User-Defined Integrity)`: 속성 값들이 사용자가 정의한 제약조건에 만족해야 함

## 46. 이행적 종속 관계
A->B이고 B->C일 때, A->C를 만족하는 관계

## 47. DML(Data Manipulation Language, 데이터 조작어)
- DML은 데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 **데이터를 실질적으로 처리**하는 데 사용하는 언어이다.
- 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.
1. `SELECT`: 테이블에서 조건에 맞는 튜플을 검색
2. `INSERT`: 테이블에 새로운 튜플을 삽입함
3. `DELETE`: 테이블에서 조건에 맞는 튜플을 삭제함
4. `UPDATE`: 테이블에서 조건에 맞는 튜플의 내용을 변경함

## 48. 트리거(Trigger)
트리거는 데이터베이스 시스템이서 데이터의 삽입/갱신/삭제 등의 이벤트가 발생할 때마다 관련 작업이 *자동으로 수행*되는 절차형 SQL이다.
- 트리거는 DB에 저장되며, 데이터 변경 및 무결성 유지, 로그 메세지 출력 등의 목적으로 사용함
- 트리거의 구문에는 *DCL(데이터 제어어)*을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류가 발생한다.
- 트리거에 오류가 있는 경우 *트리거가 처리하는 데이터에도 영향*을 미치므로 생성 시 주의가 필요함

## 49. 논리적 설게
현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 *논리적 자료 궂로 변환(Mapping)*하는 과정이다.

- 개념 세계의 데이터를 필드로 구성된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화한다.
- 개념적 설계가 개념 스키마를 설계하는 단계라면 논리적 설계에서는 *개념 스키마를 평가 및 정제*하고 DBMS에 따라 서로 다른 *논리적 스키마를 설계*한다.
- *트랜잭션의 인터페이스를 설계*한다.
- 관계형 데이터베이스라면 *테이블을 설계*하는 단계이다.

## 50. E-R 모델의 표현 방법
- 개념적 데이터 모델의 가장 대표적인 것으로, 1976년 피터 챈에 의해 제안되고 기본적인 구성 요소가 정립되었다.
- **개체 타입(Entity Type)**과 이들 간의 **관계 타입(RelationShip Type)**을 이용해 현실 세계를 개념적으로 표현
- 데이터를 *개체(Entity), 관계(Relationship), 속성(Attribute)* 으로 묘사함.
- 특정 DBMS를 고려하지는 않음
- 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있음

### 다이어그램의 종류
- `사각형`: 개체(Entity)
- `마름모`: 관계(Relationship)
- `타원`: 속성(Attribute)
- `이중 타원`: 다중값 속성(복합 속성)
- `밑줄 타원`: 기본키 속성
- `복수 타원`: 복합 속성(ex: 성명은 성과 이름으로 구성)
- `관계`: 1:1, 1:N, N:M 등의 개체 간 관계에 대한 대응수를 선 위에 기술함
- `선, 링크`: 개체 타입과 속성을 연결

## 51. 로킹 단위(Locking Granularity)
- 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기
- 데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있음
- 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아지고,
- 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 *오버헤드가 증가*하지만 *병행성 수준이 높아진다*.

## 52. 뷰(View)
사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 **가상 테이블**
- 저장장치 내에 *물리적으로 존재하지 않음*, 사용자에게는 있는 것으로 간주
- 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용됨

### 뷰의 특징
- 기본 테이블과 같은 형태의 구조 사용, 조작도 기본 테이블과 거의 같음
- 가상 테이블이기 때문에 물리적으로 구현되어 있지 않음
- 데이터의 *논리적 데이터 제공*
- 필요한 데이터만 뷰로 모아 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐
- 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적 기법으로 사용할 수 있다.
- **기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신 연산이 가능하다.** (연산에 제약이 따름)
- 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.
- 뷰를 정의할 때는 CREATE문, 제거할 때는 DROP문을 이용한다.
- *독립적인 인덱스를 가질 수 없다.*
- 뷰의 *정의를 변경할 수 없다.*

## 53. 관계형 데이터베이스 용어
1. `릴레이션(Relation)`: 데이터들을 표(Table)의 형태로 나타낸 것으로 구조를 나타내는 *릴레이션 스키마*와 실제 값들인 *릴레이션 인스턴스* 로 구성
2. `튜플(Tuple)`: 릴레이션을 구성하는 *각각의 행*, 속성의 모임, 파일 구조에서 레코드와 같은 의미. 튜플의 수를 *카디널리티(Cardinality)* 또는 기수, 대응수라고 함
3. `속성(Attribute)`: 데이터베이스를 구성하는 *가장 작은 논리적 단위*, 파일 구조성의 데이터 항목 또는 *데이터 필드*에 해당. 개체의 특성을 기술, 속성의 수를 *디그리(Degree)* 또는 차수라고 한다.
4. `도메인`: 하나의 애트리뷰트가 취할 수 있는 같은 타입의 *원자(Atomic) 값들의 집합*, 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는 데에도 이용된다.
> 성별 애트리뷰트의 도메인은 '남'과 '여'로, 그 외의 값은 입력할 수 없다.

## 54. 관계대수
- 관계대수는 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다.
- 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하는 언어로, *피연산자가 릴레이션이고, 결과도 릴레이션이다.*
- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.
- 관계대수에는 관계 데이터베이스에 적용하기 위해 특별히 개발한 *순수 관계 연산자*와 수학적 집합 이론에서 사용하는 *일반 집합 연산자*가 있다.

### 순수 관걔 연산자
1. `Select`
- 릴레이션에 속하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
- 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이므로 **수평 연산**이라고도 함
- *시그마(σ)*를 사용
> σ DNO=3 (EMPLOYEE) : EMPLOYEE 테이블에서 DNO가 3인 행을 도출

2. `Project`
- 주어진 릴레이션에서 **속성 리스트에 제시된 속성 값만을 추춘** 하여 새로운 릴레이션을 만드는 연산(**수직 연산**)이다. 단, 연산 결과에 **중복이 발생하면 중복이 제거됨**
- *파이(π)* 를 사용
> Π TITLE(EMPLOYEE) : EMPLOYEE 테이블에서 TITLE 열을 도출

3. `Join`
- 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
- *▷◁*를 사용

4. `Division`
-  **X⊃Y**인 두 개의 릴레이션 R(X) 와 R(Y)가 있을 때, R의 속성이 Y의 속성값을 모두 가진 튜플에서 Y가 가진 속성을 제외한 속성만을 구하는 연산
- *÷*를 사용

### 일반 집합 연산자
1. `합집합(UNION)`
- 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 **중복되는 튜플은 제거**
- 합집합의 카디널리티는 두 릴레이션 카디널리티(튜플의 수)의 합보다 크지 않음
- *∪*를 사용

2. `교집합(INTERSECTION)`
- 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산
- 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않음
- *∩*를 사용

3. `차집합(DIFFERENCE)`
- 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산
- 차집합의 카디널리티는 릴레이션 R의 카디널리티보다 크지 않음
- *ㅡ* 를 사용

4. `교차곱(CARTESIAN PRODUCT)`
- 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산
- 교차곱의 디그리(차수, 속성)는 *두 릴레이션의 디그리를 더한 것과 같고*, 카디널리티(튜플의 수)는 *두 릴레이션의 카디널리티를 곱한 것과 같음*
- *X* 를 사용

## 55. 분산 데이터베이스의 목표
1. `위치 투명성(Location Transparency)`: 액세스하려는 데이터베이스의 **실제 위치를 알 필요 없이** 단지 데이터베이스의 논리적인 명칭만으로 액세스 할 수 있음

2. `중복 투명성(Replication Transparency)`: 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행함

3. `병행 투명성(Concurrency Transparency)`: 분산 데이터베이스와 관련된 **다수의 트랜잭션들이 동시에 실행**되더라도 그 트랜잭션의 결과는 **영향을 받지 않는다.**

4. `장애 투명성(Failure Transparency)`: 트랜잭션, DBMS, 네트워크, 컴퓨터 **장애에도 불구하고 트랜잭션을 정확하게 처리함**

## 56. 후보키(Candidate Key)
- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 *기본키로 사용할 수 있는 속성*들
- 후보키는 릴레이션에 있는 모든 튜플에 대해서 *유일성*과 *희소성*을 만족시켜야 함

## 58. 데이터 제어 언어(DCL)
DCL은 데이터의 *보안, 무결성, 회복, 병행 수행 제어* 등을 정의하는 데 사용되는 언어이다.
- 데이터베이스 관리자가 *데이터 관리*를 목적으로 사용한다.

### DCL의 종류
1. `COMMIT`: 명령에 의해 수행된 결과를 **실제 물리적 디스크로 저장**하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려줌
2. `ROLLBACK`: 데이터베이스 조작 작업이 **비정상적으로 저장** 되었을 떄 **원래의 상태로 복구**함
3. `GRANT`: 데이터베이스 사용자에게 **사용 권한을 부여**
4. `REVOKE`: 데이터베이스 사용자의 **사용 권한을 취소**

## 59. DROP
DROP은 스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱스, 제약 조건 등을 제거하는 명령문이다.
```sql
DROP SCHEMA 스키마명 [CASCADE | RESTRICT];
DROP DOMAIN 도메인명 [CASCADE | RESTRICT];
DROP TABLE 테이블명 [CASCADE | RESTRICT];
DROP VIEW 뷰명 [CASCADE | RESTRICT];
DROP INDEX 인덱스명 [CASCADE | RESTRICT];
DROP CONSTRAINT 제약조건명;

DROP TABLE 학생 CASCADE; /*학생 테이블을 제거하며, 학생 테이블을 참조하는 모든 데이터를 함께 제거*/
```
- `CASCADE`: 제거할 요소를 *참조하는 다른 모든 개체를 함께 제거*함. 즉 주 테이블의 데이터 제거 시 각 외래키와 관계를 맺고 있는 모든 데이터를 제거하는 **참조 무결성 제약 조건**을 설정하기 위해 사용됨

- `RESTRICT`: 다른 개체가 제거할 요소를 참조할 때는 *제거를 취소*함

## 60. 트랜잭션의 특성
1. `Atomicity(원자성)`
- 트랜잭션의 연산은 *데이터베이스에 모두 반영되도록 완료(Commit) 되든지 전혀 반영되지 않도록 복귀(Rollback)되어야 함*
- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 **전부가 취소되어야 함**

2. `Consistency(일관성)`
- 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
- 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 수행 완료 후의 상태가 같아야 함

3.  `Isolation(독립성, 격리성, 순차성)`
- 둘 이상의 트랜잭션이 동시에 병행되는 경우, *어느 하나의 트랜잭션 실행 중에 다른 트랜잭션이 끼어들 수 없음*
- 수행중인 트랜잭션은 완전히 완료될 때까지 **다른 트랜잭션에서 수행 결과를 참조할 수 없음**

4. `Durability(영속성, 지속성)`
- 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

## 61. UNIX 쉘(Shell)
- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 *명령어 해석기*
- 시스템과 사용자 간의 *인터페이스 담당*
- DOS의 *COMMAND.COM*과 같은 기능 수행
- **주기억장치에 상주하지 않고** 명령어가 포함된 파일 형태로 존재하며, **보조기억장치**에서 교체 처리가 가능함
- *파이프라인 기능을 지원*하고 입/출력 재지정을 통해 **입력과 출력의 방향을 변경**할 수 있음
- 공용 Shell(`Bourne Shell`, `C Shell`, `Korn Shell`)이나 사용자 자신이 만든 Shell을 사용 가능

## 62. 전송 계층의 주요 프로토콜
1. `TCP(Transmission Control Protocol)`
- *양방향 연결*(Full Duplex Connection)형 서비스를 제공함
- *스트림 위주의 전달*(패킷 단위)를 함
- *신뢰성 있는 경로를 확립*하고 메세지 전송을 감독함
- *순서 제어, 오류 제어, 흐름 제어* 기능을 함
- TCP 프로토콜의 헤더는 기본적으로 20Byte에서 60Byte까지 사용할 수 있는데, 선택적으로 40Byte를 더 추가할 수 있으므로 최대 100Byte까지 크기를 확장할 수 있음

2. `UDP(User Datagram Protocol)`
- 데이터 전송 전에 *연결을 설정하지 않는 비연결형 서비스*를 제공
- TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로 *오버헤드가 적고, 흐름 제어나 순서 제어가 없어 전송 속도가 빠름*
- **실시간 전송에 유리**히먀, 신리성보다는 속도가 중요시되는 네트워크에서 사용됨

3. `RTCP (Real-time Control Protocol)`
- RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜
- 세션에 참여한 각 참여자들에게 주기적으로 제어 정보를 제공함

## 63. C언어 비트 연산자
비트 연산자는 비트별(0,1)로 연산하여 결과를 얻는 연산자이다.
- `&`: *and*, 모든 비트가 1일 때만 1
- `^`: *xor*, 모든 비트가 같으면 0, 하나라도 다르면 1
- `|`: *or*, 모든 비트 중 한 비트라도 1이라면 1
- `~`: *not*, 각 비트의 부정. 0이면 1,  1이면 0
- `<<`: *왼쪽 시프트*, 비트를 왼쪽으로 이동
- `>>`: *오른쪽 시프트*, 비트를 오른쪽으로 이동