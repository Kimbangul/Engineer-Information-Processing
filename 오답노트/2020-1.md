## 1. GoF(Gang of Four)의 디자인 패턴
GoF의 디자인 패턴은 유형애 따라 **생성** 패턴 5개, **구조** 패턴 5개, **행위** 패턴 11개 총 23개의 패턴으로 구성된다.

1. `생성 패턴(Creation Pattern)`
- 객체의 *생성과 참조 기능을 캡슐화* 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해준다.
- 추상 팩토리(Abstract Factory), 빌더(Builder), 팩토리 메소드(Factory Method), 프로토타입(Prototype), 싱글톤(Singleton)

2. `구조 패턴(Structural Pattern)`
- *클래스나 객체들을 조합*하여 더 큰 구조로 만들 수 있게 해주는 패턴으로 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.
- 어댑터(Adapter), 브리지(bridge), 컴포지트(Composite), 데코레이터(Decorator), 퍼싸드(Facade), 플라이웨이트(Flyweight), 프록시(Proxy)

3. `행위 패턴(Behavioral Pattern)`
- 클래스나 객체들이 서로 *상호작용*하는 방법이나 *책임 분배 방식*을 정의하는 패턴으로, 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화할 수 있도록 도와준다.
- 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(interpreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)

## 2. 객체지향 방법론
1. `속성`: 객체를 나타내는 성질, 값, 데이터
2. `메소드`: 객체의 속성을 이용한 일련의 동작들
3. `캡슐화`: 데이터와 해당 데이터의 처리 기능을 하나로 묶어냄, 재사용이 용이
4. `정보은닉`: 다른 객체에게 자신의 정보를 숨김
5. `추상화`: 객체의 공통적인 속성을 상위 객체로 도출
6. `상속성`: 상위 객체의 속성을 하위 객체가 물려받아 사용
7. `다형성`: 하나의 수행 방법으로 여러 형태의 기능을 수행
> '+' 연산자의 경우 숫자 클래스에서는 덧셈, 문자 클래스에서는 문자열의 연결 기능으로 사용된다.
8. `클래스`: 공통된 속성과 연산(행위)를 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미. 객체지향 프로그램에서 *데이터를 추상화*하는 단위이다.

## 3. 객체의 연관성
연관성은 두 개 이상의 객체(클래스)들이 상호 참조하는 관계를 말하며 종류는 다음과 같다.

1. `is number of`: 연관화
- 두 개 이상의 객체가 상호 관련되어 있음을 의미함

2. `is instance of`: 분류화
- 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것

3. `is part of`: 집단화
- 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것

4. `is a`
- *일반화*: 공통적인 성질들로 추상화한 상위 객체를 구성하는 것(추상화)
- *특수화/상세화*: 상위 객체를 구체화하여 하위 객체를 구성하는 것

## 4. 객체지향 분석의 방법론
- `Rumbaugh(럼바우) 방법`: 가장 일반적으로 사용되는 방법으로, 분석 활동을 *객체 모델, 동적 모델, 기능 모델* 로 나누어 수행하는 방법

- `Booch(부치) 방법`: *미시적(Micro)* 개발 방법과 *거시적(Macro)* 개발 프로세스를 모두 사용하는 분석 방법으로, <u>클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의</u>함

- `Jacobson 방법`: *Use Case*를 강조하여 사용하는 분석 방법

- `Coad와 Yourdon 방법`: *E-R 다이어그램*을 사용하여 객체의 행위를 모델링하며, <u>객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의</u> 등의 과정으로 구성하는 기법

- `Wirfs-Brock 방법`: 분석과 설계 간의 구분이 없고, *고객 명세서를 평가* 해서 실제 작업까지 연속적으로 수행하는 기법

## 5. 코드의 종류
1. `순차 코드(Sequence Code)`
- 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 *일련번호를 부여* 하는 방법으로, 순서 코드 또는 일련번호 코드라고도 함.

2. `블록 코드(Block Code)`
- 코드화 대상 항목 중에서 *공통성이 있는 것끼리 블록으로 구분*하고 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 함
> 1001~1100: 총무부, 1101~1200: 영업부

3. `10진 코드(Decimal Code)`
- 코드화 대상 항목을 *0~9까지 10진 분할*하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 함
>  1000: 공학, 1100: 소프트웨어 공학, 1110: 소프트웨어 설계

4. `그룹 분류 코드(Group Classfication Code)`
- 코드화 대상 항목을 일정 기준에 따라 *대분류, 중분류, 소분류* 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법
> ex: 1-10-001: 본사-총무부-인사계, 2-01-001: 지사-총무부-인사계

5. `연상 코드(Memoric Code)`
- 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법
> TV-40: 40인치 TV, L-15-220: 15W 220V의 램프

6. `표의 숫자 코드(Significant Digit Code)`
- 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 *물리적 수치를 그대로 코드에 적용*시키는 방법으로, 유효 숫자 코드라고도 함
> 120-720-1500: 두께x폭x길이가 120x720x1500인 강판

7. `합성 코드(Combined Code)`
- 필요한 기능을 하나의 코드로 수행하기 어려운 경우 *2개 이상의 코드를 조합*하여 만드는 방법
> 연상 코드 + 순차 코드 => KE-711: 대한항공 711기, AC-253: 에어캐나다 253기

## 6. 플랫폼의 성능 측정 기준
- **가용성(Availability)**: 필요할 때 즉시 사용 가능한 정도(사용 가능도)
- **응답 시간(Response Time)**: 명령에 반응하는 시간(*처리 시간과 다름*)
- **정확성(Accuracy)**: 처리 결과가 기대한 값과 비교해서 정확한지 측정
- **사용률(Utilization)**: 데이터 처리에 시스템 자원을 사용하는 정도

## 7. 자료 사전
- `=`: 자료의 정의, *~로 구성되어 있다(is composed of)*
- `+`: 자료의 연결, *그리고(and)*
- `()`: 자료의 생략, *생략 가능한 자료(Optional)*
- `[|]`: 자료의 선택, *또는(or)*
- `{}`: 자료의 반복 *(Interation of)*
> { }n : n번 이상 반복 / { } nm : m 이상 n 이하로 반복
- `* *`: 자료의 설명 *주석(Comment)*

## 8. 요구사항 검증 방법
요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 경함 여부를 검토 담당자들이 수작업으로 분석

1. `동료검토(Peer Review)`
- 요구사항 명세서 *작성자가 명세서 내용을 직접 설명*하고 동료들이 이를 들으면서 결함을 발견

2. `워크스루(Walk Through)`
- 검토 회의 전 *요구사항 명세서를 미리 배포*하여 사전 검토한 후 *짧은 검토 회의* 를 통해 결함 발견

3. `인스펙션(Inspection)`
- 요구사항 *명세서 작성자를 제외한 다른 검토 전문가*들이 요구사항 명세서를 확인하면서 결함 발견

## 9. CASE의 주요 기능
CASE(Computer Aided Softsare Engineering)는 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 *컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화*하는 것이다.

- `주요 기능`: 소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원 등 

## 10. XP(eXtreme Programming)의 5가지 가치
- 의사소통, 단순성, 용기, 존중, 피드백

## 11. DBMS 분석 시 고려사항
- 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용

## 12. HIPO(Hierachy Input Process Output)
-  시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로, *입력, 처리, 출력*의 기능을 나타냄
- *하향식 소프트웨어 개발*을 위한 문서화 도구
- 체계적인 문서 관리 가능
- 기호, 도표 등을 사용하므로 이해가 쉬움
- 기능과 자료의 의존 관계를 동시에 표현 가능
- 변경, 유지보수가 용이
- `HIPO Chart`: 시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것

### HIPO 차트의 종류
- `가시적 도표(도식 목차)`: 시스템의 전체적인 기능과 흐름을 보여주는 계층(Tree) 구조도
- `총체적 도표(총괄도표, 개요도표)`: 프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표
- `세부적 도표(상세 도표)`: 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

## 13. UI(사용자 인터페이스) 설계 원칙
1. `직관성`: 누구나 쉽게 이해하고 사용할 수 있어야 한다.
2. `유효성`: 사용자의 목적을 정확하고 완벽하게 달성해야 한다.
3. `학습성`: 누구나 쉽게 배우고 익힐 수 있어야 한다.
4. `유연성`: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.

## 14. 럼바우(Rumbaugh)의 객체지향 분석 절차
1. `객체 모델링`
정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 **속성과 연산 식별 및 객체들 간의 관계를 규정**하여 *객체 다이어그램* 으로 표시하는 것

2. `동적 모델링`
*상태 다이어그램(상태도)*을 이용하여 시간의 흐름에 따른 객체들 간의 **제어 흐름, 동작 순서** 등의 동적인 행위를 표현하는 모델링

3. `기능 모델링`
*자료 흐름도(DFD)* 를 이용하여 다수의 프로세스들간의 자료 흐름을 중심으로 **처리 과정** 을 표현한 모델링

## 15. 데이터 흐름도(DFD)의 구성 요소
- 프로세스(Process), 자료 저장소(Data Store), 자료 흐름(Flow), 단말(Terminator)

## 16. UML(Unified Modeling Language)
스테레오 타입은 UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용되며, *길러멧*이라고 부르는 겹화살괄호(`<<>>`)에 표현할 형태를 기술한다.

- `<<include>>`: 연결된 다른 UML요소에 대해 포함 관계에 있는 경우 
- `<<extend>>`: 연결된 다른 UML요소에 대해 확장 관계에 있는 경우
- `<<interface>>`: 인터페이스를 정의
- `<<exception>>`: 예외를 정의
- `<<constructor>>`: 생성자 역할을 수행

## 17. 미들웨어(Middleware)
미들웨어는 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어이다.

1. `DB(DataBase)`
- 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어
- DB를 이용하여 시스템을 구축하는 경우 보통 **2-Tier** 아키텍처라고 함

2. `RPC(Remote Procedure Call)`
- 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어

3. `MOM(Message Oriented Middleware)`(메시지 지향 미들웨어)
- 메세지 기반의 비동기형 메세지를 전달하는 방식의 미들웨어
- 온라인 업무보다는 **이기종 분산 데이터 시스템의 데이터 동기**를 위해 많이 사용됨

4. `TP-Monitor(Transaction Processing Monitor)`
- 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 *트랜잭션을 처리 및 감시*하는 미들웨어
- 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용됨

5. `ORB(Object Request Broker)`(객체 요청 브로커)
- *객체 지향* 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어
- 최근에는 TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음

6. `WAS(Web Application Server)`(웹 애플리케이션 서버)
- 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용
- 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어

## 18. 요구사항 분석
- 사용자 요구의 *타당성을 조사*하고 *비용과 일정에 대한 제약을 설정*한다.
- 사용자의 *요구를 정확하게 추출하여 목표*를 정하고, 어떤 방식으로 해결할 것인지를 결정
- 사용자의 요구사항을 *정확하고 일관성 있게 분석하여 문서화* 해야 한다.
- `UML(Unified Modeling Language)`, `자료 흐름도(DFD)`, `자료 사전(DD)`, `소단위 명세서(Mini-Spec)`, `개체 관계도(ERD)`, `상태 전이도(STD)`, `제어 명세서` 등의 도구를 이용한다.

## 19. 공통 모듈 구현 시 준수해야 할 명세 기법
여러 프로그램에서 공통적으로 사용할 수 있는 모듈 구현 시, 다음의 명세 기법을 준수하여야 한다.

1. `정확성`: 시스템 구현 시 *해당 기능이 필요*하다는 것을 알 수 있도록 정확히 작성
2. `명확성`: 해당 기능을 *이해할 때 중의적으로 해석되지 않도록* 명확히 작성
3. `완전성`: 시스템 *구현을 위해 필요한 모든 것*을 기술
4. `일관성`: 공통 기능들 간 *상호 충돌이 발생하지 않도록* 작성
5. `추적성`: 기능에 대한 요구사항이 *출처, 관련 시스템 등의 관계를 파악할 수 있도록* 작성

## 20. Structural Diagram(구조적 다이어그램)의 종류
1. 클래스 다이어그램
- 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현
- 시스템의 구조를 파악하고 구조상의 문제점을 도출할 수 있음

2. 객체 다이어그램
- 클래스에 속한 사물(객체)들, 즉 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현
- *럼바우 객체지향 분석 기법* 에서 객체 모델링에 활용됨

3. 컴포넌트 다이어그램
- 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현함
- *구현 단계에서 사용*

4. 배치 다이어그램
- 결과물, 프로세스, 컴포넌트 등 **물리적 요소들의 위치를 표현**
- *노드와 의사소통(통신) 경로*로 표현
- *구현 단계에서 사용*

5. 복합체 구조 다이어그램
- 클래스나 컴포넌트가 복합 구조를 갖는 경우 *그 내부 구조를 표현*

6. 패키지 다이어그램
- 유스케이스나 클래스 등의 **모델 요소들을 그룹화**한 패키지들의 관계를 표현

## 21. 경계 값 분석 기법
- 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법

## 22. 트리 관련 용어
1. `노드(Node)`: 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(branch)를 합친 것
2. `근 노드(Root Node)`: 트리의 맨 위에 있는 노드
3. `디그리(Degree, 차수)`: 각 노드에서 뻗어 나온 가지의 수
4. `단말 노드(Terminal Node)` = 잎 노드(Leaf Node): 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
5. `자식 노드(Son Node)`: 어떤 노드에 연결된 다음 레벨의 노드들
6. `부모 노드(Parent Node)`: 어떤 노드에 연결된 이전 레벨의 노드들
7. `형제 노드(Brother Node)`: 동일한 부모를 갖는 노드들
8. `트리의 디그리`: **노드들의 디그리 중에서 가장 많은 수**

## 23. 블랙박스 테스트의 종류
1. `동치 분할 검사(Equivalence Partitioning Testing)`
- *입력 자료에 초점*을 맞춰 테스트 케이스(동치 클래스)를 만들고 검사하는 방법으로, 동등 분할 기법이라고도 함
- 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 *균등하게* 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법

2. `경계값 분석(Boundary value Analysis)`
- 입력 자료에만 치중한 동치 분할 기법을 보완
- 입력 조건의 중간값보다 *경계값*에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 *경계값을 테스트 케이스로 선정*하여 검사

3. `원인-효과 그래프 검사(Cause-Effect Graphinf Testing)`
- 입력 데이터 간의 관계와 출력에 영향을 미치는 *상황을 체계적으로 분석*한 후, 효용성이 높은 테스트 케이스를 선정

4. `오류 예측 검사(Error Guessing)`
- 과거의 경험이나 확인자의 감각으로 테스트
- 다른 블랙 박스 테스트 기법으로는 찾아낼 수 없는 오류를 찾아내는 일련의 보충적 검사 기법이며, 데이터 확인 검사라고도 함

5. `비교 검사(Comparision Testing)`
- *여러 버전의 프로그램에 동일한 테스트 자료를 제공*하여 동일한 결과가 출력되는지 테스트

## 24. 테스트 드라이버와 스텁의 차이점
1. `드라이버(Driver)`
- 테스트 대상의 *하위 모듈을 호출*하는 도구로, 매개변수를 전달하고 모듈 테스트 수행 후의 결과를 도출
- 상향식 테스트에서 사용
- 이미 존재하는 하위 모듈과 *존재하지 않는 상위 모듈* 간의 인터페이스 역할을 함

2. `스텁(Stub)`
- 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈
- 상위 모듈은 있지만 하위 모듈이 없는 경우 *하위 모듈을 대체*
- 하향식 테스트에서 사용, 시험용 모듈이기 때문에 일반적으로 드라이버보다 작성하기 쉬움

## 25. ISO/ISE 9126 - 소프트웨어 품질 특성과 평가를 위한 표준 지침
1. `기능성`: 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부
- 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성

2. `신뢰성`: 소프트웨어가 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는 정도
- 성숙성, 고장 허용성, 회복성

3. `사용성`: 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대해 사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도
- 이해성, 학습성, 운용성, 친밀성

4. `효율성`: 사용자가 요구하는 기능을 할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도
- 시간 효율성, 자원 효율성

5. `유지 보수성`: 환경의 변화 또는 새로운 요구사항 발생 시 소프트웨어를 개선하거나 확장할 수 있는 정도
- 분석성, 변경성, 안정성, 시험성

6. `이식성`: 소프트웨어가 다른 환경에도 얼마나 쉽게 적용할 수 있는지 정도
- 적용성, 설치성, 대체성, 공존성

## 26. 애플리케이션 테스트 관련 용어
1. `결함 집중(Detect Clustering)`: 대부분의 결함이 소수의 특정 모듈에 집중해서 발생하는 것
2. `파레토의 법칙(Pareto Principle)`: 테스트로 발견된 80%의 오류는 20%의 모듈에서 발견됨
3. `살충제 패러독스(Pesricide Paradox)`: 같은 테스트 케이스를 가지고, 테스트를 계속해서 반복하는 경우 어느 시점부터는 더 이상 결함을 발견할 수 없음
4. `오류-부재의 궤변(Absence of Errors Fallacy)`: 소프트웨어의 결함을 모두 분석해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없음

## 27. DRM(디지털 저작권 관리)의 기술 요소
- `암호화(Encryption)`: 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술
- `키 관리(Key Management)`: 콘텐츠를 암호화한 키에 저장 및 분배 기술
- `암호화 파일 생성(Packager)`: 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
- `식별 기술(idenfication)`: 콘텐츠에 대한 식별 체계 표현 기술
- `저작권 표현(Right Expression)`: 라이선스의 내용 표현 기술
- `정책 관리(Policy Management)`: 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
- `크랙 방지(Tamper Resitanse)`: 크랙에 의한 콘텐츠 사용 방지 기술
- `인증(Authntication)`: 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

### 28. 인터페이스 보안 기능 적용
1. 네트워크 영역
- 인터페이스 송/수신간 스니핑 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 *트래픽에 대한 암호화*를 설정함
- 암호화는 인터페이스 아키텍처에 따라 *IPSec, SSL, S-HTTP*등의 다양한 방식으로 적용함

2. 애플리케이션 영역
- *소프트웨어 개발 보안 가이드*를 참조하여 애플리케이션 코드 상의 보안 취약점을 보완

3. 데이터베이스 영역
- 데이터베이스, 스키마, 엔티티의 접근 권한과 프로시저, 트리거 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용

4. IPSec(IP Security): 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜로, 암호화 수행시 양방향 암호화를 지원함

## 29. 인터페이스 구현 검증 도구
1. `xUnit`
- 같은 테스트 코드를 여러 번 작성하지 않게 도와주고, 테스트마다 예상 결과를 기억할 필요가 없게 하는 자동화된 해법을 제공하는 단위 테스트 프레임워크
- Smalltalk에 처음 적용되어 SUnit 이라는 이름이었으나 Java용의 JUnit, C++ 용의 CppUnit, .NET용의 NUnit, Http용의 HttpUnit 등 *다양한 언어에 적용*되면서 xUnit 으로 통칭되고 있음

2. `STAF`
- 서비스 호출 및 *컴포넌트 재사용* 등 다양한 환경을 지원하는 테스트 프레임워크
- 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성할 수 있도록 지원
- 분산 소프트웨어의 경우 각 분산 환경에 설치된 *데몬이 프로그램 테스트에 대한 응답을 대신*하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성함.

3. `FITNesse`
- *웹 기반* 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크

4. `NTAF`
- FitNess의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN의 테스트 자동화 프레임워크

5. `Selenium`
- 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크

6. `watir`
- *Ruby*를 사용하는 애플리케이션 테스트 프레임워크

## 30. SW 패키징 도구 활용 시 고려 사항
- 사용자의 시스템 환경, 즉 운영체제(OS), CPU, 메모리 등에 필요한 *최소 환경을 정의*한다.
- UI는 사용자가 눈으로 직접 확인할 수 있도록 *시각적인 자료와 함께 제공*하고 *메뉴얼과 일치*시켜 패키징한다.
- 소프트웨어는 단순히 패키징하여 배포하는 것으로 끝나는 것이 아니라 **하드웨어와 함께 관리**될 수 있도록 *Managed Service*형태로 제공하는 것이 좋다.
- 사용자에게 배포되는 소프트웨어이므로 내부 콘텐츠에 대한 *암호화 및 보안*을 고려한다.
- 다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관리) 연동을 고려한다.
- 제품 소프트웨어 종류에 *적합한 알고리즘*을 적용한다.

## 31. 소프트웨어 형상 관리
형상 관리(SCM: Software Configuration Management)는 소프트웨어의 개발 과정에서 *소프트웨어의 변경 사항을 관리하기 위해* 개발된 일련의 활동이다.

## 32. White Box Testing
화이트박스 테스트는 모듈의 원시 코드를 오픈 시킨 상태에서 원시 코드의 *논리적인 모든 경로를 테스트* 하여 테스트 케이스를 설계하는 방법이다.

- 모듈 안 작동을 **직접 관찰** 한다.
- 원시 코드(모듈)의 **모든 문장을 한 번 이상 실행**한다.
- 프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행함으로서 **논리적 경로를 제어한다.**

### 화이트박스 테스트의 종류
1. `기초 경로 검사(Base Path Testing)`: 대표적인 화이트박스 테스트 설계 기법, 절차적 설계의 **논리적 복잡성을 측정**할 수 있게 해 줌, 실행 경로의 기초를 정의하는 데 지침으로 사용

2. `제어 구조 검사(Control Structure Testing)`
- 조건 검사(Condition Testing): 프로그램 모듈 내에 있는 **논리적 조건을 테스트**
- 루프 검사(Loop Testing): 프로그램의 **반복 구조에 초점을 맞춰** 테스트 
- 데이터 흐름 검사(Data Flow Testing): **변수의 정의**와 **변수 사용의 위치**에 초점을 맞춰 테스트


## 33. 외계인 코드(Alien Code)
아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드

## 34. 트리의 운행(순회)법
```
  A
 /\
B  C
```
1. `Preorder 운행(전위 순회)`: *Root-> Left -> Right* / A -> B -> C
2. `Inorder 운행(중위 순회)`: *Left -> Root -> Right* / B -> A -> C
3. `Postorder 운행(후위 순회)`: *Left -> Right -> Root* / B -> C -> A

## 35, 36. 빅오 표기법
1. `O(1)`: 입력값(n)에 관계 없이 일정하게 문제 해결애 하나의 단계만을 가짐. (스택의 삽입(Push), 삭제(Pop))
2. `O(log2n)`: 문제 해결에 필요한 단계가 입력값(n) 또는 조건에 의해 *감소*함. (이진 트리, 이진 검색)
3. `O(n)`: 문제 해결에 필요한 단계가 입력값(n)과 1:1의 관계를 가짐 (for문)
4. `O(nlog2n)`: 문제 해결에 필요한 단계가 *n(log2n)*번만큼 수행됨. (*힙 정렬, 2-Way 합병 정렬*)
5. `O(n^2)`: 문제 해결에 필요한 단계가 입력값(n)의 제곱만큼 수행됨(삽입 정렬, 쉘 정렬, 선택 정렬, 버블 정렬, 퀵 정렬)
6. `O(2^n)`: 문제 해결에 필요한 단계가 2의 입력갑(n)제곱만큼 수행됨(*피보나치 수열*)

## 37. ISO/IEC 9126 '기능성' 의 하위 특성
- 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성

## 38. EAI(Enterprise Application Integration)
EAI는 *기업 내 각종 애플리케이션 또는 플랫폼* 간의 *정보 전달, 연계, 통합 등 상호 연동*이 가능하게 해 주는 솔루션으로, 비즈니스 간 통합 및 연계성을 증대시켜 효율성과 각 시스템 간의 확장성을 높여 준다.

### EAI의 구축 유형
1. `Point-to-Point`
- 가장 기본적인 통합 방식, 애플리케이션을 *1:1*로 연결함. 
- 변경 및 재사용이 어ㅓㅕ움

2. `Hub & Spoke`
- 단일 접점인 허브 시스템을 통해 데이터를 전송하는 *중앙 집중형 방식*
- 확장 및 유지 보수 용이
- 허브 장애 발생 시 *시스템 전체에 영향을 미침*

3. `Message Bus(ESB 방식)`
- 애플리케이션 사이에 *미들웨어*를 두어 처리하는 방식
- 확장성이 뛰어나며 *대용량 처리가 가능함*

4. `Hybrid`
- *Hub&Spoke*와 *Message Bus*의 통합 방식
- 그룹 내에서는 Hub&Spoke 방식을, 그룹 간에는 Message Bus 방식을 사용
- 필요한 경우, 한 가지 방식으로 EAI 구현이 가능함
- *데이터 병목 현상을 최소화할 수 있음*

## 39. 소스 코드 품질 정적 분석 도구
- 작성한 소스 코드를 *실행하지 않고* 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구
- 비교적 애플리케이션 개발 초기의 결함을 찾는 데 사용되고, 개발 완료 시점에서는 개발된 소스 코드의 품질을 검증하는 차원에서 사용
- *자료 흐름이나 논리 흐름을 분석* 하여 비정상적인 패턴 감지
- 동적 분석 도구로는 발견하기 어려운 결함을 찾아내고, 소스 코드에서 **코딩의 복잡도, 모델 의존성, 불일치성** 등을 분석 가능
- 종류: `pmd`, `cppcheck`, `sonarCube`, `checkstyle`, `ccm`, `cobertura`

## 40. 반정규화 - 중복 테이블 추가
1. `테이블 통합`
- 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 작업의 효율성을 향상시킬 수 있음
- `집계 테이블 추가`, `진행 테이블 추가`, `특정 부분만을 포함하는 테이블의 추가`

## 41. DDL (Data Define Language, 데이터 정의어)
DDL은 스키마, 도메인, 테이블, 뷰, 인덱스를 정의하거나 변경 또는 삭제할 때 사용하는 언어이다.
- *논리적 데이터 구조와 물리적 데이터 구조의 사상을 정의*한다.
- 데이터베이스 *관리자나 설계자*가 사용한다.

### DDL의 유형
1. `CREATE`: 스키마, 도메인, 테이블, 뷰, 인덱스를 정의함
2. `ALTER`: 테이블에 대한 정의 변경에 사용
3. `DROP`: 스키마, 도메인, 테이블, 뷰, 인덱스를 삭제함

## 43. 키(Key)
키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트를 말한다.

1. `후보키(Candidate Key)`
- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기  위해 사용하는 속성들의 부분집합, 즉 *기본키로 사용할 수 있는 속성*
- 후보키는 릴레이션에 있는 모든 튜플에 대해 *유일성*과 *희소성*을 만족시켜야 함

2. `기본키(Primary Key)`
- 후보키 중에서 특별히 선정된 주키(Main Key)로 *중복된 값을 가질 수 없음*
- 한 릴레이션에서 특정 튜플을 *유일하게 구분*할 수 있는 속성
- 기본키는 *NULL 값을 가질 수 없다*.

3. `대체키(Alternate key)`
- 후보키가 둘 이상일 때 *기본키를 제외한 나머지 후보키*, 보조키라고도 함

4. `슈퍼키(Super Key)`
- 한 릴레이션 내에 있는 *속성들의 집합으로 구성된 키*로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 집합과 동일한 값은 나타내지 않음
- 릴레이션을 구성하는 모든 튜플에 대해 *유일성은 만족하나 희소성은 만족시키지 못함*(어떤 속성끼리 묶던 중복값이 안나오고 서로 구별만 할 수 있으면 된다)

5. `외래키(Foreign Key)`
- 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미함.
- 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 함. 

## 44. 정규화 과정
1. `비정규 릴레이션 -> 1NF`: 모든 도메인이 원자값이어야 함
2. `1NF -> 2NF`: 부분적 함수 종속을 제거
3. `2NF -> 3NF`: 이행적 함수 종속 제거
4. `3NF -> BCNF`: 결정자이면서 후보키가 아닌 것 제거
5. `BCNF -> 4NF`: 다치 종속 제거
6. `4NF -> 5NF`:  조인 종속성 이용

## 45. 무결성(Intergraty)
무결성이란 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미한다.

- `개체 무결성(Entity Integrity)`: 기본 테이블의 *기본키*를 구성하는 어떤 속성도 *null값이나 중복값을 가질 수 없음*
- `도메인 무결성(Domain Integrity)`: 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
- `참조 무결성(Referential Integrity)`: 외래키 값은 Null 이거나 참조 릴레이션의 기본키 값과 동일해야 한다. 즉 릴레이션은 *참조할 수 없는 외래키 값을 가질 수 없다*는 규정
- `사용자 행위 무결성(User-Defined Integrity)`: 속성 값들이 사용자가 정의한 제약조건에 만족해야 함

## 46. 이행적 종속 관계
A->B이고 B->C일 때, A->C를 만족하는 관계

## 47. DML(Data Manipulation Language, 데이터 조작어)
- DML은 데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 **데이터를 실질적으로 처리**하는 데 사용하는 언어이다.
- 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.
1. `SELECT`: 테이블에서 조건에 맞는 튜플을 검색
2. `INSERT`: 테이블에 새로운 튜플을 삽입함
3. `DELETE`: 테이블에서 조건에 맞는 튜플을 삭제함
4. `UPDATE`: 테이블에서 조건에 맞는 튜플의 내용을 변경함

## 48. 트리거(Trigger)
트리거는 데이터베이스 시스템이서 데이터의 삽입/갱신/삭제 등의 이벤트가 발생할 때마다 관련 작업이 *자동으로 수행*되는 절차형 SQL이다.
- 트리거는 DB에 저장되며, 데이터 변경 및 무결성 유지, 로그 메세지 출력 등의 목적으로 사용함
- 트리거의 구문에는 *DCL(데이터 제어어)*을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류가 발생한다.
- 트리거에 오류가 있는 경우 *트리거가 처리하는 데이터에도 영향*을 미치므로 생성 시 주의가 필요함

## 49. 논리적 설게
현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 *논리적 자료 구조로 변환(Mapping)*하는 과정이다.

- 개념 세계의 데이터를 필드로 구성된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화한다.
- 개념적 설계가 개념 스키마를 설계하는 단계라면 논리적 설계에서는 *개념 스키마를 평가 및 정제*하고 DBMS에 따라 서로 다른 *논리적 스키마를 설계*한다.
- *트랜잭션의 인터페이스를 설계*한다.
- 관계형 데이터베이스라면 *테이블을 설계*하는 단계이다.

## 50. E-R 모델의 표현 방법
- 개념적 데이터 모델의 가장 대표적인 것으로, 1976년 피터 챈에 의해 제안되고 기본적인 구성 요소가 정립되었다.
- **개체 타입(Entity Type)**과 이들 간의 **관계 타입(RelationShip Type)**을 이용해 현실 세계를 개념적으로 표현
- 데이터를 *개체(Entity), 관계(Relationship), 속성(Attribute)* 으로 묘사함.
- 특정 DBMS를 고려하지는 않음
- 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있음

### 다이어그램의 종류
- `사각형`: 개체(Entity)
- `마름모`: 관계(Relationship)
- `타원`: 속성(Attribute)
- `이중 타원`: 다중값 속성(복합 속성)
- `밑줄 타원`: 기본키 속성
- `복수 타원`: 복합 속성(ex: 성명은 성과 이름으로 구성)
- `관계`: 1:1, 1:N, N:M 등의 개체 간 관계에 대한 대응수를 선 위에 기술함
- `선, 링크`: 개체 타입과 속성을 연결

## 51. 로킹 단위(Locking Granularity)
- 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기
- 데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있음
- 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아지고,
- 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 *오버헤드가 증가*하지만 *병행성 수준이 높아진다*.

## 52. 뷰(View)
사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 **가상 테이블**
- 저장장치 내에 *물리적으로 존재하지 않음*, 사용자에게는 있는 것으로 간주
- 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용됨

### 뷰의 특징
- 기본 테이블과 같은 형태의 구조 사용, 조작도 기본 테이블과 거의 같음
- 가상 테이블이기 때문에 물리적으로 구현되어 있지 않음
- 데이터의 *논리적 데이터 제공*
- 필요한 데이터만 뷰로 모아 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐
- 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적 기법으로 사용할 수 있다.
- **기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신 연산이 가능하다.** (연산에 제약이 따름)
- 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.
- 뷰를 정의할 때는 CREATE문, 제거할 때는 DROP문을 이용한다.
- *독립적인 인덱스를 가질 수 없다.*
- 뷰의 *정의를 변경할 수 없다.*

## 53. 관계형 데이터베이스 용어
1. `릴레이션(Relation)`: 데이터들을 표(Table)의 형태로 나타낸 것으로 구조를 나타내는 *릴레이션 스키마*와 실제 값들인 *릴레이션 인스턴스* 로 구성
2. `튜플(Tuple)`: 릴레이션을 구성하는 *각각의 행*, 속성의 모임, 파일 구조에서 레코드와 같은 의미. 튜플의 수를 *카디널리티(Cardinality)* 또는 기수, 대응수라고 함
3. `속성(Attribute)`: 데이터베이스를 구성하는 *가장 작은 논리적 단위*, 파일 구조성의 데이터 항목 또는 *데이터 필드*에 해당. 개체의 특성을 기술, 속성의 수를 *디그리(Degree)* 또는 차수라고 한다.
4. `도메인`: 하나의 애트리뷰트가 취할 수 있는 같은 타입의 *원자(Atomic) 값들의 집합*, 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는 데에도 이용된다.
> 성별 애트리뷰트의 도메인은 '남'과 '여'로, 그 외의 값은 입력할 수 없다.

## 54. 관계대수
- 관계대수는 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다.
- 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하는 언어로, *피연산자가 릴레이션이고, 결과도 릴레이션이다.*
- 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.
- 관계대수에는 관계 데이터베이스에 적용하기 위해 특별히 개발한 *순수 관계 연산자*와 수학적 집합 이론에서 사용하는 *일반 집합 연산자*가 있다.

### 순수 관걔 연산자
1. `Select`
- 릴레이션에 속하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
- 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것이므로 **수평 연산**이라고도 함
- *시그마(σ)*를 사용
> σ DNO=3 (EMPLOYEE) : EMPLOYEE 테이블에서 DNO가 3인 행을 도출

2. `Project`
- 주어진 릴레이션에서 **속성 리스트에 제시된 속성 값만을 추춘** 하여 새로운 릴레이션을 만드는 연산(**수직 연산**)이다. 단, 연산 결과에 **중복이 발생하면 중복이 제거됨**
- *파이(π)* 를 사용
> Π TITLE(EMPLOYEE) : EMPLOYEE 테이블에서 TITLE 열을 도출

3. `Join`
- 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
- *▷◁*를 사용

4. `Division`
-  **X⊃Y**인 두 개의 릴레이션 R(X) 와 R(Y)가 있을 때, R의 속성이 Y의 속성값을 모두 가진 튜플에서 Y가 가진 속성을 제외한 속성만을 구하는 연산
- *÷*를 사용

### 일반 집합 연산자
1. `합집합(UNION)`
- 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 **중복되는 튜플은 제거**
- 합집합의 카디널리티는 두 릴레이션 카디널리티(튜플의 수)의 합보다 크지 않음
- *∪*를 사용

2. `교집합(INTERSECTION)`
- 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산
- 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않음
- *∩*를 사용

3. `차집합(DIFFERENCE)`
- 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산
- 차집합의 카디널리티는 릴레이션 R의 카디널리티보다 크지 않음
- *ㅡ* 를 사용

4. `교차곱(CARTESIAN PRODUCT)`
- 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산
- 교차곱의 디그리(차수, 속성)는 *두 릴레이션의 디그리를 더한 것과 같고*, 카디널리티(튜플의 수)는 *두 릴레이션의 카디널리티를 곱한 것과 같음*
- *X* 를 사용

## 55. 분산 데이터베이스의 목표
1. `위치 투명성(Location Transparency)`: 액세스하려는 데이터베이스의 **실제 위치를 알 필요 없이** 단지 데이터베이스의 논리적인 명칭만으로 액세스 할 수 있음

2. `중복 투명성(Replication Transparency)`: 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행함

3. `병행 투명성(Concurrency Transparency)`: 분산 데이터베이스와 관련된 **다수의 트랜잭션들이 동시에 실행**되더라도 그 트랜잭션의 결과는 **영향을 받지 않는다.**

4. `장애 투명성(Failure Transparency)`: 트랜잭션, DBMS, 네트워크, 컴퓨터 **장애에도 불구하고 트랜잭션을 정확하게 처리함**

## 56. 후보키(Candidate Key)
- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합, 즉 *기본키로 사용할 수 있는 속성*들
- 후보키는 릴레이션에 있는 모든 튜플에 대해서 *유일성*과 *희소성*을 만족시켜야 함

## 58. 데이터 제어 언어(DCL)
DCL은 데이터의 *보안, 무결성, 회복, 병행 수행 제어* 등을 정의하는 데 사용되는 언어이다.
- 데이터베이스 관리자가 *데이터 관리*를 목적으로 사용한다.

### DCL의 종류
1. `COMMIT`: 명령에 의해 수행된 결과를 **실제 물리적 디스크로 저장**하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려줌
2. `ROLLBACK`: 데이터베이스 조작 작업이 **비정상적으로 저장** 되었을 떄 **원래의 상태로 복구**함
3. `GRANT`: 데이터베이스 사용자에게 **사용 권한을 부여**
4. `REVOKE`: 데이터베이스 사용자의 **사용 권한을 취소**

## 59. DROP
DROP은 스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱스, 제약 조건 등을 제거하는 명령문이다.
```sql
DROP SCHEMA 스키마명 [CASCADE | RESTRICT];
DROP DOMAIN 도메인명 [CASCADE | RESTRICT];
DROP TABLE 테이블명 [CASCADE | RESTRICT];
DROP VIEW 뷰명 [CASCADE | RESTRICT];
DROP INDEX 인덱스명 [CASCADE | RESTRICT];
DROP CONSTRAINT 제약조건명;

DROP TABLE 학생 CASCADE; /*학생 테이블을 제거하며, 학생 테이블을 참조하는 모든 데이터를 함께 제거*/
```
- `CASCADE`: 제거할 요소를 *참조하는 다른 모든 개체를 함께 제거*함. 즉 주 테이블의 데이터 제거 시 각 외래키와 관계를 맺고 있는 모든 데이터를 제거하는 **참조 무결성 제약 조건**을 설정하기 위해 사용됨

- `RESTRICT`: 다른 개체가 제거할 요소를 참조할 때는 *제거를 취소*함

## 60. 트랜잭션의 특성
1. `Atomicity(원자성)`
- 트랜잭션의 연산은 *데이터베이스에 모두 반영되도록 완료(Commit) 되든지 전혀 반영되지 않도록 복귀(Rollback)되어야 함*
- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 **전부가 취소되어야 함**

2. `Consistency(일관성)`
- 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
- 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 수행 완료 후의 상태가 같아야 함

3.  `Isolation(독립성, 격리성, 순차성)`
- 둘 이상의 트랜잭션이 동시에 병행되는 경우, *어느 하나의 트랜잭션 실행 중에 다른 트랜잭션이 끼어들 수 없음*
- 수행중인 트랜잭션은 완전히 완료될 때까지 **다른 트랜잭션에서 수행 결과를 참조할 수 없음**

4. `Durability(영속성, 지속성)`
- 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

## 61. UNIX 쉘(Shell)
- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 *명령어 해석기*
- 시스템과 사용자 간의 *인터페이스 담당*
- DOS의 *COMMAND.COM*과 같은 기능 수행
- **주기억장치에 상주하지 않고** 명령어가 포함된 파일 형태로 존재하며, **보조기억장치**에서 교체 처리가 가능함
- *파이프라인 기능을 지원*하고 입/출력 재지정을 통해 **입력과 출력의 방향을 변경**할 수 있음
- 공용 Shell(`Bourne Shell`, `C Shell`, `Korn Shell`)이나 사용자 자신이 만든 Shell을 사용 가능

## 62. 전송 계층의 주요 프로토콜
1. `TCP(Transmission Control Protocol)`
- *양방향 연결*(Full Duplex Connection)형 서비스를 제공함
- *스트림 위주의 전달*(패킷 단위)를 함
- *신뢰성 있는 경로를 확립*하고 메세지 전송을 감독함
- *순서 제어, 오류 제어, 흐름 제어* 기능을 함
- TCP 프로토콜의 헤더는 기본적으로 20Byte에서 60Byte까지 사용할 수 있는데, 선택적으로 40Byte를 더 추가할 수 있으므로 최대 100Byte까지 크기를 확장할 수 있음

2. `UDP(User Datagram Protocol)`
- 데이터 전송 전에 *연결을 설정하지 않는 비연결형 서비스*를 제공
- TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로 *오버헤드가 적고, 흐름 제어나 순서 제어가 없어 전송 속도가 빠름*
- **실시간 전송에 유리**히먀, 신리성보다는 속도가 중요시되는 네트워크에서 사용됨

3. `RTCP (Real-time Control Protocol)`
- RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜
- 세션에 참여한 각 참여자들에게 주기적으로 제어 정보를 제공함

## 63. C언어 비트 연산자
비트 연산자는 비트별(0,1)로 연산하여 결과를 얻는 연산자이다.
- `&`: *and*, 모든 비트가 1일 때만 1
- `^`: *xor*, 모든 비트가 같으면 0, 하나라도 다르면 1
- `|`: *or*, 모든 비트 중 한 비트라도 1이라면 1
- `~`: *not*, 각 비트의 부정. 0이면 1,  1이면 0
- `<<`: *왼쪽 시프트*, 비트를 왼쪽으로 이동
- `>>`: *오른쪽 시프트*, 비트를 오른쪽으로 이동

## 64. 결합도(Coupling)
결합도는 모듈 간 상호 의존하는 정도 또는 두 모듈 간의 연관 관계를 의미한다.

- 다양한 결합으로 모듈을 구성할 수 있으나 *결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다.*
- 결합도가 강하면 **시스템 구현 및 유지보수 작업이 어렵다.**
- 결합도의 종류에는 *지료 결합도, 스탬프 결합도, 제어 결합도, 외부 결합도, 공통 결합도, 내용 결합도*가 있음.

1. `자료 결합도`: *모듈 간 인터페이스가 자료 요소로만* 구성될 떄의 결합도
2. `스탬프(검인) 결합도`: *모듈 간의 인터페이스로 배열이나 레코드* 등의 자료 구조가 전달될 때의 결합도
3. `제어 결합도`: 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소(*Function code, switch, tag, flag*)를 전달하는 결합도
4. `외부 결합도`: 어떤 모듈에서 선언한 *데이터(변수)를 외부의 다른 모듈에서 참조*할 떄의 결합도
5. `공통(공유) 결합도`: 공유되는 공통 데이터 영역을 여러 모듈이 사용할 떄의 결합도
6. `내용 결합도`: 한 모듈이 *다른 모듈의 내부 기능 및 내부 자료를 직접 참조하거나 수정*할 때의 결합도

## 65. 스레드(Thread)
스레드는 **프로세스 내에서의 작업 단위**로서, 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위이다.

- 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 한다.
- 프로세스의 일부 특성을 갖고 있기 때문에 **경량(light) 프로세스**라고도 한다.
- 스레드 기반 시스템에서 스레드는 **독립적인 스케줄링의 최소 단위**로서 프로세스의 역할을 담당
- 동일 프로세스 환경에서 **서로 독립적인 다중 수행**이 가능하다.

### 사용자 수준의 스레드
- 사용자가 만든 라이브러리를 이용하여 스레드를 운용
- 속도는 빠르나 구현이 어려움

### 커널 수준의 스레드
- 운영체제의 커널에 의해 스레드를 운용함
- 구현이 쉽지만 속도가 느림

## 66. C언어의 배열
배열은 동일한 데이터 유형을 여러 개 사용해야 할 경우를 손쉽게 처리하기 위해 여러 개의 변수들을 조합해서 하나의 이름으로 정의해 사용하는 것을 말한다.

- 하나의 이름으로 여러 기억장소를 가리키기 때문에 배열에서 개별적인 요소들의 위치는 첨자를 이용하여 지정한다.
- 변수명 뒤에 대괄호 `[]`를 붙이고 그 안에 사용할 개수를 지정한다.
- C언어에서 배열의 위치는 *0*부터 시작한다.
- *행 우선*으로 데이터가 기억장소에 할당된다.
- *배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같다.*
- 배열 선언 시 초기값을 지정할 수 있다.
- 배열을 선언할 때 배열의 크기를 생략하는 경우에는 반드시 초기값을 지정해야 초기값을 지정한 개수 만큼의 배열이 선언된다.
- 배열의 개수보다 적은 수로 배열을 초기화하면 입력된 값만큼 지정된 숫자가 입력되고, 나머지 요소에는 *0*이 입력된다.
- C언어에는 문자열을 저장하는 자료형이 없기 떄문에 배열 또는 포인터를 이용하여 처리한다.
- 배열에 문자열을 저장하면 문자열의 끝을 알리기 위한 *널 문자(`\0`)*가 문자열 끝에 자동으로 삽입된다.
- 배열에 문자열을 저장할 때는 배열 *선언 시 초기값으로 지정*해야 하며, **이미 선언된 배열에는 문자열을 저장할 수 없다.**

## 67. 은행가 알고리즘(Banker's Algorithm)
- 교착 상태의 *회피 기법*
- E.J.Dijkstra가 제안한 것으로, 은행에서 모든 고객의 요구가 충족하도록 현금을 할당하는 데에서 유래한 기법
- 자원의 할당 여부를 결정하기 전에 미리 결정된 모든 자원의 최대 가능한 할당량을 시뮬레이션하여 안전 여부를 검사한다. 그런 다음 대기 중인 다른 모든 활동의 교착 상태 가능성을 조사하여 '안정 상태' 여부를 검사 확인한다.

## 68. IEEE 802.11의 버전
1. `802.11(초기 버전)`: **2.4GHz** 대역 전파와 **CSMA/CD** 기술을 사용해 최대 **2Mbps**까지의 전송 속도를 지원

2. `802.11a`: **5GHz** 대역의 전파 사용, **ODFM** 기술을 사용해 최고 **54Mbps**까지의 전송 속도 지원

3. `802.11b`: 802.11 초기 버전의 개선안으로 등장하였으며, *초기 버전의 대역 전파와 기술을 사용*해 최고 **11MBps**의 전송 속도로 기존에 비해 5배 이상 빠르게 개선됨

4. `802.11e`: 802.11의 부가 기능 표준으로, *QoS(서비스 품질)* 기능이 지원되도록 하기 위해 *매체 접근 제어(MAC) 계층에 해당하는 부분을 수정함*

5. `802.11g`: **2.4GHz** 대역의 전파를 사용하지만 5GHz 대역의 전파를 사용하는 **802.11a와 동일한 최고 54Mbps까지의 전송 속도를 지원**

6. `802.11i`: 802.11의 *보안 기능 표준*으로, 인증 방식에 **WPA/WPA2**를 사용

7. `802.11n`: 2.4GHz 대역과 5GHz 대역을 사용하는 규격으로, 최고 *600Mbps*까지의 전송 속도를 지원함

## 69. 인터넷 계층의 주요 프로토콜
1. `IP(Interneet Protocol)`
- 전송할 데이터에 주소를 지정하고, 경로를 설정하는 기능을 함
- 비연결형인 *데이터그램* 방식을 사용하는 것으로 *신뢰성이 보장되지 않음*

2. `IMCP(Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜)`
- IP와 조합하여 통신 중에 발생하는 *오류의 처리* 와 전송 경로 변경 등을 위한 *제어 메세지를 관리*하는 역할을 하며, 헤더는 **8Byte**로 구성됨

3. `IMGP(Internet Group Management Protocol, 인터넷 그룹 관리 프로토콜)`
- *멀티캐스트*(한 번의 송신으로 메시지나 정보를 목표한 여러 컴퓨터에 동시에 전송하는 것)를 지원하는 호스트나 라우터 사이에서 **멀티캐스트 그룹 유지**를 위해 사용됨

4. `ARP(Address Resolution Protocol, 주소 분석 프로토콜)`
- 호스트의 *IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로* 바꿈

5. `RARP(Reverse Address Resolution Protocol)`
- ARP와 반대로 *물리적 주소를 IP로 변환*

## 70. 주요 스케줄링 알고리즘
1. `FCFS (First Come First Service, 선입선출 = FIFO(First in First Out))`
- 준비상태 큐(대기 큐, 준비 완료 리스트, 작업준비 큐, 스케줄링 큐)에 도착한 순서에 따라 차례로 CPU를 할당하는 기법으로, 가장 간단한 알고리즘이다.
- 먼저 도착한 것이 먼저 처리되어 **공평성은 유지** 되지만 **짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 됨**

2. `SJF(Shortest Job First, 단기 작업 우선)`
- 준비상태 큐에서 기다리고 있는 프로세스들 중에서 *실행 시간이 가장 짧은 프로세스에게 먼저 CPU 할당*
- *가장 적은 평균 대기 시간*을 제공하는 최적 알고리즘

3. `HRN(Highest Response-ratio Next)`
- 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스(실행)시간을 이용
- 우선순위 계산 공식을 이용하여 *서비스(실행)시간이 짧은 프로세스나 대기 시간이 긴 서비스에게 우선순위*를 주어 CPU를 할당
- 서비스 실행 시간이 짧거나 대기 시간이 긴 프로세스일 경우 우선순위가 높아짐
- 우선순위를 계산하여 *숫자가 가장 높은 것부터 낮은 순으로 우선순위 부여*
- 우선순위 계산식: **(대기시간 + 서비스 시간) / 서비스 시간**

## 71. 교착상태(Dead Lock)
*상호 배제*에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상

### 교착상태 발생의 필요 충분 조건
1. `상호 배제(Mutual Exclusion)`
- **한 번에 한 개의 프로세스만이 공유 자원을 사용**할 수 있어야 함

2. `점유와 대기(Hold and wait)`
- 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함

3. `비선점(Non-Preemption)`
- **다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 함**

4. `환형 대기(Circular Wait)`
- 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 *원형*으로 구성되어 있어 *자신에게 할당된 자원을 요구하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함*

## 72. 페이지 교체 알고리즘
페이지 교체 알고리즘은 `페이지 부재(Page Fault,  메모리에 적재된 페이지중에 사용해야 할 페이지가 없을 때)` 가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용 중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법이다.

1. `OPT(OPTimal replacement, 최적 교체)`
- *앞으로 가장 오랫동안 사용하지 않을 페이지*를 교체하는 기법
- 벨레이디가 제안한 것으로, *페이지 부재 횟수가 가장 적게 발생*하는 기법

2. `FIFO(First in First Out)`
- 각 페이지가 주기억장치에 적재될 떄마다 그때의 시간을 기억시켜 *가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법*
- 이해하기 쉽고, 프로그래밍 및 설계가 간단함

3. `LRU(Least Recently Used)`
- 최근에 *가장 오랫동안 사용하지 않은 페이지*를 교체하는 기법
- 각 페이지마다 *계수기(Counter)*나 *스택(Stack)*을 두어 현 시점에서 가장 오랫동안 사용하지 않은, 즉 *가장 오래 전에 사용된 페이지를 교체함*

4. `LFU(Least Frequently Used)`
- *사용 빈도가 가장 적은 페이지를 교체*하는 기법
- 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용됨

5. `SCR(Second Chance Replacement, 2차 기회 교체)`
가장 *오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지* 하는 것으로, **FIFO 기법의 단점을 보완**하는 기법

6. `NUR(Not Used Recently)`
- `LRU`와 비슷한 알고리즘으로, **최근에 사용하지 않은 페이지를 교체**하는 기법
- *최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제*로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음
- 최근의 사용 여부를 확인하기 위해서 각 페이지마다 *두 개의 비트*, 즉 *참조 비트(Reference Bit)*와 *변형 비트(Modefied Bit, Dirty Bit)*가 사용됨

## 73. 변수명 작성 규칙
- *영문자, 숫자, _(언더바)*를 사용할 수 있다.
- 첫 글자는 영문자나 _(언더바)로 시작해야 하며, 숫자는 올 수 없다.
- 글자 수에 제한이 없다.
- 공백이나 *, +, -, / 등의 특수문자를 사용할 수 없다.
= 대소뮨자룰 구분한다.
- 예약어를 명령어로 사용할 수  없다.
- 변수 선언 시 문장 끝에 반드시 세미콜론(;)을 붙여야 한다.


## 74. IPv6(Internet Protocol Version 6)
- 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발
- *128비트*의 긴 주소를 사용하여 주소 부족 문제 해결, IPv4에 비해 자료 전송  속도가 빠르다
- *인증성, 기밀성, 데이터 무결성*의 지원으로 보안 문제를 해결할 수 있다.
- IPv4와 호환성이 뛰어남
- *주소의 확장성,  융통성, 연동성*이 뛰어나며, 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원한다.
- 패킷의 크기를 확장할 수 있으므로 *패킷 크기에 제한이 없다.*

### IPv6의 구성
- 16비트씩 8부분, 총 *128비트*로 구성되어 있다.
- 각 부분을 16진수로 포헌하고, 콜론(`:`)으로 표현한다.
- IPv6은 다음과 같이 세 가지 주소 체계로 나누어진다.
1. `유니캐스트(Unicast)`: 단일 송신자와 단일 수신자 간의 통신 (**1:1 통신에 사용**)
2. `멀티캐스트(Multicast)`: 단일 송신자와 다중 수신자 간의 통신(**1:다 통신에 사용**)
3. `애니캐스트(Anycast)`: 단일 송신자와 *가장 가까이 있는* 단일 수신자 간의 통신(**1:1 통신에 사용**)

## 75. 프로세스 상태의 종류
프로세스 상태 전이는 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것을 의미하며, 프로세스의 상태를 다음과 같이 상태 전이도로 표시할 수 있다.

```
제출(Submit)-> 접수(Hold) -> Job 스케줄러 -> 준비(Ready) -> Dispatch -> 실행(Run) -> 종료(Terminal Exit)

접수 <- Spooling -> 디스크

실행(Run) -> 입, 출력 발생 -> 대기(Wait, Block) -> 입, 출력 종료 시 깨움(Wakw up) -> 준비 (Ready)

```
- 프로세스의 상태는 *제출, 접수, 준비, 실행, 대기*상태로 나눌 수 있으며, 이 중 주요 세 가지 상태는 **준비, 실행, 대기**상태이다.
- `제출(Submit)`: 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
- `접수(Hold)`: 제출된 작업이 스풀 공간인 *디스크의 할당 위치에 저장*된 상태
- `준비(Ready)`: 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
- `실행(Run)`: 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
- `대기(Wait), 보류, 블록(Block)`: 프로세스에 입/출력 처리가 필요하면 *현재 실행중인 프로세스가 중단되고 입/출력 처리가 완료될 때까지 대기*하고 있는 상태
- `종료(Terminated, Exit)`: 프로세스의 실행이 끝나고 프로세스 할당에 해제된 상태

## 76. IPv6의 주소체계
1. `유니캐스트(Unicast)`: 단일 송신자와 단일 수신자 간의 통신(**1:1 통신에 사용**)
2. `멀티캐스트(Multicast)`: 단일 송신자와 다중 수신자 간의 통신(**1:다 통신에 사용**)
3. `애니캐스트(Anycast)`: 단일 송신자와 *가장 가까이 있는* 단일 수신자 간의 통신(**1:1 통신에 사용**)

## 77. 응집도(Cohesion)
*정보 은닉 개념을 확장*한 것으로, 명령이나 호출문 등 *모듈의 내부 요소들이 서로 관련되어 있는 정도*, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도

1. `기능적 응집도`: 모듈 내부의 **모든 기능 요소들이 단일 문제와 연관**되어 수행
2. `순차적 응집도`: 모듈 내 하나의 활동으로부터 나온 **출력 데이터를 그 다음 데이터의 입력 데이터로 사용**할 경우의 응집도
3. `교환(통신)적 응집도`: *동일한 입력과 출력*을 사용하여 *서로 다른 기능을 수행*하는 구성 요소들이 모였을 경우의 응집도
4. `절차적 응집도`: 모듈이 *다수의 관련 기능*을 가질 때 모듈 안의 구성 요소들이 *그 기능을 순차적으로 수행*할 때의 응집도
5. `시간적 응집도`: **특정 시간에 처리**되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
6. `논리적 응집도`: 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
7. `우연적 응집도`: 모듈 내의 각 구성 요소들이 서로 관련 없는 요소로만 구성


## 78. Java 언어 접근 제한자
1. `Public`: 클래스 내부, 패키지 내부, 하위 클래스, 패키지 외부에서 접근 가능
2. `Protected`: 클래스 내부, 패키지 내부, *하위 클래스에서 접근 가능*
3. `Default`: 클래스 내부, *패키지 내부*에서 접근 가능
4. `Private`: *클래스 내부에서만 접근 가능*

## 79. 스크립트 언어의 종류
1. `자바스크립트(JavaScript)`
- **웹 페이지의 동작을 제어**하는 데 사용되는 클라이언트용 스크립트 언어로, 클래스가 존재하지 않으며 변수 선언도 필요 없음
- 서버에서 데이터를 전송할 때 아이디, 비밀번호, 수량 등의 입력 사항을 확인하기 위한 용도로 많이 사용됨

2. `VB스크립트(Visual Basic Script)`
- 마이크로소프트 사에서 **자바 스크립트에 대응하기 위해 제작**된 언어로, *Active X*를 사용하여 마이크로소프트 사의 애플리케이션들을 컨트롤할 수 있음

3. `ASP(Active Server Page)`
- **서버 측에서 동적으로 수행되는 페이지**를 만들기 위한 언어로 마이크로소프트사에서 제작함
- Windows 계열에서만 수행 가능한 프로그래밍 언어

4. `JSP(Java Server Page)`
- JAVA로 만들어진 서버용 스크립트로, 다양한 운영체제에서 사용 가능함

4. `PHP(Professional HyperText Preprocessor)`
- 서버용 스크립트 언어로, Linux, Unix, Windows 운영체제에서 사용 가능함
- C, Java 등과 문법의 유사하므로 배우기 쉬워 웹 페이지 제작에 많이 사용됨

5. `파이썬(Python)`
- *객체지향 기능을 지원*하는 *대화형 인터프리터 언어*로, **플랫폼에 독립적**이고 문법이 간단하여 배우기 쉬움

6. `쉘 스크립트`
- 유닉스/리눅스 계열의 쉘(Shell)에서 사용하는 명령어들의 조합으로 구성된 스크립트 언어
- *컴파일 단계가 없어 실행 속도가 빠름*
- 쉘의 종류: *Bash Shell, Bourne Shell, C Shell, Korn Shell* 등
- 선택형 제어문: **if, case**
- 반복형 제어문: **for, while, until**

## 80. 전송 계층(Transport Layer)
- 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써, *종단 시스템(End-To-End)간에 투명한 데이터 전송을 가능하게 함*
- 종단 시스템 간의 전송 연결 설정, 데이터 설정, 연결 해제 기능을 함
- 주소 설정, 다중화(분할 및 재조립), *오류 제어, 흐름 제어*를 수행함

## 81. JSON(JavaScript Object Notation)
JSON은 **속성-값 쌍**으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다.
비동기 처리에 사용되는 *AJAX*에서 XML을 대체하여 사용되고 있다.

## 82. 경로 프로토콜(Routing Protocol)

### GP(Interior Gateway Protocol, 내부 게이트웨이 프로토콜)
*하나의 자율 시스템(AS)* 내의 라우팅에 사용되는 프로토콜

1. `RIP(Routing Information Protocol)`
- 현재 가장 널리 사용되는 라우팅 프로토콜로 *거리 벡터 라우팅 프로토콜*이라고도 불리며, 최단 경로 탐색에 **Bellman-Ford**알고리즘이 사용됨.
- *소규모 동종의 네트워크*(**자율 시스템, AS**)내에서 효율적인 방법
- 최대 홉(Hop) 수를 *15*로 제한하므로 **15 이상의 경우는 도달할 수 없는 네트워크를 의미**하는데 이것은 *대규모 네트워크에서는 RIP를 사용할 수 없음을 의미함*

2. `OSPF(Open Shortest Path First Protocol)`
- **RIP의 단점을 해결하여 새로운 기능을 지원**하는 인터넷 프로토콜로, *대규모 네트워크에서 많이 사용됨*
- 인터넷 망에서 이용자가 최단 경로를 선정할 수 있도록 라우팅 정보에 *노드 간의 거리 정보, 링크 상태 정보를 실시간으로 반영*하여 최단 경로로 라우팅을 지원
- 최단 경로 탐색에 *다익스트라(Dijkstra)* 알고리즘을 사용함
- 라우팅 정보에 변화가 생길 경우 **변화된 정보만 네트워크 내의 모든 라우터에 알림**
- 하나의 자율 시스템(AS)에서 동작하면서 내부 라우팅 프로토콜의 그룹에 도달함

### EGP(Exterior Gateway Protocol)
*자율 시스템(AS)간의 라우팅*, 즉 게이트웨이 간의 라우팅에 사용되는 프로토콜

### BGP(Border Gateway Protocol)
- 자율 시스템(AS)간의 라우팅 프로토콜로, *EGP의 단점 보완*을 위해 만들어짐
- 초기에 BGP 라우터들이 연결될 때에는 *전체 경로 제어표(라우팅 테이블)을 교환*하고, 이후에는 *변화된 정보*만 교환함

## 83. Smurfing(스머핑)
*IP나 ICMP의 특성을 악용*하여 *엄청난 양의 데이터를 한 사이트에 집중적으로 보냄*으로써 네트워크를 불능 상태로 만드는 공격 방법 

## 84. CMMI(Capability Maturity Model Intergration)
CMMI(능력 성숙도 통합 모델)는 *소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가*하는 모델로, 미국 카네기멜론 데학교의 소프트웨어 공학연구소(SEI)에서 개발하였다.
- CMMI의 소프트웨어 프로세스 성숙도는 `초기, 관리, 정의, 정량적 관리, 최적화`의 5단계로 구분된다.

1. `초기(Initial)`
- 프로세스: 정의된 프로세스 없음
- 특징: *작업자 능력에 따라 성공 여부 결정*

2. `관리(Managed)`
- 프로세스: *규칙화*된 프로세스
- 특징: *특정한 프로젝트 내의 프로세스* 정의 및 수행

3. `정의(Defined)`
- 프로세스: *표준화*된 프로세스
- 특징: *조직의 표준 프로세스를 활용*하여 업무 수행

4. `정량적 관리(Quantitatively Managed)`
- 프로세스: *예측 가능*한 프로세스
- 특징: 프로세스를 *정량적으로 관리 및 통계*

5. `최적화(Optimizing)`
- 프로세스: *지속적 개선* 프로세스
- 특징: 프로세스 역량 향상을 위해 지속적인 프로세스 개선

## 85. 네트워크 관련 신기술
1. `IoT(Internet if Things, 사물 인터넷)`
- 정보 통신 기술을 기반으로 *실세계와 가상 세계의 다양한 사물들을 인터넷으로 서로 연결*하여 진보된 서비스를 제공하기 위한 서비스 기반 기술

2. `메시 네트워크(Mesh Network)`
- 차세대 이동통신, 홈네트워킹, 공공 안전 등 특수한 목적을 위한 새로운 방식의 네트워크 기술로, *대규모 디바이스의 네트워크 생성에 최적화*

3. `피코넷(PICONET)`
- *여러 개의 톡립된 통신장치*가 *블루투스 기술이나 UMB 통신기술*을 사용하여 통신망을 형성하는 무선 네트워크 기술

4. `파장 분할 다중화(WDM, Wavelength Division Multiplexing)`
- 광섬유를 이용한 통신 기술의 ㅎ나로, *파장이 다른 복수의 신호*를 보냄으로써 *여러 대의 단말기가 동시에 통신 회선을 사용*할 수 있도록 하는 것
- *파장이 다른 광선끼리는 서로 간섭을 일으키지 않는 성질*을 이용한 기술

5. `클라우드 기반 HSM(Cloud-Based Hardware Security Module)`
- 클라우드를 기반으로 *암호화 키의 생성/저장/처리* 등의 작업을 수행하는 보안기기
- 클라우드에 인증서를 저장하므로 스마트폰과 같은 개별 기기에 인증서를 저장할 필요가 없음
- 암호화 키 생성이 하드웨어적으로 구현되기 떄문에 소프트웨어적으로 구현된 암호 기술이 가지는 보안 취약점을 무시할 수 있음

6. `파스-타(PaaS-TA)`
- 소프트웨어 개발 환경 제공을 위해 개발한 *개방형 클라우드 컴퓨팅 플랫폼*
- 국내 IT 서비스 경쟁력 강화를 목표로 과학기술정보통신부와 한국정보화진흥원이 연구개발(R&D)를 지원하였으며, **인프라 제어 및 관리 환경, 개발 환경, 실행 환경, 서비스 환경, 운영 환경으로 구성**되어 있음

7. `징(Zing)`
- *10cm* 이내 거리에서 *3.5Gbps* 속도의 데이터 전송이 가능한 초고속 근접무선통신(NFC)
- 휴대용 스마트 기기, 노트북, 쇼핑몰/거리 등의 광고나 키오스크에 접목하여 사용할 수 있음

8. `SSO(Single Sign On)`
- *한 번의 로그인*으로 개인이 가입한 모든 사이트를 이용할 수 있게 해주는 시스템
- 개인정보를 각 사이트마다 일일이 기록해야 하던 불편함을 해소할 수 있음
- 기업에서는 회원에 관한 통합관리가 가능해 마케팅을 극대화시킬 수 있음

9. `스마트 그리드(Smart Grid)`
- 정보 기술을 *전력에 접목*해 효율성을 높인 시스템으로, **전력 IT**라고도 부름
- *전력선을 기반*으로 모든 통신, 정보, 관련 애플리케이션 *인프라를 하나의 시스템으로 통합*하여 효율적인 에너지 관리가 가능

## 86. COCOMO Model 소프트웨어 개발 유형
*보헴*이 제안한 것으로, 원시 프로그램의 규모인 *LOC*에 의한 비용 산정 기법

1. `조직형(Organic Mode)`
- 기관 내부에서 개발된 *중/소규모*의 소프트웨어로 일괄 자료 처리나 과학 기술 계산용, 비즈니스 자료 처리용으로 *5만(50KDS)* 라인 이하의 소프트웨어를 개발하는 유형
- **사무 처리용, 업무용, 과학용 응용 소프트웨어 개발**에 적합

2. `반분리형(Semi-Detached Mode)`
- 조직형과 내장형의 중간형으로 **트랜잭션 처리 시스템**이나 **운영체제, 데이터베이스 관리 시스템** 등의 *30만(300KDS) 라인 이하*의 소프트웨어를 개발하는 유형
- **컴파일러, 인터프리터**와 같은 유틸리티 개발에 적합

3. `내장형(Embeded Mode)`
- *초대형 규모*의 트랜잭션 처리 시스템이나 운영체제 등의 *30만(300KDS) 라인 이상*의 소프트웨어를 개발하는 유형
0 **신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템** 등의 시스템 프로그램 개발에 적합함

## 87. 정보 보안 침해 공격 관련 용어
1. `웜(Worm)`
*네트워크를 통해 연속적으로 자신을 복제*하여 *시*스템의 부하를 높임*으로써 결국 시스템을 다운시키는 바이러스의 일종으로, **분산 서비스 거부 공격, 버퍼 오버플로 공격, 슬래머** 등이 웜의 한 형태

2. `제로 데이 공격(Zero Day Attack)`
보안 취약점이 발견되었을 때 발견된 취약점의 존재가 널리 *공표되기도 전에 해당 취약점을 총해 이루어지는 보안 공격*으로, **공격의 신속성**을 의미함

3. `키로거 공격(Key Logger Attack)`
컴퓨터 사용자의 *키보드 움직임을 탐지*해 ID, 패스워드, 계좌번호, 카드번호 등과 같은 중요 개인정보를 몰래 뺴가는 해킹 공격

4. `랜섬웨어(Ransomware)`
인터넷 사용자의 컴퓨터에 잠입해 내부 문서나 파일 등을 암호화해 사용자가 열지 못하게 하는 프로그램으로, 암호 해독용 프로그램의 전달을 조건으로 사용자에게 돈을 요구하기도 함

5. `백도어(Back Door, Trap Door)`
- 시스템 설계자가 서비스 기술자나 유지보수 프로그램 작성자(Programmer)의 액세스 편의를 위해 *시스템 보안을 제거하여 만든 비밀 통로*로, 컴퓨터 범죄에 악용되기도 함
- 백도어 탐지 방법: *무결성 검사, 열린 포트 확인, 로그 분석, SetUid 파일 검사* 등

## 88. LOC 산정 공식
```
예측치 = (낙관치 + (4 * 기대치(중간치)) + 비관치) / 6
```

- *노력(인월)* = `개발 기간 * 투입 인원`, `LOC / 1인당 월평균 생산 코드 라인 수`
- *개발 비용* = `노력(인월) * 단위 비용(1인당 월평균 인건비)`
- *개발 기간* = `노력(인월) / 투입 인원`
- *생산성* = `LOC / 노력(인월)`

## 89. Putnam 모형
소프트웨어 생명 주기의 전 과정 동안에 사용될 *노력의 분포를 가정*해 주는 모델
- 푸트남(Putnam)이 제안한 것으로 **생명 주기 예측 모형**이라고도 한다.
- *시간*에 따른 함수로 표현되는 *Rayleigh-Norden* 곡선의 노력 분포도를 기초로 한다.
- **대형 프로젝트의 노력 분포 산정**에 이용되는 기법
- 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소한다.

## 90. 양방향 알고리즘 종류
1. `SEED`
- 1999년 한국인터넷진흥원(KISA)에서 개발한 *블록 암호화*(개인키 암호화) 알고리즘
- 블록 크기는 *128*비트이며, 키 길이에 따라 128, 256으로 분류됨

2. `ARIA(Academy, Research Institute, Agency)`
- 2004년 국가정보원과 산학연합회가 개발한 *블록 암호화*(개인키 암호화) 알고리즘
- ARIA는 학계, 연구기관, 정부의 영문 앞 글자로 구성됨
- 블록 크기는 *128*비트이먀. 키 길이에 따라 128, **192**, 256으로 분류됨

3. `DES(Data Encryption Standard)`
- 1975년 미국 NBS에서 발표한 *개인키 암호화* 알고리즘
- DES를 3번 적용하여 보안을 더욱 강조한 3DES(Triple DES)도 있음
- 블록 크기는 *64*바이트이며, 키 길이는 *56비트*

4. `AES(Advanced Encryption Standard)`
- 2001년 미국 표준 기술 연구소(NST)에서 발표한 *개인키* 암호화 알고리즘
- DES의 한계를 노린 NST에서 공모한 후 발표하였다.
- 블록 크기는 *128*비트이며, 키 길이에 따라 **128, 192, 256**으로 분류됨

5. `RSA(Rivest Shamir Adleman)`
- 1978년 MIT의 라이베스트, 샤미르, 애들먼에 의해 제안된 *공개키*암호화 알고리즘
- **큰 숫자를 소인수분해하기 어렵다는 것에 기반**하여 만들어짐
- *공개키와 비밀키를* 사용하는데, 여기서 키란 메시지를 열고 잠그는 상수(Constant)를 의미함