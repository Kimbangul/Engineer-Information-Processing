### 1. 요구사항 분석 시 필요한 기술
- 인터뷰를 통한 요구사항 도출
- 도출된 요구사항을 분석하여 문서로 정리
- 정리된 명세서가 사용자의 요구사항을 충족하는지 여부 검증

### 2. Factory Method(팩토리 메소드)
- 객체 **생성을 서브 클래스에서 처리하도록 분리하여 캡슐화**한 패턴
- 상위 클래스에서는 인터페이스만 정의하고, <u>실제 생성은 서브 클래스가 담당</u> 
- **가상 생성자(Virtual Constructor)** 패턴이라고도 함.

### 3. 럼바우의 객체 지향 분석
1. 객체 모델링
- 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 **속성과 연산 식별** 및 **객체들 간의 관계를 규정**하여 <u>**객체 다이어그램**</u>으로 표시하는 것

2. 동적 모델링
- **<u>상태 다이어그램(상태도)</u>**을 이용하여 **시간의 흐름**에 따른 객체들 간의 *<u>제어 흐름, 동작 순서</u>*등의 **동적인 행위**를 표현하는 모델링

3. 기능 모델링
- **자료 흐름도(DFD)**를 이용하여 *<u>다수의 프로세스들 간의 자료 흐름</u>*을 중심으로 처리 과정을 표현한 모델링

### 4. 애자일 기법
1. 프로세스와 도구보다는 **개인과 상호작용**에 더 가치를 둔다.
2. 방대한 문서보다는 실행되는 소프트웨어에 더 가치를 둔다.
3. 계약 협상보다는 **고객과 협업**에 더 가치를 둔다.
4. 계획을 따르기보다는 **변화에 반응하는 것**에 더 가치를 둔다.

### 5. 미들웨어 솔루션의 유형
- `DB(DataBase)`, `RPC(Remote Procedure Call)`, `MOM(Message Oriented Middleware)`, `TP-Monitor(Transaction Processing Monitor)`, `ORB(Object Request Broker)`, `WAS(Web Application Server)`

### 6. UML 순차(시퀀스) 다이어그램
순차 다이어그램은 시스템이나 객체들이 메세지를 주고받으며 <u>*시간의 흐름에 따라 상호작용하는 과정*</u>을 액터, 객체, 메세지 등의 요소를 사용하여 그림으로 표현한 것이다. 순차 다이어그램은 **액터, 객체, 생명선, 실행, 메세지** 등으로 구성된다.

1. 액터(Actor)
- 시스템으로부터 서비스를 요청하는 외부 요소로, **사람이나 외부 시스템**을 의미함

2. 객체(Object)
- 메세지를 주고받는 **주체**

3. 생명선(LifeLine)
- 객체가 <u>메모리에 존재하는 기간</u>으로, 객체 아래쪽에 **점선**을 그어 표현

4. 메세지
- 객체가 상호 작용을 위해 주고받는 매세지

### 7. 캡슐화(Encapsulation)
- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것
- 캡슐화된 객체는 <u>*인터페이스를 제외*</u>한 세부 내용이 은폐(**정보 은닉**)되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적다.
- 캡슐화된 객체는 **재사용이 용이**하다.
- 객체들 간의 메세지를 주고받을 때 상태 객체의 세부 내용은 알 필요가 없으므로 **인터페이스가 단순해지고, 객체 간 결합도가 낮아짐**

### 8. 행위적 패턴의 종류
- 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(interpreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)

### 9. UI 설계 원칙
- **직관성**: 누구나 쉽게 이해하고 사용할 수 있어야 한다.
- **유효성**: 사용자의 목적을 정확하고 완벽하게 달성해야 한다.
- **학습성**: 누구나 쉽게 배우고 익힐 수 있어야 한다.
- **유효성**: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.

### 10. 코드의 기능
1. `식별 기능`: 데이터 간의 성격에 따라 구분이 가능함
2. `분류 기능`: 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화할 수 있음
3. `배열 기능`: 다양한 데이터를 기준에 맞추어 표현할 수 있음
4. `간소화 기능`: 복잡한 데이터를 간소화할 수 있음

### 11. 협약(Contract)에 의한 설계
컴포넌트를 설계할 때 <u>*클래스에 대한 여러 가정을 공유할 수 있도록 명세*</u>한 것으로, 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다. <br />
협약에 의한 설계 시 명세에 포함될 조건에는 **선행 조건, 결과 조건, 불변 조건**이 있다.

- `선행 조건`: 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
- `결과 조견`: 오퍼레이션이 수행된 후 만족되어야 할 조건
- `불변 조건`: 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

### 12. UML 다이어그램의 종류
#### 구조적 다이어그램의 종류
- **정적 모델링**
- 클래스 다이어그램, 객체 다이어그램, 컴포넌트 다이어그램, <u>*배치 다이어그램*</u>, 복합체 다이어그램, 패키지 다이어그램

#### 행위 다이어그램의 종류
- **동적 모델링**
- 유스케이스 다이어그램, <u>*순차 다이어그램*</u>, 커뮤니케이션 다이어그램, 상태 다이어그램, 활동 다이어그램, 상호작용 개요 다이어그램, 타이밍 다이어그램


### 13. 클래스
클래스는 **공통된 속성과 연성(행위)을 갖는 객체의 집합**으로, 객체의 **일반적인 타입**을 의미함
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
- 객체지향 프로그램에서 데이터를 추상화하는 단위이다.
- *<u>클래스에 속한 각각의 객체</u>*를 **인스턴스**라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화 라고 한다.

### 14. UML 모델의 관계
1. **연관(Association)관계**
- 2개 이상의 사물이 서로 관련되어 있음을 표현한다.
- `ㅡ>`

2. **집합(Aggregation)관계**
- 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현한다.
- `-◇`

3. **포함(Composition)관계**
- 집합 관계의 특수한 형태로, *<u>포함하는 사물의 변화가 포함되는 사물에게 영향</u>*을 미치는 관계를 표현한다.
- `-◆`

4. **일반화(Generalization)관계**
- 일반화 관계는 **하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현**한다.
- 하위 클래스들의 공통점을 상위 클래스에서 가지고, 하위 클래스는 상위 클래스의 공통점을 상속 받는 관계
- `-▷`

5. **의존(Dependency)관계**
- 의존 관계는 연관 관계와 같이 사물 사이에 서로 연관은 있으나 *<u>필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계</u>*를 표현한다.
- 일반적으로 한 클래스가 **다른 클래스를 오퍼레이션의 매개 변수로 사용**하는 경우에 나타나는 관계이다.
- `- - - >`

6. **실체화(Realization)**관계
- 실체화 관계는 사물이 *<u>할 수 있거나 해야 하는 기능(행위, 인터페이스)으로 서로를 그룹화</u>*할 수 있는 관계를 표현한다.
- `- - - -▷`

### 15. 디자인 패턴을 구성하는 요소
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드

### 16. 자료 사전
- `=`: 자료의 정의, ~로 구성되어 있다(is composed of)
- `+`: 자료의 연결, 그리고(and)
- `()`: 자료의 생략, 생략 가능한 자료(Optional)
- `[]`: 자료의 선택, 또는(or)
- `{}`: 자료의 반복(Iteration of)
- `* *`: 자료의 설명(주석)
> {}n: n번 이상 반복, {}nm: m 이상 n 이하로 반복

### 17. 객체지향 설계 원칙
객체지향 설계 원칙은 시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 다섯 가지 원칙으로, 다섯 가지 원칙의 앞글자를 따 **SOLID 원칙** 이라고도 불린다.


#### 1. 단일 책임 원칙(SRP, Single Responsibility Principle)
- 객체는 *<u>단 하나의 책임만</u>* 가져야 한다는 원칙
- 클래스는 그 책임을 완전히 캡슐화해야 함

#### 2. 개방-폐쇄 원칙(OOP, Open-Cloded Principle)
-  *<u>기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계</u>*해야 한다는 원칙

#### 3. 리스코프 치환 원칙(Liskov Substitution Principle)
- 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
- 서브 타입(상속받은 하위 타입)은 *<u>어디에서나 자신의 기반 타입(상위 클래스) 로 교체할 수 있어야 함</u>*

### 4. 인터페이스 분리 원칙(Interface Segregation Principle)
- 자신이 사용하지 않는 인터페이스와 *<u>의존 관계를 맺거나 영향을 받지 않아야 한다</u>*는 원착

### 5. 의존 역전 원칙(Dependency Inversion Principle)
- 각 객체들 간의 의존관계가 성립될 때, *<u>추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계</u>*를 맺어야 한다는 원칙