### 1. 요구사항 분석 시 필요한 기술
- 인터뷰를 통한 요구사항 도출
- 도출된 요구사항을 분석하여 문서로 정리
- 정리된 명세서가 사용자의 요구사항을 충족하는지 여부 검증

### 2. Factory Method(팩토리 메소드)
- 객체 **생성을 서브 클래스에서 처리하도록 분리하여 캡슐화**한 패턴
- 상위 클래스에서는 인터페이스만 정의하고, <u>실제 생성은 서브 클래스가 담당</u> 
- **가상 생성자(Virtual Constructor)** 패턴이라고도 함.

### 3. 럼바우의 객체 지향 분석
1. 객체 모델링
- 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 **속성과 연산 식별** 및 **객체들 간의 관계를 규정**하여 <u>**객체 다이어그램**</u>으로 표시하는 것

2. 동적 모델링
- **<u>상태 다이어그램(상태도)</u>**을 이용하여 **시간의 흐름**에 따른 객체들 간의 *<u>제어 흐름, 동작 순서</u>*등의 **동적인 행위**를 표현하는 모델링

3. 기능 모델링
- **자료 흐름도(DFD)**를 이용하여 *<u>다수의 프로세스들 간의 자료 흐름</u>*을 중심으로 처리 과정을 표현한 모델링

### 4. 애자일 기법
1. 프로세스와 도구보다는 **개인과 상호작용**에 더 가치를 둔다.
2. 방대한 문서보다는 실행되는 소프트웨어에 더 가치를 둔다.
3. 계약 협상보다는 **고객과 협업**에 더 가치를 둔다.
4. 계획을 따르기보다는 **변화에 반응하는 것**에 더 가치를 둔다.

### 5. 미들웨어 솔루션의 유형
- `DB(DataBase)`, `RPC(Remote Procedure Call)`, `MOM(Message Oriented Middleware)`, `TP-Monitor(Transaction Processing Monitor)`, `ORB(Object Request Broker)`, `WAS(Web Application Server)`

### 6. UML 순차(시퀀스) 다이어그램
순차 다이어그램은 시스템이나 객체들이 메세지를 주고받으며 <u>*시간의 흐름에 따라 상호작용하는 과정*</u>을 액터, 객체, 메세지 등의 요소를 사용하여 그림으로 표현한 것이다. 순차 다이어그램은 **액터, 객체, 생명선, 실행, 메세지** 등으로 구성된다.

1. 액터(Actor)
- 시스템으로부터 서비스를 요청하는 외부 요소로, **사람이나 외부 시스템**을 의미함

2. 객체(Object)
- 메세지를 주고받는 **주체**

3. 생명선(LifeLine)
- 객체가 <u>메모리에 존재하는 기간</u>으로, 객체 아래쪽에 **점선**을 그어 표현

4. 메세지
- 객체가 상호 작용을 위해 주고받는 매세지

### 7. 캡슐화(Encapsulation)
- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것
- 캡슐화된 객체는 <u>*인터페이스를 제외*</u>한 세부 내용이 은폐(**정보 은닉**)되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적다.
- 캡슐화된 객체는 **재사용이 용이**하다.
- 객체들 간의 메세지를 주고받을 때 상태 객체의 세부 내용은 알 필요가 없으므로 **인터페이스가 단순해지고, 객체 간 결합도가 낮아짐**

### 8. 행위적 패턴의 종류
- 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(interpreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)

### 9. UI 설계 원칙
- **직관성**: 누구나 쉽게 이해하고 사용할 수 있어야 한다.
- **유효성**: 사용자의 목적을 정확하고 완벽하게 달성해야 한다.
- **학습성**: 누구나 쉽게 배우고 익힐 수 있어야 한다.
- **유효성**: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.

### 10. 코드의 기능
1. `식별 기능`: 데이터 간의 성격에 따라 구분이 가능함
2. `분류 기능`: 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화할 수 있음
3. `배열 기능`: 다양한 데이터를 기준에 맞추어 표현할 수 있음
4. `간소화 기능`: 복잡한 데이터를 간소화할 수 있음

### 11. 협약(Contract)에 의한 설계
컴포넌트를 설계할 때 <u>*클래스에 대한 여러 가정을 공유할 수 있도록 명세*</u>한 것으로, 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다. <br />
협약에 의한 설계 시 명세에 포함될 조건에는 **선행 조건, 결과 조건, 불변 조건**이 있다.

- `선행 조건`: 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
- `결과 조견`: 오퍼레이션이 수행된 후 만족되어야 할 조건
- `불변 조건`: 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

### 12. UML 다이어그램의 종류
#### 구조적 다이어그램의 종류
- **정적 모델링**
- 클래스 다이어그램, 객체 다이어그램, 컴포넌트 다이어그램, <u>*배치 다이어그램*</u>, 복합체 다이어그램, 패키지 다이어그램

#### 행위 다이어그램의 종류
- **동적 모델링**
- 유스케이스 다이어그램, <u>*순차 다이어그램*</u>, 커뮤니케이션 다이어그램, 상태 다이어그램, 활동 다이어그램, 상호작용 개요 다이어그램, 타이밍 다이어그램


### 13. 클래스
클래스는 **공통된 속성과 연성(행위)을 갖는 객체의 집합**으로, 객체의 **일반적인 타입**을 의미함
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
- 객체지향 프로그램에서 데이터를 추상화하는 단위이다.
- *<u>클래스에 속한 각각의 객체</u>*를 **인스턴스**라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화 라고 한다.

### 14. UML 모델의 관계
1. **연관(Association)관계**
- 2개 이상의 사물이 서로 관련되어 있음을 표현한다.
- `ㅡ>`

2. **집합(Aggregation)관계**
- 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현한다.
- `-◇`

3. **포함(Composition)관계**
- 집합 관계의 특수한 형태로, *<u>포함하는 사물의 변화가 포함되는 사물에게 영향</u>*을 미치는 관계를 표현한다.
- `-◆`

4. **일반화(Generalization)관계**
- 일반화 관계는 **하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현**한다.
- 하위 클래스들의 공통점을 상위 클래스에서 가지고, 하위 클래스는 상위 클래스의 공통점을 상속 받는 관계
- `-▷`

5. **의존(Dependency)관계**
- 의존 관계는 연관 관계와 같이 사물 사이에 서로 연관은 있으나 *<u>필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계</u>*를 표현한다.
- 일반적으로 한 클래스가 **다른 클래스를 오퍼레이션의 매개 변수로 사용**하는 경우에 나타나는 관계이다.
- `- - - >`

6. **실체화(Realization)**관계
- 실체화 관계는 사물이 *<u>할 수 있거나 해야 하는 기능(행위, 인터페이스)으로 서로를 그룹화</u>*할 수 있는 관계를 표현한다.
- `- - - -▷`

### 15. 디자인 패턴을 구성하는 요소
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드

### 16. 자료 사전
- `=`: 자료의 정의, ~로 구성되어 있다(is composed of)
- `+`: 자료의 연결, 그리고(and)
- `()`: 자료의 생략, 생략 가능한 자료(Optional)
- `[]`: 자료의 선택, 또는(or)
- `{}`: 자료의 반복(Iteration of)
- `* *`: 자료의 설명(주석)
> {}n: n번 이상 반복, {}nm: m 이상 n 이하로 반복

### 17. 객체지향 설계 원칙
객체지향 설계 원칙은 시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 다섯 가지 원칙으로, 다섯 가지 원칙의 앞글자를 따 **SOLID 원칙** 이라고도 불린다.


#### 1. 단일 책임 원칙(SRP, Single Responsibility Principle)
- 객체는 *<u>단 하나의 책임만</u>* 가져야 한다는 원칙
- 클래스는 그 책임을 완전히 캡슐화해야 함

#### 2. 개방-폐쇄 원칙(OOP, Open-Cloded Principle)
-  *<u>기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계</u>*해야 한다는 원칙

#### 3. 리스코프 치환 원칙(Liskov Substitution Principle)
- 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
- 서브 타입(상속받은 하위 타입)은 *<u>어디에서나 자신의 기반 타입(상위 클래스) 로 교체할 수 있어야 함</u>*

### 4. 인터페이스 분리 원칙(Interface Segregation Principle)
- 자신이 사용하지 않는 인터페이스와 *<u>의존 관계를 맺거나 영향을 받지 않아야 한다</u>*는 원칙

### 5. 의존 역전 원칙(Dependency Inversion Principle)
- 각 객체들 간의 의존관계가 성립될 때, *<u>추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계</u>*를 맺어야 한다는 원칙
- 상위 계층이 하위 계층의 구현으로부터 독립

### 18. 자료 흐름도(Data Flow Diagram)의 구성 요소
- **프로세스(Process), 자료 저장소(Data Store), 자료 흐름(Flow), 단말(Terminator)**

### 19. CASE(Computer Aided Software Engineering)
CASE는 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것이다.
- 객체지향 시스템, 구조적 시스템 등 **다양한 시스템에서 활용되는 자동화 도구(CASE Tool)**이다.
- 소프트웨어, 하드웨어, 데이터베이스, 테스트 등을 **통합**하여 <u>소프트웨어를 개발하는 환경을 조성한다.</u>
- 소프트웨어 생명 주기의 **전체 단계를 연결**해 주고 **자동화 해주는 통합된 도구를 제공**해주는 기술이다.
- <u>소프트웨어 개발 도구와 방법론이 결합</u>된 것으로, **정형화된 구조 및 방법(메커니즘)을 소프트웨어 개발에 적용**하여 생산성 향상을 구현하는 공학 기법이다.
- 소프트웨어 개발의 모든 단계에 거쳐 <u>일관된 방법론을 제공</u>하는 자동화 도구들을 지원하고, 개발자들은 이 도구를 사용하여 **소프트웨어 개발의 표준화**를 지향하며, **자동화**의 이점을 얻을 수 있다.
- CASE의 주요 기능: <u>**소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원**</u>

### 20. 요구사항 검증 방법
#### 1. 동료검토(Peer Review)
- 요구사항 **명세서 작성자가 내용을 직접 설명**하고 <u>동료</u>들이 이를 들으면서 결함을 발견하는 형태의 검토 방법

#### 2. 워크스루(WalkThrough)
- 검토 회의 전에 **요구사항 명세서를 미리 배포**하여 사전 검토한 후에 *<u>짧은 회의를 통해 결함을 발견</u>*

#### 3. 인스펙션(Inspection)
- *<u>요구사항 명세서 작성자를 제외</u>*한 **다른 검토 전문가**들이 요구사항 명세서를 확인하면서 결함을 발견

#### 4. 프로토타이핑(Prototyping)
- 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 **견본품**을 만들어 최종 결과물을 예측함

#### 5. 테스트 설계
- 요구사항은 테스트할 수 있도록 작성되어야 하며, 이를 위해 테스트 케이스(Test case)를 생성하여 이후에 요구사항이 현실적으로 테스트 가능한지를 검토함

#### 6. CASE 도구 활용
- **일관성 분석**을 통해 요구사항 변경사항의 추적 및 분석을 관리하고 표준 준수 여부를 확인함

### 21. 네트워크 인터페이스 보안 솔루션
- IPSec, SSL, S-HTTP

### 22. 소프트웨어 공학의 기본 원칙
- 현대적인 프로그래밍 기술을 지속적으로 적용한다.
- 소프트웨어 품질에 대해 지속적인 검증을 시행한다.
- 소프트웨어 개발 단계별 산출물에 대한 명확한 기록을 유지한다.

### 23. 소프트웨어 품질 요구사항
- `ISO/IEC 9126`: 소프트웨어의 **품질 특성과 평가**를 위한 표준 지침으로서 국제 표준으로 널리 사용됨
- `ISO/IEC 25010`: 소프트웨어 **제품에 대한 국제 표준**으로, *<u>2011년에 ISO/IEC 9126을 개정하여 만들었음</u>*
- `ISO/IEC 12119`: ISO/IEC 9126을 준수한 품질 표준으로, **테스트 절차를 포함하여 규정함**
- `ISO/IEC 14598`: **소프트웨어 품질의 측정과 평가의 주요 절차를 규정**힌 표준으로, *<u>개발자/구매자/평가자 별로 수행해야 할 제품 평가 활동을 규정함</u>*

### 24. 클린 코드 작성 원칙
- 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화

### 25. 블랙박스 테스트의 종류
- 동치(동등)분할 검사, 경계값 분석, 원인-효과 그래프 검사, 오류 예측 검사, 비교 검사

### 26. 순환복잡도(mccabe의 cyclomatic)
순환 복잡도는 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어 척도로, **맥케이브 순환도** 또는 맥케이브 복잡도 메트릭이라고도 하며, 제어 흐름도 이론에 기초를 둔다.
- 순환 복잡도를 이용하여 계산된 값은 *<u>프로그램의 독립적인 경로의 수</u>*를 정의하고, *<u>모든 경로가 한 번 이상 수행되었음을 보장/u>*하기 위해 행해주는 테스트 횟수의 상한선을 제공한다.
1. 순환 복잡도는 제어 흐름도의 영역 수와 일치하므로 영역 수를 계산한다.
2. `순환 복잡도 = 화살표 수 - 노드 수 + 2`

### 27. 선택 정렬(Selection Sort)
- 선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 **가장 작은 값을 찾아 첫 번째에 놓고**, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.

### 28. 형상 관리 도구의 주요 기능
- 저장소(Repository), 가져오기(import), 체크아웃(checkout), 체크인(checkin), 커밋(commit), 동기화(update)

### 30. 소프트웨어 품질 목표
#### 기능성
- 소프트웨어가 **사용자의 요구사항을 정확하게 만족**하는 기능을 제공하는지 여부
- 하위 특성: 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성

#### 신뢰성
- 소프트웨어가 요구된 기능을 **정확하고 일관되게 오류 없이 수행할 수 있는 정도**
- 하위 특성: 성숙성, 고장 허용성, 회복성

#### 사용성
- 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대하여 **사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도**
- 하위 특성: 이해성, 학습성, 운용성, 친밀성

#### 효율성
- 사용자가 요구하는 기능을 할당된 시간 동안 **한정된 자원으로 얼마나 빨리 처리할 수 있는지** 정도
- 하위 특성: 시간 효율성, 자원 효율성

#### 유지 보수성
- 환경의 변화 또는 새로운 요구사항 발생 시 소프트웨어를 개선하거나 확장할 수 있는 정도
- 하위 특성: 분석성, 변경성, 안정성, 시험성

#### 이식성
- 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도
- 하위 특성: 적용성, 설치성, 대체성, 공존성

### 31. 알고리즘 설계 기법의 종류 
#### 1. Brute Force(브루트포스)
- *<u>모든 경우의 수를 탐색해서 정답을 도출</u>*해 내는 **완전 탐색 알고리즘**
- 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS)

#### 2. Backtracking (퇴각 검색)
- 완전 탐색 알고리즘에서 **답이 될 가능성이 없으면 탐색을 하지 않음**

#### 3. Greedy(탐욕)
- 탐색을 하는 상황에서 **상황마다 가장 좋아보이는 해결책을 선택**
- 최소비용 신장트리(MST, Minimum Spanning Tree)

#### 4. Dynamic Programming(동적 프로그래밍)
- **Memoization** 기법(*<u>계산한 내용을 저장하여 추후 반복 계산을 막는 방식</u>*)을 사용
- 완전탐색을 하는 경우 이중 반복을 통해 `O(N^2)`의 시간 복잡도가 소요될 때, 적절한 문제에 해당 알고리즘을 사용하면 `O(N)`으로 줄어들 수 있음

#### 5. Divide and Conquer(분할 정복)
- **큰 문제를 작은 문제로 나눠서 푸는 하향식 접근 방식**
- 분할을 통해 해결하기 쉬운 작은 문제로 나눈 후, 정복한 후 병합하는 과정을 거쳐 큰 문제를 해결함
- 보통 **recursion(재귀)**를 사용
- 퀵 정렬(Quick Sort), 병합 정렬(Merge Sort), 이진 탐색(Binary Search)

### 35. 파티션의 종류
#### 1. 범위 분할(Range Partitioning)
- **지정한 열의 값을 기준**으로 범위를 지정하여 분할함.
-  *<u>일별, 월별, 분기별 등</u>*

#### 2. 해시 분할(Hash Partitioning)
- **해시 함수를 적용한 결과 값**에 따라 데이터를 분할함
- <u>특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완</u>한 것으로, 데이터를 **고르게 분산**할 때 유용함
- **특정 데이터가 어디에 있는지 판단할 수 있음**
- <u>고객번호, 주민번호</u> 등과 같이 데이터가 고른 컬럼에 효과적임

#### 3. 조합 분할(Composite Partitioning)
- 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식
- **범위 분할한 파티션이 너무 커서 관리가 어려울 때** 유용함.

#### 4. 목록 분할(List Partitioning)
- **지정한 열 값에 대한 목록**을 만들어 이를 기준으로 분할
- '국가' 라는 열에 '한국','미국','일본' 이 있는 경우 '미국' 을 제외할 목적으로 '아시아' 라는 목록을 만들어 분할함

#### 5. 라운드 로빈 분할(Round Robin Partitioning)
- **레코드를 균일하게 분해**하는 방식
- 각 레코드가 **순차적으로 분해**되며, *<u>기본키가 필요 없음</u>*