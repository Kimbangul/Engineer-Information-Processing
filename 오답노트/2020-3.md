### 1. 요구사항 분석 시 필요한 기술
- 인터뷰를 통한 요구사항 도출
- 도출된 요구사항을 분석하여 문서로 정리
- 정리된 명세서가 사용자의 요구사항을 충족하는지 여부 검증

### 2. Factory Method(팩토리 메소드)
- 객체 **생성을 서브 클래스에서 처리하도록 분리하여 캡슐화**한 패턴
- 상위 클래스에서는 인터페이스만 정의하고, <u>실제 생성은 서브 클래스가 담당</u> 
- **가상 생성자(Virtual Constructor)** 패턴이라고도 함.

### 3. 럼바우의 객체 지향 분석
1. 객체 모델링
- 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 **속성과 연산 식별** 및 **객체들 간의 관계를 규정**하여 <u>**객체 다이어그램**</u>으로 표시하는 것

2. 동적 모델링
- **<u>상태 다이어그램(상태도)</u>**을 이용하여 **시간의 흐름**에 따른 객체들 간의 *<u>제어 흐름, 동작 순서</u>*등의 **동적인 행위**를 표현하는 모델링

3. 기능 모델링
- **자료 흐름도(DFD)**를 이용하여 *<u>다수의 프로세스들 간의 자료 흐름</u>*을 중심으로 처리 과정을 표현한 모델링

### 4. 애자일 기법
1. 프로세스와 도구보다는 **개인과 상호작용**에 더 가치를 둔다.
2. 방대한 문서보다는 실행되는 소프트웨어에 더 가치를 둔다.
3. 계약 협상보다는 **고객과 협업**에 더 가치를 둔다.
4. 계획을 따르기보다는 **변화에 반응하는 것**에 더 가치를 둔다.

### 5. 미들웨어 솔루션의 유형
- `DB(DataBase)`, `RPC(Remote Procedure Call)`, `MOM(Message Oriented Middleware)`, `TP-Monitor(Transaction Processing Monitor)`, `ORB(Object Request Broker)`, `WAS(Web Application Server)`

### 6. UML 순차(시퀀스) 다이어그램
순차 다이어그램은 시스템이나 객체들이 메세지를 주고받으며 <u>*시간의 흐름에 따라 상호작용하는 과정*</u>을 액터, 객체, 메세지 등의 요소를 사용하여 그림으로 표현한 것이다. 순차 다이어그램은 **액터, 객체, 생명선, 실행, 메세지** 등으로 구성된다.

1. 액터(Actor)
- 시스템으로부터 서비스를 요청하는 외부 요소로, **사람이나 외부 시스템**을 의미함

2. 객체(Object)
- 메세지를 주고받는 **주체**

3. 생명선(LifeLine)
- 객체가 <u>메모리에 존재하는 기간</u>으로, 객체 아래쪽에 **점선**을 그어 표현

4. 메세지
- 객체가 상호 작용을 위해 주고받는 매세지

### 7. 캡슐화(Encapsulation)
- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것
- 캡슐화된 객체는 <u>*인터페이스를 제외*</u>한 세부 내용이 은폐(**정보 은닉**)되어 외부에서의 접근이 제한적이기 때문에 외부 모듈의 변경으로 인한 파급 효과가 적다.
- 캡슐화된 객체는 **재사용이 용이**하다.
- 객체들 간의 메세지를 주고받을 때 상태 객체의 세부 내용은 알 필요가 없으므로 **인터페이스가 단순해지고, 객체 간 결합도가 낮아짐**

### 8. 행위적 패턴의 종류
- 책임 연쇄(Chain of Responsibility), 커맨드(Command), 인터프리터(interpreter), 반복자(Iterator), 중재자(Mediator), 메멘토(Memento), 옵서버(Observer), 상태(State), 전략(Strategy), 템플릿 메소드(Template Method), 방문자(Visitor)

### 9. UI 설계 원칙
- **직관성**: 누구나 쉽게 이해하고 사용할 수 있어야 한다.
- **유효성**: 사용자의 목적을 정확하고 완벽하게 달성해야 한다.
- **학습성**: 누구나 쉽게 배우고 익힐 수 있어야 한다.
- **유효성**: 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.

### 10. 코드의 기능
1. `식별 기능`: 데이터 간의 성격에 따라 구분이 가능함
2. `분류 기능`: 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화할 수 있음
3. `배열 기능`: 다양한 데이터를 기준에 맞추어 표현할 수 있음
4. `간소화 기능`: 복잡한 데이터를 간소화할 수 있음

### 11. 협약(Contract)에 의한 설계
컴포넌트를 설계할 때 <u>*클래스에 대한 여러 가정을 공유할 수 있도록 명세*</u>한 것으로, 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다. <br />
협약에 의한 설계 시 명세에 포함될 조건에는 **선행 조건, 결과 조건, 불변 조건**이 있다.

- `선행 조건`: 오퍼레이션이 호출되기 전에 참이 되어야 할 조건
- `결과 조견`: 오퍼레이션이 수행된 후 만족되어야 할 조건
- `불변 조건`: 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건

### 12. UML 다이어그램의 종류
#### 구조적 다이어그램의 종류
- **정적 모델링**
- 클래스 다이어그램, 객체 다이어그램, 컴포넌트 다이어그램, <u>*배치 다이어그램*</u>, 복합체 다이어그램, 패키지 다이어그램

#### 행위 다이어그램의 종류
- **동적 모델링**
- 유스케이스 다이어그램, <u>*순차 다이어그램*</u>, 커뮤니케이션 다이어그램, 상태 다이어그램, 활동 다이어그램, 상호작용 개요 다이어그램, 타이밍 다이어그램


### 13. 클래스
클래스는 **공통된 속성과 연성(행위)을 갖는 객체의 집합**으로, 객체의 **일반적인 타입**을 의미함
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
- 객체지향 프로그램에서 데이터를 추상화하는 단위이다.
- *<u>클래스에 속한 각각의 객체</u>*를 **인스턴스**라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화 라고 한다.

### 14. UML 모델의 관계
1. **연관(Association)관계**
- 2개 이상의 사물이 서로 관련되어 있음을 표현한다.
- `ㅡ>`

2. **집합(Aggregation)관계**
- 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현한다.
- `-◇`

3. **포함(Composition)관계**
- 집합 관계의 특수한 형태로, *<u>포함하는 사물의 변화가 포함되는 사물에게 영향</u>*을 미치는 관계를 표현한다.
- `-◆`

4. **일반화(Generalization)관계**
- 일반화 관계는 **하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현**한다.
- 하위 클래스들의 공통점을 상위 클래스에서 가지고, 하위 클래스는 상위 클래스의 공통점을 상속 받는 관계
- `-▷`

5. **의존(Dependency)관계**
- 의존 관계는 연관 관계와 같이 사물 사이에 서로 연관은 있으나 *<u>필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계</u>*를 표현한다.
- 일반적으로 한 클래스가 **다른 클래스를 오퍼레이션의 매개 변수로 사용**하는 경우에 나타나는 관계이다.
- `- - - >`

6. **실체화(Realization)**관계
- 실체화 관계는 사물이 *<u>할 수 있거나 해야 하는 기능(행위, 인터페이스)으로 서로를 그룹화</u>*할 수 있는 관계를 표현한다.
- `- - - -▷`

### 15. 디자인 패턴을 구성하는 요소
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드

### 16. 자료 사전
- `=`: 자료의 정의, ~로 구성되어 있다(is composed of)
- `+`: 자료의 연결, 그리고(and)
- `()`: 자료의 생략, 생략 가능한 자료(Optional)
- `[]`: 자료의 선택, 또는(or)
- `{}`: 자료의 반복(Iteration of)
- `* *`: 자료의 설명(주석)
> {}n: n번 이상 반복, {}nm: m 이상 n 이하로 반복

### 17. 객체지향 설계 원칙
객체지향 설계 원칙은 시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 다섯 가지 원칙으로, 다섯 가지 원칙의 앞글자를 따 **SOLID 원칙** 이라고도 불린다.


#### 1. 단일 책임 원칙(SRP, Single Responsibility Principle)
- 객체는 *<u>단 하나의 책임만</u>* 가져야 한다는 원칙
- 클래스는 그 책임을 완전히 캡슐화해야 함

#### 2. 개방-폐쇄 원칙(OOP, Open-Cloded Principle)
-  *<u>기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계</u>*해야 한다는 원칙

#### 3. 리스코프 치환 원칙(Liskov Substitution Principle)
- 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
- 서브 타입(상속받은 하위 타입)은 *<u>어디에서나 자신의 기반 타입(상위 클래스) 로 교체할 수 있어야 함</u>*

### 4. 인터페이스 분리 원칙(Interface Segregation Principle)
- 자신이 사용하지 않는 인터페이스와 *<u>의존 관계를 맺거나 영향을 받지 않아야 한다</u>*는 원칙

### 5. 의존 역전 원칙(Dependency Inversion Principle)
- 각 객체들 간의 의존관계가 성립될 때, *<u>추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계</u>*를 맺어야 한다는 원칙
- 상위 계층이 하위 계층의 구현으로부터 독립

### 18. 자료 흐름도(Data Flow Diagram)의 구성 요소
- **프로세스(Process), 자료 저장소(Data Store), 자료 흐름(Flow), 단말(Terminator)**

### 19. CASE(Computer Aided Software Engineering)
CASE는 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것이다.
- 객체지향 시스템, 구조적 시스템 등 **다양한 시스템에서 활용되는 자동화 도구(CASE Tool)**이다.
- 소프트웨어, 하드웨어, 데이터베이스, 테스트 등을 **통합**하여 <u>소프트웨어를 개발하는 환경을 조성한다.</u>
- 소프트웨어 생명 주기의 **전체 단계를 연결**해 주고 **자동화 해주는 통합된 도구를 제공**해주는 기술이다.
- <u>소프트웨어 개발 도구와 방법론이 결합</u>된 것으로, **정형화된 구조 및 방법(메커니즘)을 소프트웨어 개발에 적용**하여 생산성 향상을 구현하는 공학 기법이다.
- 소프트웨어 개발의 모든 단계에 거쳐 <u>일관된 방법론을 제공</u>하는 자동화 도구들을 지원하고, 개발자들은 이 도구를 사용하여 **소프트웨어 개발의 표준화**를 지향하며, **자동화**의 이점을 얻을 수 있다.
- CASE의 주요 기능: <u>**소프트웨어 생명 주기 전 단계의 연결, 다양한 소프트웨어 개발 모형 지원, 그래픽 지원**</u>

### 20. 요구사항 검증 방법
#### 1. 동료검토(Peer Review)
- 요구사항 **명세서 작성자가 내용을 직접 설명**하고 <u>동료</u>들이 이를 들으면서 결함을 발견하는 형태의 검토 방법

#### 2. 워크스루(WalkThrough)
- 검토 회의 전에 **요구사항 명세서를 미리 배포**하여 사전 검토한 후에 *<u>짧은 회의를 통해 결함을 발견</u>*

#### 3. 인스펙션(Inspection)
- *<u>요구사항 명세서 작성자를 제외</u>*한 **다른 검토 전문가**들이 요구사항 명세서를 확인하면서 결함을 발견

#### 4. 프로토타이핑(Prototyping)
- 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 **견본품**을 만들어 최종 결과물을 예측함

#### 5. 테스트 설계
- 요구사항은 테스트할 수 있도록 작성되어야 하며, 이를 위해 테스트 케이스(Test case)를 생성하여 이후에 요구사항이 현실적으로 테스트 가능한지를 검토함

#### 6. CASE 도구 활용
- **일관성 분석**을 통해 요구사항 변경사항의 추적 및 분석을 관리하고 표준 준수 여부를 확인함

### 21. 네트워크 인터페이스 보안 솔루션
- IPSec, SSL, S-HTTP

### 22. 소프트웨어 공학의 기본 원칙
- 현대적인 프로그래밍 기술을 지속적으로 적용한다.
- 소프트웨어 품질에 대해 지속적인 검증을 시행한다.
- 소프트웨어 개발 단계별 산출물에 대한 명확한 기록을 유지한다.

### 23. 소프트웨어 품질 요구사항
- `ISO/IEC 9126`: 소프트웨어의 **품질 특성과 평가**를 위한 표준 지침으로서 국제 표준으로 널리 사용됨
- `ISO/IEC 25010`: 소프트웨어 **제품에 대한 국제 표준**으로, *<u>2011년에 ISO/IEC 9126을 개정하여 만들었음</u>*
- `ISO/IEC 12119`: ISO/IEC 9126을 준수한 품질 표준으로, **테스트 절차를 포함하여 규정함**
- `ISO/IEC 14598`: **소프트웨어 품질의 측정과 평가의 주요 절차를 규정**힌 표준으로, *<u>개발자/구매자/평가자 별로 수행해야 할 제품 평가 활동을 규정함</u>*

### 24. 클린 코드 작성 원칙
- 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화

### 25. 블랙박스 테스트의 종류
- 동치(동등)분할 검사, 경계값 분석, 원인-효과 그래프 검사, 오류 예측 검사, 비교 검사

### 26. 순환복잡도(mccabe의 cyclomatic)
순환 복잡도는 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어 척도로, **맥케이브 순환도** 또는 맥케이브 복잡도 메트릭이라고도 하며, 제어 흐름도 이론에 기초를 둔다.
- 순환 복잡도를 이용하여 계산된 값은 *<u>프로그램의 독립적인 경로의 수</u>*를 정의하고, *<u>모든 경로가 한 번 이상 수행되었음을 보장/u>*하기 위해 행해주는 테스트 횟수의 상한선을 제공한다.
1. 순환 복잡도는 제어 흐름도의 영역 수와 일치하므로 영역 수를 계산한다.
2. `순환 복잡도 = 화살표 수 - 노드 수 + 2`

### 27. 선택 정렬(Selection Sort)
- 선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여 **가장 작은 값을 찾아 첫 번째에 놓고**, 두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여 그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.

### 28. 형상 관리 도구의 주요 기능
- 저장소(Repository), 가져오기(import), 체크아웃(checkout), 체크인(checkin), 커밋(commit), 동기화(update)

### 30. 소프트웨어 품질 목표
#### 기능성
- 소프트웨어가 **사용자의 요구사항을 정확하게 만족**하는 기능을 제공하는지 여부
- 하위 특성: 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성

#### 신뢰성
- 소프트웨어가 요구된 기능을 **정확하고 일관되게 오류 없이 수행할 수 있는 정도**
- 하위 특성: 성숙성, 고장 허용성, 회복성

#### 사용성
- 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대하여 **사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도**
- 하위 특성: 이해성, 학습성, 운용성, 친밀성

#### 효율성
- 사용자가 요구하는 기능을 할당된 시간 동안 **한정된 자원으로 얼마나 빨리 처리할 수 있는지** 정도
- 하위 특성: 시간 효율성, 자원 효율성

#### 유지 보수성
- 환경의 변화 또는 새로운 요구사항 발생 시 소프트웨어를 개선하거나 확장할 수 있는 정도
- 하위 특성: 분석성, 변경성, 안정성, 시험성

#### 이식성
- 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도
- 하위 특성: 적용성, 설치성, 대체성, 공존성

### 31. 알고리즘 설계 기법의 종류 
#### 1. Brute Force(브루트포스)
- *<u>모든 경우의 수를 탐색해서 정답을 도출</u>*해 내는 **완전 탐색 알고리즘**
- 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS)

#### 2. Backtracking (퇴각 검색)
- 완전 탐색 알고리즘에서 **답이 될 가능성이 없으면 탐색을 하지 않음**

#### 3. Greedy(탐욕)
- 탐색을 하는 상황에서 **상황마다 가장 좋아보이는 해결책을 선택**
- 최소비용 신장트리(MST, Minimum Spanning Tree)

#### 4. Dynamic Programming(동적 프로그래밍)
- **Memoization** 기법(*<u>계산한 내용을 저장하여 추후 반복 계산을 막는 방식</u>*)을 사용
- 완전탐색을 하는 경우 이중 반복을 통해 `O(N^2)`의 시간 복잡도가 소요될 때, 적절한 문제에 해당 알고리즘을 사용하면 `O(N)`으로 줄어들 수 있음

#### 5. Divide and Conquer(분할 정복)
- **큰 문제를 작은 문제로 나눠서 푸는 하향식 접근 방식**
- 분할을 통해 해결하기 쉬운 작은 문제로 나눈 후, 정복한 후 병합하는 과정을 거쳐 큰 문제를 해결함
- 보통 **recursion(재귀)**를 사용
- 퀵 정렬(Quick Sort), 병합 정렬(Merge Sort), 이진 탐색(Binary Search)

### 35. 파티션의 종류
#### 1. 범위 분할(Range Partitioning)
- **지정한 열의 값을 기준**으로 범위를 지정하여 분할함.
-  *<u>일별, 월별, 분기별 등</u>*

#### 2. 해시 분할(Hash Partitioning)
- **해시 함수를 적용한 결과 값**에 따라 데이터를 분할함
- <u>특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완</u>한 것으로, 데이터를 **고르게 분산**할 때 유용함
- **특정 데이터가 어디에 있는지 판단할 수 있음**
- <u>고객번호, 주민번호</u> 등과 같이 데이터가 고른 컬럼에 효과적임

#### 3. 조합 분할(Composite Partitioning)
- 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식
- **범위 분할한 파티션이 너무 커서 관리가 어려울 때** 유용함.

#### 4. 목록 분할(List Partitioning)
- **지정한 열 값에 대한 목록**을 만들어 이를 기준으로 분할
- '국가' 라는 열에 '한국','미국','일본' 이 있는 경우 '미국' 을 제외할 목적으로 '아시아' 라는 목록을 만들어 분할함

#### 5. 라운드 로빈 분할(Round Robin Partitioning)
- **레코드를 균일하게 분해**하는 방식
- 각 레코드가 **순차적으로 분해**되며, *<u>기본키가 필요 없음</u>*

### 41. 정규화 과정
1. `1NF`: 모든 도메인이 원자값
2. `2NF`: 부분적 함수 종속 제거
3. `3NF`: 이행적 함수 종속 제거
4. `BCNF`(보이스/코드 정규형): 결정자이면서 후보키가 아닌 것 제거
5. `4NF`: 다치 종속 제거
6. `5NF`: 조인 종속성 이용

### 45. DDL, DML, DCL
#### DDL
- `CREATE`, `ALTER`, `DROP`

### DML
- `SELECT`, `INSERT`, `DELETE`, `UPDATE`

### DCL
- `COMMIT`,`ROLLBACK`, `GRANT`, `REVOKE`

### 47. 무결성(Intergraty)
무결성이란 <u>데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성</u>을 의미한다.

#### 개체 무결성(Entity Integrity, 실체 무결성)
- **기본키를 구성하는 어떤 속성도 null 값이나 중복값을 가질 수 없음**

#### 도메인 무결성(Domain Integrity)
- 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정

#### 참조 무결성(Referential Integrity)
- **외래키 값은 null 이거나 참조 릴레이션의 기본키 값과 동일**해야 한다. 즉, 릴레이션은 *<u>참조할 수 없는 외래키 값을 가질 수 없음</u>*

#### 사용자 행위 무결성(User-Defined Integrity)
- 속성 값들이 사용자가 정의한 제약조건에 만족해야 함

### 48. 분산 데이터베이스의 목표
1. `위치 투명성(Location Transparency)`: 액세스하려는 데이터베이스의 **실제 위치를 알 필요 없이** 단지 *<u>데이터베이스의 논리적인 명칭만으로</u>* 액세스 가능

2. `중복 투명성(Replication Transparency)`: 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 *<u>마치 하나의 데이터만 존재하는 것처럼 사용</u>*하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행

3. `병행 투명성(Concurrency Transparency)`: 분산 데이터베이스와 관련된 **다수의 트랜잭션이 동시에 실행** 되더라도 그 트랜잭션의 결과는 **영향을 받지 않는다.**

4. `장애 투명성(Failure Transparency)`: 트랜잭션, DBMS, 네트워크, 컴퓨터 **장애에도 불구하고 트랜잭션을 정확하게 처리**

### 52. Division 연산
- `Division`: **X⊃Y**인 두 릴레이션 R(X)와 R(Y)가 있을 때, Y의 속성값을 가지고 있는 튜플(행) 중 Y가 가진 속성만 제외하고 출력함

### 53. 회복 기법
1. `연기 갱신 기법(Defferred Update)`
- *<u>트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기</u>*
- 트랜잭션이 수행되는 동안 갱신된 내용은 일단 Log에 보관됨
- 트랜잭션의 **부분 완료(성공적인 완료 직전)** 시점에 Log에 보관한 갱신 내용을 실제 데이터베이스에 기록함
- 트랜잭션이 부분 완료되기 전 장애가 발생하여 트랜잭션이 Rollback되면 트랜잭션이 실제 데이터베이스에 영향을 미치지 않았기 때문에 어떠한 갱신 내용도 취소시킬 필요 없이 무시하면 됨
- **Redo** 작업만 가능함

2. `즉각 갱신 기법(Immediate Update)`
- 트랜잭션이 데이터를 갱신하면 *<u>트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영</u>*하는 방법
- 장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들은 Log에 보관시킴
- 회복 작업을 할 경우에는 **Redo와 Undo 모두 사용 가능**함

3. `그림자 페이지 대체 기법(Shadow Paging)`
- 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 **복사본인 그림자 페이지로 별도 보관**해 놓고, 실제 페이지를 대상으로 트랜잭션에 의한 갱신 작업을 하다가 장애가 발생하여 트랜잭션을 Rollback 시킬 때, *<u>갱신된 이후의 실제 페이지 부분에 그림자 페이지를 대체하여 회복</u>*시키는 방법
- **로그, Undo 및 Redo 알고리즘이 필요 없음**

4. `검사점 기법`
트랜잭션 실행 중 특정 단계에서 재실행할 수 있도록 갱신 내용이나 시스템에 대한 상황 등에 관한 정보와 함께 **검사점을 로그에 보관**해 두고, 장애 발생 시 *<u>트랜잭션 전체를 철회하지 않고 검사점부터 회복 작업을 하여 회복 시간을 절약</u>*하도록 하는 기법

### 58. SQL 집계 함수(aggregation function)
`GROUP BY` 절에 그룹별로 속성의 값을 집계할 때 사용한다.
- `COUNT(속성명)`: 그룹별 튜플 수를 구하는 함수
- `SUM(속성명)`: 그룹별 합계를 구하는 함수
- `MAX(속성명)`: 그룹별 최대값을 구하는 함수
- `MIN(속성명)`: 그룹별 최소값을 구하는 함수
- `STDDEV(속성명)`: 그룹별 **표준편차**를 구하는 함수
- `VARIANCE(속셩명)`: 그룹별 **분산**을 구하는 함수

### 63. 쉘 스크립트에서 사용할 수 있는 제어문
1. 선택형: `if`, `case`
2. 반복형: `for`, `while`, `until`

### 66. HRN(Highest Response-ratio Next)
- 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것으로, 대기 시간과 서비스(실행)시간을 이용
- 우선순위 계산 공식을 이용하여 **서비스(실행) 시간이 짧은 프로세스나 대기 시간이 긴 서비스에게 우선순위**를 주어 CPU를 할당
- 서비스 실행 시간이 짧거나 대기 시간이 긴 프로세스일 경우 우선순위가 높아짐
- 우선순위를 계산하여 **숫자가 가장 높은 것부터 낮은 순으로 우선순위 부여**
- 우선순위 계산식: <u>**(대기시간 + 서비스 시간) / 서비스 시간**</u>

### 67. 운영체제(OS)
컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어
- 컴퓨터 *<u>사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어</u>*의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.
- 컴퓨터 운영체제의 종류에는 `Windows`, `UNIX`, `Linux`, `Mac OS` 등이, 모바일 운영체제에는 `iOS`, `Android` 등이 있다.
- 운영체제 관련 요구사항 식별 시 고려사항: **가용성, 성능, 기술 지원, 주변 기기, 구축 비용**

### 68. 배치 프로그램(Batch Program)
사용자와의 **상호작용 없이** 여러 작업들을 *<u>미리 정해진 일련의 순서에 따라 일괄적으로 처리</u>*하는 것을 의미한다.

- 배치 프로그램이 갖추어야 하는 필수 요소
1. `대용량 데이터`: 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함
2. `자동화`: 심각한 오류가 발생하는 상황을 제외하고는 **사용자의 개입 없이** 수행되어야 함
3. `견고성`: 잘못된 데이터나 데이터 중복 등의 상황으로 **중단되는 일 없이 수행**되어야 함
4. `안정성/신뢰성`: 오류가 발생하면 **오류의 발생 위치, 시간 등을 추적할 수 있어야 함**

### 69. TCP(Transmission Control Protocol)
- **양방향 연결**(Full Duplex Connection)형 서비스를 제공함
- **스트림 위주의 전달**(패킷 단위)를 함
- **신뢰성 있는 경로를 확립**하고 메세지 전송을 감독함
- **순서 제어, 오류 제어, 흐름 제어**기능을 함
- TCP 프로토콜의 헤더는 기본적으로 **20Byte에서 60Byte**까지 사용할 수 있는데, 선택적으로 40Byte를 더 추가할 수 있으므로 **최대 100Byte**까지 크기를 확장할 수 있음

### 70. 순차적 응집도 vs 절차적 응집도
- `순차적 응집도`: 모듈 내 하나의 활동으로부터 나온 **출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우**의 응집도
- `절차적 응집도`: 모듈이 다수의 관련 기능을 가질 때 **모듈 안의 구성 요소들이 그 기능을 순차적으로 수행**할 경우의 응집도

### 71. 데이터 링크 계층(Data Link Layer)
- 두 개의 인접한 개방 시스템들 간에 *<u>신뢰성 있고 효율적인 정보 전송</u>*을 할 수 있도록 **시스템간 연결 설정과 유지 및 종료**를 담당함
- 송신 측과 수신 측의 속도 차이를 해결하기 위한 **흐름 제어** 기능을 함
- 프레임의 시작과 끝을 구분하기 위한 **프레임의 동기화**기능을 함
- 오류의 검출과 회복을 위한 **오류 제어**기능을 함

### 72. 결합도(Coupling)
`내용 결합도` > `공통(공유)결합도` > `외부 결합도` > `제어 결합도` > `스탬프(검인) 결합도` > `자료 결합도`

### 73. 기억장치 관리 - 배치(Placement)전략
배치 전략은 새로 반입되는 프로그램이나 데이터를 주기억장치위 어디에 위치시킬 것인지를 결정하는 전략이다.

1. `최초 적합(First fit)`: 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 **첫 번째 분할 영역**에 배치시키는 방법
2. `최적 적합(Best Fit)`: 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 **단편화를 가장 작게 남기는 분할 영역에 배치**시키는 방법
3. `최악 적합(Worst Fit)`: 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 **단편화를 가장 많이 남기는 분할 영역에 배치**시키는 방법

> **단편화** : 메모리를 할당할 때, 프로세스가 필요로 하는 크기보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 상황

### 74. IP 주소(Internet Protocol Address)
IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다.
- 숫자로 8비트씩 4부분, **총 32비트**로 구성되어 있다.
- IP 주소는 네트워크 부분의 길이에 따라 다음과 같이 A 클래스에서 E 클래스까지 총 5단계로 구성되어 있다.

#### A Class (~127)
- 국가나 대형 통신망에 사용(**0~127로 시작**), 2^24 = 16,777,216 개의 호스트 사용 가능

#### B Class (128~191)
- 중대형 통신망에 사용(**128~191로 시작**), 2^16 = 65,536개의 호스트 사용가능

#### C Cass (192~223)
- 소규모 통신망에 사용 (**192~223으로 시작**), 2^8 = 256개의 호스트 사용 가능

#### D Class(224~239)
- 멀티캐스트용으로 사용(**224~239로 시작**)

#### E Class
실험적 주소이며 공용되지 않음

#### 네트워크 서브네팅(Subnetting)
서브네팅은 *<u>할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용</u>*하는 것을 말한다.
- 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 **서브넷 마스크(Subnet MAsk)**라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다.
- 서브넷 마스크는 각 클래스마다 다르게 사용된다.
- 서브넷의 시작 주소: 네트워크 주소 
- 서브넷의 마지막 주소: 브로드캐스트 주소(서브넷의 끝부분에 연속된 0으로 된 비트를 모두 1비트로 변환했을 때)

#### CIDR 숫자
- IP 주소의 **앞에서 가릴 비트의 수**
- `/24` 라면 IP 주소의 총 32비트 중에, mask할 비트 수가 24개라는 뜻

### 75. 파이썬 - 슬라이스(Slice)
- 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라(Slicing) 반환하는 기능이다.
- 형식: `객체명[초기위치:최종위치:증가값]` 
- 초기위치에서 **최종위치 - 1**까지 **증가값만큼 증가**하면서 해당 위치들의 요소들을 반환한다.

### 76. 제어 결합도(control coupling)
- 어떤 모듈이 다른 모듈이 내부 논리 조직을 **제어**하기 위한 목적으로 *<u>제어신호를</u>* 이용하여 통신
- 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 **상위 모듈에게 권리 전도**

### 79. UNIX/LINUX 기본 명령어
- `cat`: **파일 내용**을 화면에 표시함
- `chdir`: *<u>현재 사용할</u>* **디렉터리의 위치를 변경**
- `chmod`: 파일의 보호 모드를 설정하여 파일의 사용 허가를 지정
- `chown`: **소유자를 변경**함
- `cp`: **파일을 복사함**
- `exec`: 새로운 프로세스를 수행함
- `find`: 파일을 찾음
- `fork`: 새로운 프로세스를 **생성**함(하위 프로세스 호출, 프로세스 복제 명령)
- `fsdk`: 파일 시스템을 **검사하고 복원**
- `getpid`: 자신의 프로세스 아이디를 얻음
- `getppid`: 부모 프로세스 아이디를 얻음
- `ls`: 현재 디렉토리 **파일 목록을 확인**
- `mount/unmount`: 파일 시스템 마운팅 / 마운팅 해제
- `rm`: 파일을 삭제함
- `wait`: fork 후 exec에 실행되는 프로세스의 상위 프로세스가 하위 프로세스 종료 등의 event를 기다림

### 80. 자료형
#### C/C++의 데이터 타입 크기 및 기억 범위
1. 문자
- 데이터 타입: `char`
- 크기: 1Byte

2. **부호없는 문자형**
- 데이터 타입: `unsigned char`
- 크기: 1Byte

3. 정수
- `short`: 2byte
- `int`: 4byte
- `long`: **4byte**
- `long long`: 8byte

4. 실수
- `float`: 4byte
- `double`: **8byte**
- `long double`: 8byte

#### JAVA의 데이터 타입 크기 및 기억 범위
1. 문자
- 데이터 타입: `char`
- 크기: **2byte**

2. 정수
- **`byte`: 1byte**
- `short`: 2byte
- `int`: **4byte**
- `long`: 8byte

3. 실수
- `float`: 4byte
- `double`: 8byte

4. 논리
- `boolean`: 1byte

### 82. 정보보안 요소
- 정보보안 3대 요소: 기밀성, 무결성, 가용성
- 그 외 요소: 인증, 부인 방지

### 83. SW 관련 용어
1. 메시업(Meshup)
- **웹에서 제공하는 정보 및 서비스를 이용**하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술. 즉 **다수의 정보원이 제공하는 콘텐츠를 조합하여 하나의 서비스로 제공**하는 웹사이트 또는 애플리케이션

2. 서비스 지향 아키텍처(SOA: Serviced Oriented Architecture)
- 기업의 소프트웨어 인프라인 정보 시스템을 공유과 재사용이 가능한 **서비스 단위나 컴포넌트 중심으로 구축**하는 정보기술 아키텍처
- SOA 기반 애플리케이션 구성 계층: **표현(Presentation)계층, 업무 프로세스(Biz-Process)계층, 서비스 중간(Information)계층, 애플리케이션(Application)계층, 데이터 저장(Resistency) 계층**

3. 디지털 트윈(Digital Twin)
- *<u>현실 속의 사물을 소프트웨어로 가상화</u>*한 모델로, 자동차/항공/에너지/국방/헬스케어 등 여러 분야에서 주목 받음
- 실제 물리적인 자산을 소프트웨어로 가상화함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있고, 자산 최적화, 돌발사고 최적화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있음

4. 텐서플로(TensorFLow)
- 구글의 구글 브레인(Google Brain)팀이 만든, 다양한 작업에 대해 **데이터 흐름 프로그래밍을**을 위한 오픈소스 소프트웨어 라이브러리
- C++ 언어로 제작되었고, 구글 검색/음성 인식/번역 등의 구글 서비스 전반에서 다양하게 사용

5. 도커(Docker)
- **컨테이너 기술을 자동화**하여 쉽게 사용할 수 있게 하는 오픈소스 프로젝트
- 소프트웨어 컨테이너 안에 응용 프로그램들을 배치시키는 일을 자동화해주는 역할을 수행함

6. 스크래피(Scrapy)
**Python 기반의 웹 크롤링 프레임워크**로, 코드 재사용성을 높이는 데 도움이 되며, *<u>대규모의 크롤링 프로젝트에 적합</u>*함.

### 84. 기능점수(FP) 모형 요인
- 자료 입력(입력 양식)
- **정보 출력(출력 보고서)**
- 명령어(사용자 질의수)
- 데이터 파일
- 필요한 외부 루틴과의 인터페이스

### 85. 개인키 암호화 기법(Private Key Encryption)
개인키 암호화 기법은 **동일한 키로 데이터를 암호화하고 복호화**한다.
- 데이터베이스 사용자는 평문의 정보 M을 암호화 알고리즘 E와 개인키 k를 사용하여 암호문 c로 저장시켜 놓으면 사용자는 그 데이터베이스에 접근하기 위해 복호화 알고리즘 D와 개인키 K를 이용하여 다시 평문의 정보 M으로 바꾸어 이용하는 방법이다.
- 개인키 암호화 기법에서 암호화 대상이 n개일 때 사용되는 키의 개수는 `n(n-1)/2`이다.
- 개인키 암호화 기법은 **대칭 암호 기법** 또는 **단일키 암호화 기법**이라고도 한다.
- 개인키 암호화 기법은 한 번에 하나의 *<u>데이터 블록을 암호화</u>*하는 **블록 암호화 방식**과, *<u>평문과 동일한 길이의 스트림을 생성</u>*하여 *<u>비트 단위</u>* 로 암호화 하는 **스트림 암호화 방식**으로 분류된다.

1. 블록 암호화 방식: `DES`, `SEED`, `AES`, `ARIA`
2. 스트림 암호화 방식: `LFSA`, `RC4`

### 86. SLIM
- **Rayleigh-Norden 곡선**과 **Putnam 예측 모델**을 기초로 하여 개발된 자동화 추정 도구

### 87. 양방향 알고리즘 종류
1. `SEED`
- 1999년 **한국인터넷진흥원(KISA)** 에서 개발한 **블록 암호화 알고리즘**
- 블록 크기는 **128비트**이며, 키 길이에 따라 128, 256으로 분류됨

2. `ARIA(Academy, Research Institute, Agency)`
- 2004년 **국가정보원과 산학연합회**가 개발한 **블록 암호화 알고리즘**
- ARIA는 학계, 연구기관, 정부의 영문 앞 글지로 구성됨
- 블록 크기는 **128비트**이며, 키 길이에 따라 *<u>128, 192, 256</u>*으로 분류됨

3. `DES(Data Encryption Standard)`
- 1975년 **미국 NBS**에서 발표한 **개인키 암호화 알고리즘**
- DES를 3번 적용하여 보안을 더욱 강화한 3DES(Triple DES)도 있음
- 블록 크기는 **64비트**이며, 키 길이에 따라 *<u>128, 192, 256</u>*으로 분류됨

4. `AES(Advanced Encryption Standard)`
- 2001년 **미국 표준 기술 연구소**(NST)에서 발표한 개인키 암호화 알고리즘
- DES의 한계를 노린 NST에서 공모한 후 발표
- 블록 크기는 **128비트**이며, 키 길이에 따라 *<u>128, 192, 256</u>*으로 분류됨

5. `RSA(Rivest Shamir Adleman)`
- 1978년 MIT의 라이베스트, 샤미르, 애들먼에 의해 제안된 공개키 암호화 알고리즘
- **큰 숫자를 소인수분해하기 어렵다는 것에 기반**하여 만들어짐
- 공개키와 비밀키를 사용하는데, 여기서 키란 메세지를 열고 잠그는 상수(Constant)를 의미함

### 91. DDoS(Distributed Denial of Service, 분산 서비스 거부)공격
여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 분산 서비스 공격을 수행하는 것으로, 네트워크에서 취약점이 있는 호스트들을 탐색한 후 이들 호스트들에 분산 서비스 공격용 툴을 설치하여 `에이전트(Agent)`로 만든 후 DDoS 공격이 이용한다.
- 공격의 범위를 확대하기 위해 일부 호스트에 다수의 에이전트를 관리할 수 있는 `핸들러(Handler)`프로그램을 설치하여 `마스터(Master)` 로 지정한 후 공격에 이용하기도 한다.

#### 분산 서비스 공격용 툴
**에이전트(Agent)** 의 역할을 수행하도록 설계된 프로그램으로 **데몬(Daemon)**이라고 부르며, 다음과 같은 종류가 있다.
- `Trin00`: 가장 초기 형태의 데몬으로, 주로 **UDP Flooding** 공격을 수행함
- `TFN(Tribe Flooding Network)`: UDP Flooding 뿐만 아니라 **TCP SYN Flood**공격, **ICMP 응답 요청**, **스머핑 공격**등을 수행함
- `TFN2K`: TFN의 확장판
- `Stacheldraht`: 이전 툴들의 기능을 유지하면서, 공격자/마스터/에이전트가 쉽게 노출되지 않도록 **암호화된 통신** 을 수행하며, 툴이 **자동으로 업데이트** 되도록 설계됨

### 92. CPM(Critical Path Method, 임계 경로 기법)
- 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는 데 사용하는 기법
- 노드와 간선으로 구성된 네트워크로 노드는 작업을, 간선은 작업 사이의 전후 의존 관계를 나타냄
- **원형 노드**는 각 작업을 의미하며 각 작업 이름과 소요 기간을 표시하고, **박스 노드**는 이정표를 의미하며 박스 노드 위에는 예상 완료 시간을 표시한다.
- 간선을 나타내는 화살표의 흐름에 따라 각 작업이 진행되며, *<u>전 작업이 완료된 후 다음 작업을 진행</u>*할 수 있다.

### 93. RIP(Routing Information Protocol)
- 현재 가장 널리 사용되는 라우팅 프로토콜로 **거리 벡터 라우팅 프로토콜**이라고도 불리며, 최단 경로 탐색에 **Bellman-Ford** 알고리즘이 사용됨.
- *<u>소규모 동종의 네트워크</u>*(자율 시스템, AS) 내에서 효율적인 방법
- 최대 홉 수를 **15**로 제한하므로 **15 이상의 경우는 도달할 수 없는 네트워크를 의미**하는데 이것은 **대규모 네트워크에서는 RIP를 사용할 수 없음**을 의미함

### 96. 소프트웨어 재사용 방법
- `합성(Composition) 방식`: **모듈(블록)을 조립**하여 소프트웨어를 완성시키는 **블록 구성** 방식
- `생성(Generation) 방식`: **추상적인 명세를 구체화**하여 소프트웨어를 완성시키는 **패턴 구성** 방식

### 98. ISO/IEC
- `ISO/IEC 9126`: 소프트웨어의 **품질 특성과 평가**를 위한 표준 지침으로서 국제 표준으로 널리 사용됨
- `ISO/IEC 25010`: 소프트웨어 **제품에 대한 국제 표준**으로, *<u>2011년에 ISO/IEC 9126을 개정하여 만들었음</u>*
- `ISO/IEC 12119`: ISO/IEC 9126을 준수한 품질 표준으로, **테스트 절차를 포함하여 규정함**
- `ISO/IEC 14598`: **소프트웨어 품질의 측정과 평가의 주요 절차를 규정**힌 표준으로, *<u>개발자/구매자/평가자 별로 수행해야 할 제품 평가 활동을 규정함</u>*

- `ISO/IEC 12207`: **표준 소프트웨어 생명 주기 프로세스**로, 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명주기 표준을 제공
- `ISO/IEC 15504`: **SPICE**

#### SPICE(Software Process Improvement and Capability dEtermination)
SPICE(소프트웨어 처리 개선 및 능력 평가 기준)은 정보시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위해 **소프트웨어 프로세스를 평가 및 개선하는 국제 표준**으로 공식 명칭은 **ISO/IEC 15504**이다.
- SPICE는 **5개의 프로세스 범주**와 **40개의 세부 프로세스**로 구성된다.
- SPICE는 프로세스 수행 능력 단계를 **불완전, 수행, 관리, 확립, 예측, 최적화**의 6단계로 구분한다.

- `불완전(incomplete)`: 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계
- `수행(Performed)`: **프로세스가 수행**되고 **목적이 달성**된 단계
- `관리(Managed)`: **정의된 자원의 한도 내**에서 그 프로세스가 작업 산출물을 인도하는 단계
- `확립(Established)`: **소프트웨어 공학 원칙**에 기반하여 정의된 프로세스가 수행되는 단계
- `예측(Predictable)`: 프로세스가 목적 달성을 위해 통제되고, **양적인 측정**을 통해서 일관되게 수행되는 단계
- `최적화(Optimizing)`: 프로세스 수행을 최적화하고, 지속적은 개선을 통해 업무 목적을 만족시키는 단계

### 99. 소프트웨어 보안 개발 방법론
1. `MS-SDL`
- 마이크로소프트사가 자체적으로 수립한 소프트웨어 개발 모델

2. `Seven Touchpoints`
**실무적으로 검증된 소프트웨어 보안의 모범 사례 7가지** 를 개발 모델에 통합한 것
- **코드 검토**(Code Review)
- **아키텍처 위험 분석**(architectural risk analtsis)
- **침투 테스트**(penetration test)
- **위험 기반 보안 테스트**(risk-base security testing)
- **악용 사례**(abuse case)
- 보안 요구 (security requirement)
- 보안 운영 (security operation)

3. `CLASP`
- Comprehensive, Lightweight Application Sercurity Process
- **소프트웨어 개발 초기 단계**의 보안을 강화하기 위한 정형화된 절차이다.
- **활동 중심, 역할 기반**의 프로세스로 구성되어 있으며 *<u>이미 운영 중인 시스템에 적용하기 좋다.</u>*
- *<u>개념, 역할 기반, 활동 평가, 활동 구현, 취약성</u>*의 5가지 관점에 따라 보안 절차를 진행한다.

4. `CWE`
Common Weakness Enumeration, 소프트웨어 **보안 취약점을 유발하는 원인**을 7가지로 정리한 보안 개발 방법론
- **입력 데이터 검증 및 표현**: 입력값에 대한 잘못된 검증, 잘못된 형식 지정
- **보안 기능**: 부적절한 보안 기능 구현
- **시간 및 상태**: 병렬 시스템 환경에서 부적절한 시간 및 상태 관리
- **에러 처리**: 에러 처리가 미흡하거나 처리 과정에서 중요 정보 포함
- **코드 오류**: 인가되지 않은 사용자에게 데이터 누출
- **캡슐화**: 중요한 데이터 등을 충분히 캡슐화하지 않아 데이터 누출
- **API 오용**: 보안에 취약한 API를 잘못된 방법으로 사용