# 2024년 1회
## 경로 제어 프로토콜(Routing Protocol)
### IGP(Interior Gateway Protocol, 내부 게이트웨이 프로토콜)
하나의 자율 시스템(AS, 하나의 도메인에 속하는 라우터들의 집합) 내의 라우팅 프로토콜

1) RIP(Routing Information Protocol)
- 현재 가장 널리 사용되는 라우팅 프로토콜로 거리 벡터 라우팅 프로토콜이라고도 불리며, 최단 경로 탐색에 Bellman-Ford 알고리즘이 사용됨
- 소규모 동종의 네트워크(자율 시스템, AS)내에서 효율적인 방법
- 최대 홉(Hop) 수를 15로 제한하므로 15 이상의 경우는 도달할 수 없는 네트워크를 의미하는데 이것은 대규모 네트워크에서는 RIP를 사용할 수 없음을 의미함
- 홉 카운트(Hop Count), 즉 라우터의 수를 기준으로 가장 적은 수의 라우터를 거쳐가는 경로를 최적 경로로 선택함
- 라우팅 경로를 30초마다 네트워크의 모든 라우터에 알리며, 180초 이내에 새로운 라우팅 정보가 수신되지 않으면 해당 경로를 이상 상태로 간주함

2) OSPF(Open Shortest Path Fisrst Protocol)
- RIP의 단점을 해결하여 새로운 기능을 지원하는 인터넷 프로토콜로, 대규모 네트워크에서 많이 사용됨.
- 인터넷 망에서 이용자가 최단 경로를 선정할 수 있도록 라우팅 정보에 노드 간의 거리 정보, 링크 상태 정보를 실시간으로 반영하여 최단 경로로 라우팅을 지원함
- 최단 경로 탐색에 다익스트라(Dijkstra) 알고리즘을 사용함
- 라우팅 정보에 변화가 생길 경우 변화된 정보만 네트워크 내의 모든 라우터에 알림
- 하나의 자율 시스템(AS)에서 동작하면서 내부 라우팅 프로토콜의 그룹에 도달함

### EGP (Exterior Gateway Protocol)
자율 시스템(AS) 간의 라우팅, 즉 게이트웨이 간의 라우팅에 사용되는 프로토콜

### BGP(Border Gateway Protocol)
- 자율 시스템(AS)간의 라우팅 프로토콜로, EGP의 단점을 보완하기 위해 만들어졌음
- 초기에 BGP 라우터들이 연결될 떄에는 전체 경로 제어표(라우팅 테이블)을 교환하고, 이후에는 변화된 정보망을 교환함

## 디자인 패턴
모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 얘제

### 생성 패턴(Creational Pattern)
객체의 생성과 참조 과정을 정의하는 패턴
1) 추상 팩토리(Abstract Factory): 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현함
- 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능함
- 키트(Kit) 패턴이라고도 함

2) 빌더(Builder)
- 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함
- 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음

3) 팩토리 메소드(Factory Method)
- 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
- 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함.
- 가상 생성자(Vitual Constructor) 패턴이라고도 함

4) 프로토타입(Prototype)
- 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
- 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용함

5) 싱글톤(Singleton)
- 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음
- 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화할 수 있음

### 구조 패턴(Structural Pattern)
구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴
1) 어댑터(Adapter)
- 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용함

2) 브리지(Bridge)
- 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 기능과 구현을 두 개의 별도 클래스로 구현함

3) 컴포지트(Composite)
- 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
- 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음

4) 데코레이터(Decorator)
- 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
- 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현함

5) 퍼싸드(Facade)
- 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요함

6) 플라이웨이트(Flyweight)
- 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
- 다수의 유사 객체를 생성하거나 조작할 떄 유용하게 사용할 수 있음

7) 프록시(Proxy)
- 접근이 어려운 객체와 여기에 연결하려는 개체 사이에서 인터페이스 역할을 수행하는 패턴으로, 대리자라고도 불림
- 내부에서는 객체 간의 복잡한 관계를 단순하게 정리하고 외부에서는 객체의 세부적인 내용을 숨김

### 행위 패턴(Behavioral Pattern)
행위 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴이다.

1) 책임 연쇄(Chain of Responsibility)
- 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
- 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감

2) 커맨드(Command)
- 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
- 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함

3) 인터프리터(Interpreter)
- 언어에 문법 표현을 정의하는 패턴
- SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용함

4) 반복자(Iterator)
- 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
- 내부 표현 방법의 노출 없이 순차적인 접근이 가능함

5) 중재자(Mediator)
- 수많많은 객체들 간의 복잡한 상호작용을 캡슐화아여 객체로 정의하는 패턴
- 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음

6) 메멘토(Memento)
- 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
- Ctrl + Z와 같은 되돌리기 기능을 개발할 때 주로 이용함

7) 옵서버(Observer)
- 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
- 일대다의 의존성을 정의함
- 주로 분산된 시스템 간에 이벤트를 생성/발행하고, 이를 수신해야 할 때 이용함

8) 상태(State)
- 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리함

9) 전략(Strategy)
- 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
- 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능함

9) 템플릿 메소드(Template Method)
- 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
- 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해 줌

10) 방문자(Visitor)
- 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
- 분리된 처리 기능은 각 클래스를 방문(Visit) 하여 수행됨

## 페이지 교체 알고리즘
- LRU(Least Recently Used)
최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법

- LFU (Least Frequnently Used)
사용 빈도가 가장 적은 페이지를 교체

- NUR (Not Used Recently)
최근에 사용하지 않은 페이지를 교체하는 기법, 참조 비트와 변형 비트가 있음

## 조인
1) 내부 조인(Inner Join)
두 테이블에서 일치하는 조건이 있는 행만 반환

2) 왼쪽 외부 조인
왼쪽 테이블의 모든 행과 오른쪽 테이블에서 일치하는 행을 반환, 일치하지 않는 오른쪽 테이블의 행은 NULL로 채워짐 

3) 오른쪽 외부 조인
오른쪽 테이블의 모든 행과 왼쪽 테이블에서 일치하는 행을 반환, 일치하지 않는 왼쪽 테이블의 행은 NULL로 채워짐

4) 완전 외부 조인
양쪽 테이블의 모든 행을 반환, 일치하지 않는 행은 NULL로 채워짐

5) 자연 조인
두 테이블에서 동일한 이름의 열을 기준으로 일치하는 행을 결합, ON 절이 필요 없으며 동일한 이름의 열만 자동으로 결합함

6) 세타 조인
지정된 조건에 따라 두 테이블을 결합, ON 절을 사용하여 원하는 조건 설정 가능

7) 교차 조인
두 테이블의 모든 행의 조합을 반환, Cartesian Product 라고 부르며 조인 조건 없이 두 테이블의 모든 조합을 생성

8) 자기 조인
동일한 테이블을 두 번 사용하여 자기 자신과 조인, 주로 별칭을 사용하여 두 테이블을 구분함

9) 동등 조인
조인에 사용되는 조건 중 =(equal) 비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성하는 방법