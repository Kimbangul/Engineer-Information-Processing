#### 1. 속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 객체지향 개념
- `캡슐화`: 서로 **관련성이 많은 데이터들과 연산**을 묶는다.
- `클래스`: 하나 이상의 유사한 객체들을 묶는다


#### 2. 버블 정렬(Bubble Sort)
- **서로 인접한** 두 원소를 비교하여 정렬하는 알고리즘
- 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, 이런 식으로 (마지막-1) 번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
- **1회전을 수행하고 나면 가장 큰 자료가 뒤로 이동하므로** 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째까지 자료는 정렬에서 제외된다.

#### 3.저장 레코드의 양식 설계 시 고려 사항
**물리적 데이터베이스 구조**의 기본 데이터 단위인 `저장 레코드` 설계 시 고려해야 할 사항
- 데이터 타입
- 데이터 값의 분포
- 접근 빈도
> 트랜잭션 모델링은 개념적 설계 시 고려한다.

#### 4. 데이터베이스의 개념적 설계 단계
개념적 설계란 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 *<u>현실 세계에 대한 인식을 추상적 개념으로 표현</u>*하는 과정이다.

- 개념적 설계 단계에서는 **개념 스키마 모델링**과 **트랜잭션 모델링**을 병행 수행한다.
- 개념적 설계 단계에서는 요구 분석 단계에서 나온 결과인 요구 조건 명세를 *<u>DBMS에 독립적인</u>* **E-R 다이어그램**으로 작성한다.
- **DBMS에 독립적인 개념 스키마**를 설계한다.
> 트랜잭션 인터페이스 설계는 논리적 설계에서 진행한다.

#### 5. C언어의 문자열 처리 함수
- 표준 라이브러리 `string.h`에서 문자열 처리에 사용되는 기능을 제공함
- `strlen()`: 인수로 전달된 **문자열의 길이를 반환**
- `strcat()`: 하나의 문자열에 **다른 문자열을 연결**, 첫 번째 인수가 기준 문자열이 됨
- `strcpy()`: 문자열을 **복사** 하는 함수, 첫 번째 인수로 전달된 배열에 두 번째 인수로 전달된 문자열을 복사함
- `strcmp()`: 문자열을 **비교** 하는 함수, 첫번째 인수로 전달된 문자열이 더 큰 경우, 같은 경우, 더 작은 경우에 따라 반환 값이 다름(**양수**, **0**, **음수**)
- `strrev()`: 문자열을 거꾸로 뒤집어서 반환해주는 함수

#### 6. C언어 프로그램 실행 결과
```c
#include <stdio.h>
  int main(int argc, char *argv[]){
    int a = 5, b = 3, c = 12;
    int t1, t2, t3
    t1 = a && b; // 실제 데이터(int)가 있고, Truthy한 값으로 판단 -> 1
    t2 = a || b; // 1
    t3 = !c; // 0
    printf("%d", t1 + t2 + t3); // 1 + 1 + 0 = 2
    return 0;
  }
```
- `&&`: **논리 연산자**, 모두 참이면 참(and)
- `||`: **논리 연산자**, 하나라도 참이면 참(or)
- `!`: **논리 연산자**, 부정(not)

#### 7. Python의 시퀀스 자료형
시퀀스 자료형(Sequence Type)이란 *<u>리스트(List), 튜플(Tuple), range, 문자열</u>* 처럼 **값이 연속적으로 이어진 자료형** 을 말한다.

- `리스트(List)`: **다양한 자료형의 값**을 연속적으로 저장하며, *<u>필요에 따라 개수를 늘리거나 줄일 수 있음</u>*, `[]` 으로 둘러쌈
- `튜플(Tuple)`: 리스트처럼 요소를 연속적으로 저장하지만, **요소의 추가, 삭제, 변경이 불가능**함. `()` 으로 둘러쌈
- `range`: **연속된 숫자를 생성**하는 것으로, 리스트, 반복문 등에서 많이 사용됨

#### 8. 사용자 수준의 스레드와 커널 수준의 스레드 비교
##### 커널 레벨 스레드
- 프로세스의 스레드들을 몇몇 프로세서에 **한꺼번에 디스패치**할 수 있기 때문에 *<u>멀티프로세서 환경에서 매우 빠르게 동작</u>*한다.
- 다른 스레드가 입출력 작업을 다 끝낼 때까지 다른 스레드를 사용해 작업을 진행할 수 있다.
- 커널이 **각 스레드들을 개별적으로 관리**할 수 있다.(*<u>독립적인 스케줄링 가능</u>*)
- 커널이 직접 스레드를 제공해 주기 때문에 안정성과 다양한 기능이 제공된다.
- 스케줄링과 동기화를 위해 **커널을 호출하는 데 무겁고 오래 걸린다.**
- 사용자 모드에서 커널 모드로의 전환이 빈번하게 이루어져 **성능 저하**가 발생한다.
- 사용자가 프로그래밍할때 구현이 어렵고 자원을 더 많이 소비함

##### 사용자 레벨 스레드
- 사용자 영역에서 연산을 수행하여 **운영체제에 투명함**
- 커널에 의존적이지 않은 형태로 스레드의 기능을 제공하는 **라이브러리를 활용**하는 방식
- 스케줄링 결정이나 동기화를 위해 커널을 호출하지 않기 때문에 **인터럽트가 발생할 때 커널 레벨 스레드보다 오버헤드가 적음**
- 시스템 전반에 걸친 **스케줄링 우선순위를 지원하지 않는다**.
- 프로세스에 속한 스레드 중 **I/O 작업 등에 의하여 하나라도 블록이 걸린다면 전체 스레드가 블록**된다.

#### 9. C언어 프로그램 실행 결과
```c
#include <stdio.h>
  int main(int argc, char *argv[]){

    int a[] = {14, 22, 30, 38};

    printf("%u, ", &a[2]); // a[2]의 주소, 18
    printf("%u", a);

    return 0
  }
```
> `a[0]`의 주소값이 10일 경우, 다음 C언어 프로그램이 실행되었을 떄의 결과는? (단, int 형의 크기는 4Byte로 가정한다.)
- `a[0]`: 10~13, `a[1]`: 14~17, `a[2]`: 18~21 의 메모리를 갖는다.
- C언어에서 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 **배열의 첫 번째 요소의 <u>주소</u>를 지정**하는 것과 같다.


#### 10. 대칭 암호 알고리즘, 비대칭 암호 알고리즘
> **대칭 암호 알고리즘**: 개인키 암호 방식(비밀키 암호 방식)
- 키 전달 및 관리가 어려움
- 키가 공격자에게 노출되면 보안이 취약해짐
- 키 사이즈가 작고 암호 알고리즘 구조가 간단하여 연산속도가 빨라 효율적인 암호 시스템 구축 가능
- 키를 수신자에게 비밀리에 보냄
- 대칭 암호 알고리즘에서도 키 교환은 필요하다.

> **비대칭 암호 알고리즘**: 공개키 암호 방식 
- 대칭키 알고리즘에 비해 속도가 느림
- 암호화 키와 복호화 키가 다름

#### 11. UML 다이어그램의 종류
##### 구조적 다이어그램의 종류
1. 클래스 다이어그램
- **클래스**와 클래스가 가지는 **속성**, **클래스 사이의 관계**를 표현함. *<u>시스템의 구조를 파악하고 구조상의 문제점을 도출</u>*할 수 있음.

2. 객체 다이어그램
- 클래스에 속한 사물(객체)들, 즉 *<u>인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현</u>*함. 럼바우 객체지향 분석 기법에서 **객체 모델링**에 활용됨.

3. 컴포넌트 다이어그램
- 실제 구현 모듈인 **켬포넌트 간의 관계나 컴포넌트 간의 인터페이스**를 표현함. *<u>노드와 의사소통(통신)</u>* 경로로 표현함. **구현 단계**에서 사용되는 다이어그램

4. **배치 다이어그램**
- 결과물, 프로세스, 컴포넌트 등 **물리적 요소들의 위치를 표현**함. **구현 단계**에서 사용되는 다이어그램

5. 복합체 구조 다이어그램
- 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현함

6. 패키지 다이어그램
- 유스케이스나 클래스 등의 *<u>모델 요소들을 그룹화한 패키지들의 관계</u>*를 표현함

##### 행위 다이어그램의 종류
1. 유스케이스 다이어그램
- *<u>사용자의 요구를 분석하는 것</u>*으로 **기능 모델링** 작업에 사용함. 사용자와 사용 사례로 구성되며, 사용 사례 간에는 여러 형태의 관계로 이루어짐

2. 순차 다이어그램
- 상호 작용하는 시스템이나 객체들이 **주고받는 메세지**를 표현함

3. 커뮤니케이션 다이어그램
- 순차 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메세지를 표현하는데, 메세지 뿐만 아니라 **객체들 간의 연관까지 표현**함

4. 상태 다이어그램
- 하나의 객체가 자신이 속한 클래스의 **상태 변화** 혹은 다른 객체와의 **상호 작용에 따라 상태가 어떻게 변화하는지**를 표현함. 럼바우 객체지향 분석 기법에서 **동적 모델링**에 활용됨

5. 활동 다이어그램
- 시스템이 어떤 기능을 수행하는지 객체의 **처리 로직**이나 **조건에 따른 처리의 흐름**을 순서에 따라 표현함

6. 상호작용 개요 다이어그램
- 상호작용 다이어그램 간의 제어 흐름을 표현함

7. 타이밍 다이어그램
- *<u>객체 상태 변화와 시간 제약</u>*을 **명시적으로 표현**함.

#### 12. 소프트웨어 재공학의 주요 활동
1. 분석(Analysis)
- 기존 소프트웨어 명세서를 확인하여 소프트웨어 동작을 이해하고, 재공학할 대상을 선정하는 활동

2. 재구성(Restructuring)
- 기존 소프트웨어의 *<u>구조를 향상</u>*시키기 위하여 코드를 재구성하는 활동
- 소프트웨어의 기능과 외적인 동작은 *<u>바뀌지 않음</u>*

3. 역공학(Reverse Engineering)
- 기존 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 *<u>분석 및 설계 정보를 재발견하거나 다시 만들어 내는 활동</u>*
- 일반적인 개발 단계와는 반대 방향으로 **기존 코드를 복구**하거나, 기존 소프트웨어의 구성 요소와 그 관계를 파악하여 **설계도를 추출**함

4. 이식(Migration)
- 기존 소프트웨어를 **다른 운영체제나 하드웨어 환경에서 사용할 수 있도록 변환**하는 활동

#### 13. IPv6
- **128비트**의 긴 주소를 사용하여 주소 부족 문제 해결
- IPv4에 비해 빠른 자료 전송 속도
- **인증성, 기밀성, 데이터 무결성**의 지원으로 보안 문제 해결
- IPv4와 호환성이 뛰어남
- 주소의 **확장성, 융통성, 연동성**이 뛰어나며, **실시간 흐름 제어**로 향상된 멀티미디어 기능 지원
- 패킷의 크기를 확장할 수 있으므로 **패킷 크기에 제한이 없다.**
- **2128개**의 주소를 표현할 수 있다.
- **16비트씩 8**부분, 총 128비트로 구성되어 있다.
- *<u>등급별, 서비스별로 패킷을 구분</u>*할 수 있어 품질보장이 용이허다.

#### 14. 캡슐화와 정보은닉
##### 캡슐화
- 데이터와 해당 데이터의 처리 기능을 하나로 묶어냄
- 캡슐화가 되어 있다고 반드시 정보은닉이 되는 것은 아니다.

##### 정보은닉
- 캡슐 내의 요소들에 대한 세부 구현사항을 외부에 숨기는 장치
- 다른 객체에게 자신의 정보를 숨김

#### 15. CSMA/CA vs CSMA/CD
##### CSMA/CA(Carrier Sense Multiple Access / Collision Avoidance)
- OSI 7계층의 **데이터 링크** 계층인 **MAC** 계층에서 동작하는 매체 액세스 방법
- 가장 먼저 매체에 액세스 시도를 한 컴퓨터에게 사용 권한을 주는 방법
- CSMA/CA 는 무선 랜에서 데이터 전송 시 *<u>매체가 비어있음</u>*을 확인한 뒤 충돌을 피하기 위해 일정한 시간을 기다린 후 데이터를 전송하는 방법이다.
- **회선을 사용하지 않는 경우에도 확인 신호를 전송**하여 *<u>동시 전송에 의한 충돌</u>*을 예방한다.
- 먼저 데이터를 전송할 컴퓨터는 *<u>회선 상태가 활동 중인지를 감지</u>*한 다음에 회선이 비어있는 상태로 감지하면 데이터를 전송하기 위해 **회선 상에 있는 다른 컴퓨터에게 회선 사용 의도를 알린다.**
> - 회선 감지: 회선 상에 흘러 다니는 데이터가 없는지 감지를 한다. 
> - ENQ 신호 전송: 회선에 데이터가 감지되지 않으면 전체 네트워크 상으로 회선 사용 의도를 알린다.
> - ACK 신호 전송: 전송할 데이터가 없는 노드들은 회선을 사용해도 좋다는 신호를 전송하낟.
> - 데이터 전송: 정상적으로 회선을 사용해도 좋다는 신호를 받으면 즉각 데이터의 전송을 시작한다.

##### CSMA/CD(Carrier Sense Multiple Access/Collision Detection)
- CSMA/CA와 같은 방법으로 동작하나, 회선 상태가 비어 있는 상태로 감지되면 **즉각 데이터 전송**을 하고 만약 충돌이 발생할 경우 **네트워크 상의 다른 컴퓨터에게 충돌 사실을 알린다.**
- 충돌 방생 사실을 전달받은 다른 컴퓨터들은 **임의의 시간 동안 대기한 후 다시 재전송을 시도한다.**
> - 회선 감지: 회선 상에 흘러다니는 데이터가 없는지 감지한다.
> - 데이터 전송: 회선 상에 흘러다니는 데이터가 없으면 즉시 데이터의 전송을 시작한다.
> - 충돌 발생: 동시에 데이터를 전송하면 충돌이 발생하고 충돌 발생 사실을 네트워크상의 다른 컴퓨터에게 알린다.
> - 회선 감지: 충돌 발생 사실을 전달받은 다른 컴퓨터는 임의의 시간 동안 대기한 후 다시 회선 사이의 데이터를 감지한다.

#### 16. 메시지 지향 미들웨어(Message-Oriented Middlware, MOM)
- *<u>메시지 기반의</u>*의 **비동기형 메시지**를 전달하는 방식의 미들웨어
- *<u>온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기</u>*를 위해 사용
- `Queue`, `Broadcast`, `Multicast` 방식으로 메세지를 전달함
- 메세지를 발행하는 `Publisher(Producer)`와 메세지를 구독하는 `Subscribe(Consumer)`로 구성
- 송신측과 수신측의 연결 시 메시지 큐를 활용

#### 17. 유스케이스(Use Case)의 구성 요소 간 관계
- 유스케이스 다이어그램에서 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있으며 **연관 관계/포함관계/확장관계/일반화관계**를 포함할 수 있음

#### 18. 워크스루(Walkthrough)
- 개발자가 자체적으로 수행하며 *<u>계획없이 임의적으로 실시</u>*한다.
- 개발자가 코드를 읽고, 동료가 결함을 지적하거나 개선안을 제시한다. 
- 작성자는 결함이나 제안사항을 개별 기록한다. 
- 별도의 진행자는 없다.
- 사용사례를 확장하여 명세하거나 설계 다이어그램, 원시코드, 테스트 케이스 등에 적용 할 수 있다.
- *<u>복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해</u>*하려고 할때 유용하다.
- 단순한 테스트 케이스를 이용하여 **프로덕트를 수작업으로 수행**해 보는 것이다.
- 요구사항 명세서 작성자를 포함하여 사전 검토(**요구사항 명세서를 미리 배포**)한 후에 짧은 검토 회의를 통해 결함을 발견한다.

#### 19. 인터페이스 구현 검증 도구
- 인터페이스 구현을 검증하기 위해서는 *<u>인터페이스 단위 기능과 시나리오</u>* 등을 기반으로 하는 통합 테스트가 필요하다.
- 통합 테스트는 다음과 같은 테스트 자동화 도구를 이용하면 효율적으로 수행 가능함

1. `xUnit`
- 같은 테스트 코드를 여러번 작성하지 않게 도와주고, 테스트마다 예상 결과를 기억할 필요가 없게 하는 자동화된 해법을 제공하는 *<u>단위 테스트 프레임워크</u>*
- Smalltalk에 처음 적용되어 `SUnit` 이라는 이름이었으나 Java용의 **JUnit**, C++ 용의 **CppUnit**, .NET용의 **NUnit**, Http용의 **HttpUnit** 등 다양한 언어에 적용되면서 xUnit으로 통칭되고 있음

2. `STAF`
- 서비스 호출 및 *<u>컴포넌트 재사용</u>* 등 다양한 환경을 지원하는 테스트 프레임워크
- *<u>크로스 플랫폼, 분산 소프트웨어 테스트</u>*환경을 조성할 수 있도록 지원
- 분산 소프트웨어의 경우 각 분산 환경에 설치된 **데몬**이 프로그램 테스트에 대한 응답을 대신하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성함

3. `FitNesse`: **웹 기반** 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크

4. `NTAF`: Fitnesse의 장점인 *<u>협업 기능</u>*과 STAF의 장점인 *<u>재사용 및 확장성</u>*을 통합한 **NHN**의 테스트 자동화 프레임워크

4. `Selenium`: *<u>다양한 브라우저 및 개발 언어</u>*를 지원하는 **웹 애플리케이션 테스트 프레임워크**

5. `waitr`: **Ruby**를 사용하는 애플리케이션 테스트 프레임워크

#### 20. IPv4 header(헤더)
1. `Version 필드(4bit)`
- TCP/IP 제품은 IPv4를 사용한다.

2. `Header Length 필드(4bit)`
- IP 헤드의 길이를 32비트 단위로 나타낸다. 대부분의 IP 헤드의 길이는 **20바이트**이며, 필드 값은 거의 항상 5이다. (5 * 32 = 160bit or 20Byte)

3. `Type-of-Service Flags`
- 서비스의 우선 순위를 제공한다.

4. `Total Packet Length필드 (16bit)`
- 전체 IP 패킷의 길이를 바이트 단위로 나타낸다.
- **IP 헤더 및 데이터를 포함**한 IP 패킷 전체 길이를 바이트 단위로 길이를 표시. (최대값은 65,535 = 2^16 - 1)

5. `Fragment Identifier필드(16Bit)`
- 분열이 발생한 경우, 조각을 다시 결합하고 원래의 데이터를 식별하기 위해서 사용한다.

6. `Fragment Offset필드(13bit)`
- 8바이트 오프셋으로 조각에 저장된 원래 데이터의 바이트 범위를 나타낸다.

7. `Time-to-live 비트(8bit)`
- 데이터를 전달할 수 없는 것으로 판단되어 소멸되기 이전에 데이터가 이동할 수 있는 단계의 수를 나타낸다.
- 1에서 255사이의 값을 지정하며 라우터들은 패킷을 전달 할 때마다 이 값을 하나씩 감소시킨다.

8. `Protocol Identifier 필드(8bit)`
- 수납되는 상위계층 프로토콜의 종류를 나타내는 식별자/유형/번호
- `1 - ICMP`, `2 - IGMP`, `6 - TCP`, `17 - UDP`

9. `Header Checksum 필드(16bit)`
- IP **헤더의 체크섬을 저장**하는 필드
- 체크섬은 네트워크를 통해 전달된 값이 변경되었는지 검사하는 값으로 무결성을 제공한다.
- 패킷이 라우터를 지나갈 때마다 TTL의 값이 변경되므로 Checksum은 항상 재계산된다. (속도가 떨어짐)

10. `Source IP Address 필드(32bit)`
- 출발지 IP 주소

11. `Destination IP Address 필드(32bit)`
- 목적지 IP 주소

#### 21. 보안 관련 용어
1. `서비스형 블록체인(BaaS: BlockChain as a Service)`
- 블록체인(BlockChain)앱의 개발 환경을 *<u>클라우드 기반으로</u>* 제공하는 서비스
- 블록체인 네트워크에 **노드의 추가 및 제거가 용이**하고, 블록체인 플랫폼마다 다른 블록체인 기술을 보다 편리하게 사용할 수 있게 함

2. `OWASP(the Open Web Application Security Project)`
- 웹 정보 노출이나 악성 코드, 스크립트, 보안이 취약한 부분을 연구하는 비영리 단체
- 보안 취약점 중 보안에 미치는 영향이 큰 것을 기준으로 선정한 10대 웹 애플리케이션 취약점을 3~4년에 한 번씩 발표하고 있음

3. `TCP 래퍼(TCP Wrapper)`
- **외부 컴퓨터의 접속 인가 여부를 점검**하여 접속을 허용 및 거부하는 보안용 도구
- 네트워크에 접속하면 로그인한 다른 컴퓨터 사용자의 ID 및 로그를 조회하여 악용이 가능한데, 이것을 방지가히 위한 **방화벽** 역할을 수행함

4. `허니팟(Honeypot)`
- *<u>비정상적인 접근을 탐지</u>*하기 위해 설치해 둔 시스템
- **침입자를 속여 실제 공격을 당하는 것처럼 보여줌**으로써 추적 및 공격기법에 대한 정보를 수집함

5. `DPI(Deep Packet Inspection)`
- *<u>OSI 7 Layer 전 계층의 프로토콜과 패킷 내부</u>*의 콘텐츠를 파악하여 **침입 시도, 해킹 등을 탐지**하고, **트래픽을 조정**하기 위한 **패킷 분석**기술

#### 22. IP 프로토콜의 주요 특징
- **비연결형** 서비스이다.
- **패킷 분할/병합** 기능이 있다.
- *<u>데이터 체크썸은 없으며</u>*, **헤더 체크썸만 제공**한다.
- `Best-effort`: 최선은 다하며 결과를 보장하진 못한다.

#### 23. 하향식 설계 vs 상향식 설계
##### 하향식 설계
> 메인 컴포넌트를 분해하여 아래로 늘어뜨리면서 개발
- 계층 구조상에서 시스템의 주요 컴포넌트들을 찾고 *<u>그것을 낮은 수준의 컴포넌트들로 분해</u>*하는 것으로 메인 모듈의 설계에서 시작하여 단계적으로 구체화 시키는 것
- 통합 검사 시 **인터페이스가 이미 정의되어 있어 통합이 간단**하다.
- 레벨이 낮은 데이터 구조의 세부 사항은 *<u>설계 초기 단계에서 필요</u>*
- 모든 것을 새로 개발해야하는 작업, 시스템 명세가 정확한 경우 적합

##### 상향식 설계
> 밑바닥부터 위를 향해서 설계해 나가는 설계 방식
- 가장 기본적인 컴포넌트들을 먼저 설계하고, 이것을 사용하는 상위 수준의 컴포넌트를 만들어 나가는 것
- 최하위부터 모듈을 설계하고, 모듈이 완성되면 이들을 결합하여 검사한다.
- 기존 컴포넌트를 조합하여 시스템을 개발하는 경우는 상향식이 적합하다.

#### 24. 아키텍처 설계과정
아키텍처의 설계 과정은 *<u>설계 목표 결정, 시스템 타입 결정, 아키텍처 패턴 적용, 서브시스템 구체화, 검토</u>* 순으로 적용한다.

1. `설계 목표 설정`: 시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 **전체 시스템의 설계 목표를 설정**합니다.

2. `시스템 타입 결정`: **시스템과 서브시스템의 타입**을 결정하고, 설계 목표를 고려하여 **아키텍처 패턴을 선택**한다.  

3. `아키텍처 패턴 적용`: 아키텍처 표준을 참조하여 시스템의 표준 아키텍처 패턴을 선택한다.

4. `서브시스템 구체화`: 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의한다.

5. `검토`: 아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계의 기본원리를 만족하는지 등을 검토한다.

#### 25. C언어 프로그램 실행 결과
```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
  int arr[2][3] = {1,2,3,4,5,6};
  int (*p)[3] = NULL; // 특정 사이즈의 배열을 가리키는 배열 포인터
  p = arr; // 배열명 arr만 작성되면 arr[0]과 같기 때문에 배열 p 는 arr[0] 즉, {1,2,3}을 가리킨다.

  printf("%d, ", *(p[0]+1) + *(p[1]+2)); 
  // 인덱스가 없는 배열 이름은 배열의 시작주소(p[0])를 의미하며 그 주소에 +n을 하게되면 배열의 n번째 인덱스의 주소를 얻을 수 있음.
  printf("%d", *(*(p+1)+0) + *(*(p+1)+1));
  // *(*(p[0]+1)+0) + *(*(p[0]+1)+1);
  // *(*p[1]+0) + *(*p[1]+1)
  // *(*p[1]+0) + *(*p[1]+1)
  return 0;
}
```