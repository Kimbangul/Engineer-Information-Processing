#### 1. 속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 객체지향 개념
- `캡슐화`: 서로 **관련성이 많은 데이터들과 연산**을 묶는다.
- `클래스`: 하나 이상의 유사한 객체들을 묶는다


#### 2. 버블 정렬(Bubble Sort)
- **서로 인접한** 두 원소를 비교하여 정렬하는 알고리즘
- 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, 이런 식으로 (마지막-1) 번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
- **1회전을 수행하고 나면 가장 큰 자료가 뒤로 이동하므로** 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째까지 자료는 정렬에서 제외된다.

#### 3.저장 레코드의 양식 설계 시 고려 사항
**물리적 데이터베이스 구조**의 기본 데이터 단위인 `저장 레코드` 설계 시 고려해야 할 사항
- 데이터 타입
- 데이터 값의 분포
- 접근 빈도
> 트랜잭션 모델링은 개념적 설계 시 고려한다.

#### 4. 데이터베이스의 개념적 설계 단계
개념적 설계란 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 *<u>현실 세계에 대한 인식을 추상적 개념으로 표현</u>*하는 과정이다.

- 개념적 설계 단계에서는 **개념 스키마 모델링**과 **트랜잭션 모델링**을 병행 수행한다.
- 개념적 설계 단계에서는 요구 분석 단계에서 나온 결과인 요구 조건 명세를 *<u>DBMS에 독립적인</u>* **E-R 다이어그램**으로 작성한다.
- **DBMS에 독립적인 개념 스키마**를 설계한다.
> 트랜잭션 인터페이스 설계는 논리적 설계에서 진행한다.

#### 5. C언어의 문자열 처리 함수
- 표준 라이브러리 `string.h`에서 문자열 처리에 사용되는 기능을 제공함
- `strlen()`: 인수로 전달된 **문자열의 길이를 반환**
- `strcat()`: 하나의 문자열에 **다른 문자열을 연결**, 첫 번째 인수가 기준 문자열이 됨
- `strcpy()`: 문자열을 **복사** 하는 함수, 첫 번째 인수로 전달된 배열에 두 번째 인수로 전달된 문자열을 복사함
- `strcmp()`: 문자열을 **비교** 하는 함수, 첫번째 인수로 전달된 문자열이 더 큰 경우, 같은 경우, 더 작은 경우에 따라 반환 값이 다름(**양수**, **0**, **음수**)
- `strrev()`: 문자열을 거꾸로 뒤집어서 반환해주는 함수

#### 6. C언어 프로그램 실행 결과
```c
#include <stdio.h>
  int main(int argc, char *argv[]){
    int a = 5, b = 3, c = 12;
    int t1, t2, t3
    t1 = a && b; // 실제 데이터(int)가 있고, Truthy한 값으로 판단 -> 1
    t2 = a || b; // 1
    t3 = !c; // 0
    printf("%d", t1 + t2 + t3); // 1 + 1 + 0 = 2
    return 0;
  }
```
- `&&`: **논리 연산자**, 모두 참이면 참(and)
- `||`: **논리 연산자**, 하나라도 참이면 참(or)
- `!`: **논리 연산자**, 부정(not)

#### 7. Python의 시퀀스 자료형
시퀀스 자료형(Sequence Type)이란 *<u>리스트(List), 튜플(Tuple), range, 문자열</u>* 처럼 **값이 연속적으로 이어진 자료형** 을 말한다.

- `리스트(List)`: **다양한 자료형의 값**을 연속적으로 저장하며, *<u>필요에 따라 개수를 늘리거나 줄일 수 있음</u>*, `[]` 으로 둘러쌈
- `튜플(Tuple)`: 리스트처럼 요소를 연속적으로 저장하지만, **요소의 추가, 삭제, 변경이 불가능**함. `()` 으로 둘러쌈
- `range`: **연속된 숫자를 생성**하는 것으로, 리스트, 반복문 등에서 많이 사용됨

#### 8. 사용자 수준의 스레드와 커널 수준의 스레드 비교
##### 커널 레벨 스레드
- 프로세스의 스레드들을 몇몇 프로세서에 **한꺼번에 디스패치**할 수 있기 때문에 *<u>멀티프로세서 환경에서 매우 빠르게 동작</u>*한다.
- 다른 스레드가 입출력 작업을 다 끝낼 때까지 다른 스레드를 사용해 작업을 진행할 수 있다.
- 커널이 **각 스레드들을 개별적으로 관리**할 수 있다.
- 커널이 직접 스레드를 제공해 주기 때문에 안정성과 다양한 기능이 제공된다.
- 스케줄링과 동기화를 위해 **커널을 호출하는 데 무겁고 오래 걸린다.**
- 사용자 모드에서 커널 모드로의 전환이 빈번하게 이루어져 **성능 저하**가 발생한다.
- 사용자가 프로그래밍할때 구현이 어렵고 자원을 더 많이 소비함

##### 사용자 레벨 스레드
- 사용자 영역에서 연산을 수행하여 **운영체제에 투명함**
- 커널에 의존적이지 않은 형태로 스레드의 기능을 제공하는 **라이브러리를 활용**하는 방식
- 스케줄링 결정이나 동기화를 위해 커널을 호출하지 않기 때문에 **인터럽트가 발생할 때 커널 레벨 스레드보다 오버헤드가 적음**
- 시스템 전반에 걸친 **스케줄링 우선순위를 지원하지 않는다**.
- 프로세스에 속한 스레드 중 **I/O 작업 등에 의하여 하나라도 블록이 걸린다면 전체 스레드가 블록**된다.