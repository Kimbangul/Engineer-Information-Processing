#### 1. 속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 객체지향 개념
- `캡슐화`: 서로 **관련성이 많은 데이터들과 연산**을 묶는다.
- `클래스`: 하나 이상의 유사한 객체들을 묶는다


#### 2. 버블 정렬(Bubble Sort)
- **서로 인접한** 두 원소를 비교하여 정렬하는 알고리즘
- 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, 이런 식으로 (마지막-1) 번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
- **1회전을 수행하고 나면 가장 큰 자료가 뒤로 이동하므로** 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째까지 자료는 정렬에서 제외된다.

#### 3.저장 레코드의 양식 설계 시 고려 사항
**물리적 데이터베이스 구조**의 기본 데이터 단위인 `저장 레코드` 설계 시 고려해야 할 사항
- 데이터 타입
- 데이터 값의 분포
- 접근 빈도
> 트랜잭션 모델링은 개념적 설계 시 고려한다.

#### 4. 데이터베이스의 개념적 설계 단계
개념적 설계란 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 *<u>현실 세계에 대한 인식을 추상적 개념으로 표현</u>*하는 과정이다.

- 개념적 설계 단계에서는 **개념 스키마 모델링**과 **트랜잭션 모델링**을 병행 수행한다.
- 개념적 설계 단계에서는 요구 분석 단계에서 나온 결과인 요구 조건 명세를 *<u>DBMS에 독립적인</u>* **E-R 다이어그램**으로 작성한다.
- **DBMS에 독립적인 개념 스키마**를 설계한다.
> 트랜잭션 인터페이스 설계는 논리적 설계에서 진행한다.

#### 5. C언어의 문자열 처리 함수
- 표준 라이브러리 `string.h`에서 문자열 처리에 사용되는 기능을 제공함
- `strlen()`: 인수로 전달된 **문자열의 길이를 반환**
- `strcat()`: 하나의 문자열에 **다른 문자열을 연결**, 첫 번째 인수가 기준 문자열이 됨
- `strcpy()`: 문자열을 **복사** 하는 함수, 첫 번째 인수로 전달된 배열에 두 번째 인수로 전달된 문자열을 복사함
- `strcmp()`: 문자열을 **비교** 하는 함수, 첫번째 인수로 전달된 문자열이 더 큰 경우, 같은 경우, 더 작은 경우에 따라 반환 값이 다름(**양수**, **0**, **음수**)
- `strrev()`: 문자열을 거꾸로 뒤집어서 반환해주는 함수

#### 6. C언어 프로그램 실행 결과
```c
#include <stdio.h>
  int main(int argc, char *argv[]){
    int a = 5, b = 3, c = 12;
    int t1, t2, t3
    t1 = a && b; // 실제 데이터(int)가 있고, Truthy한 값으로 판단 -> 1
    t2 = a || b; // 1
    t3 = !c; // 0
    printf("%d", t1 + t2 + t3); // 1 + 1 + 0 = 2
    return 0;
  }
```
- `&&`: **논리 연산자**, 모두 참이면 참(and)
- `||`: **논리 연산자**, 하나라도 참이면 참(or)
- `!`: **논리 연산자**, 부정(not)

#### 7. Python의 시퀀스 자료형
시퀀스 자료형(Sequence Type)이란 *<u>리스트(List), 튜플(Tuple), range, 문자열</u>* 처럼 **값이 연속적으로 이어진 자료형** 을 말한다.

- `리스트(List)`: **다양한 자료형의 값**을 연속적으로 저장하며, *<u>필요에 따라 개수를 늘리거나 줄일 수 있음</u>*, `[]` 으로 둘러쌈
- `튜플(Tuple)`: 리스트처럼 요소를 연속적으로 저장하지만, **요소의 추가, 삭제, 변경이 불가능**함. `()` 으로 둘러쌈
- `range`: **연속된 숫자를 생성**하는 것으로, 리스트, 반복문 등에서 많이 사용됨

#### 8. 사용자 수준의 스레드와 커널 수준의 스레드 비교
##### 커널 레벨 스레드
- 프로세스의 스레드들을 몇몇 프로세서에 **한꺼번에 디스패치**할 수 있기 때문에 *<u>멀티프로세서 환경에서 매우 빠르게 동작</u>*한다.
- 다른 스레드가 입출력 작업을 다 끝낼 때까지 다른 스레드를 사용해 작업을 진행할 수 있다.
- 커널이 **각 스레드들을 개별적으로 관리**할 수 있다.(*<u>독립적인 스케줄링 가능</u>*)
- 커널이 직접 스레드를 제공해 주기 때문에 안정성과 다양한 기능이 제공된다.
- 스케줄링과 동기화를 위해 **커널을 호출하는 데 무겁고 오래 걸린다.**
- 사용자 모드에서 커널 모드로의 전환이 빈번하게 이루어져 **성능 저하**가 발생한다.
- 사용자가 프로그래밍할때 구현이 어렵고 자원을 더 많이 소비함

##### 사용자 레벨 스레드
- 사용자 영역에서 연산을 수행하여 **운영체제에 투명함**
- 커널에 의존적이지 않은 형태로 스레드의 기능을 제공하는 **라이브러리를 활용**하는 방식
- 스케줄링 결정이나 동기화를 위해 커널을 호출하지 않기 때문에 **인터럽트가 발생할 때 커널 레벨 스레드보다 오버헤드가 적음**
- 시스템 전반에 걸친 **스케줄링 우선순위를 지원하지 않는다**.
- 프로세스에 속한 스레드 중 **I/O 작업 등에 의하여 하나라도 블록이 걸린다면 전체 스레드가 블록**된다.

#### 9. C언어 프로그램 실행 결과
```c
#include <stdio.h>
  int main(int argc, char *argv[]){

    int a[] = {14, 22, 30, 38};

    printf("%u, ", &a[2]); // a[2]의 주소, 18
    printf("%u", a);

    return 0
  }
```
> `a[0]`의 주소값이 10일 경우, 다음 C언어 프로그램이 실행되었을 떄의 결과는? (단, int 형의 크기는 4Byte로 가정한다.)
- `a[0]`: 10~13, `a[1]`: 14~17, `a[2]`: 18~21 의 메모리를 갖는다.
- C언어에서 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 **배열의 첫 번째 요소의 <u>주소</u>를 지정**하는 것과 같다.


#### 10. 대칭 암호 알고리즘, 비대칭 암호 알고리즘
> **대칭 암호 알고리즘**: 개인키 암호 방식(비밀키 암호 방식)
- 키 전달 및 관리가 어려움
- 키가 공격자에게 노출되면 보안이 취약해짐
- 키 사이즈가 작고 암호 알고리즘 구조가 간단하여 연산속도가 빨라 효율적인 암호 시스템 구축 가능
- 키를 수신자에게 비밀리에 보냄
- 대칭 암호 알고리즘에서도 키 교환은 필요하다.

> **비대칭 암호 알고리즘**: 공개키 암호 방식 
- 대칭키 알고리즘에 비해 속도가 느림
- 암호화 키와 복호화 키가 다름

#### 11. UML 다이어그램의 종류
##### 구조적 다이어그램의 종류
1. 클래스 다이어그램
- **클래스**와 클래스가 가지는 **속성**, **클래스 사이의 관계**를 표현함. *<u>시스템의 구조를 파악하고 구조상의 문제점을 도출</u>*할 수 있음.

2. 객체 다이어그램
- 클래스에 속한 사물(객체)들, 즉 *<u>인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현</u>*함. 럼바우 객체지향 분석 기법에서 **객체 모델링**에 활용됨.

3. 컴포넌트 다이어그램
- 실제 구현 모듈인 **켬포넌트 간의 관계나 컴포넌트 간의 인터페이스**를 표현함. *<u>노드와 의사소통(통신)</u>* 경로로 표현함. **구현 단계**에서 사용되는 다이어그램

4. **배치 다이어그램**
- 결과물, 프로세스, 컴포넌트 등 **물리적 요소들의 위치를 표현**함. **구현 단계**에서 사용되는 다이어그램

5. 복합체 구조 다이어그램
- 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현함

6. 패키지 다이어그램
- 유스케이스나 클래스 등의 *<u>모델 요소들을 그룹화한 패키지들의 관계</u>*를 표현함

##### 행위 다이어그램의 종류
1. 유스케이스 다이어그램
- *<u>사용자의 요구를 분석하는 것</u>*으로 **기능 모델링** 작업에 사용함. 사용자와 사용 사례로 구성되며, 사용 사례 간에는 여러 형태의 관계로 이루어짐

2. 순차 다이어그램
- 상호 작용하는 시스템이나 객체들이 **주고받는 메세지**를 표현함

3. 커뮤니케이션 다이어그램
- 순차 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메세지를 표현하는데, 메세지 뿐만 아니라 **객체들 간의 연관까지 표현**함

4. 상태 다이어그램
- 하나의 객체가 자신이 속한 클래스의 **상태 변화** 혹은 다른 객체와의 **상호 작용에 따라 상태가 어떻게 변화하는지**를 표현함. 럼바우 객체지향 분석 기법에서 **동적 모델링**에 활용됨

5. 활동 다이어그램
- 시스템이 어떤 기능을 수행하는지 객체의 **처리 로직**이나 **조건에 따른 처리의 흐름**을 순서에 따라 표현함

6. 상호작용 개요 다이어그램
- 상호작용 다이어그램 간의 제어 흐름을 표현함

7. 타이밍 다이어그램
- *<u>객체 상태 변화와 시간 제약</u>*을 **명시적으로 표현**함.